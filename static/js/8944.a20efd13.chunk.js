(self.webpackChunkMetaSaga_Warriors=self.webpackChunkMetaSaga_Warriors||[]).push([[8944],{78944:(e,t,r)=>{"use strict";r.d(t,{s:()=>u});var s=r(94572),i=r(37500),n=r(15696),o=r.n(n),f=r(59624);class h{print(){h.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(e,t,i.Buffer.compare);return this.linearSearch(e,t,((e,t)=>e.equals(t)))}static binarySearch(e,t,r){let s=0,i=e.length-1;for(;s<=i;){const n=Math.floor((s+i)/2),o=r(e[n],t);if(0===o){for(let s=n-1;s>=0;s--)if(0!==r(e[s],t))return s+1;return 0}o<0?s=n+1:i=n-1}return-1}binarySearch(e,t,r){return h.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let s=0;s<e.length;s++)if(r(e[s],t))return s;return-1}linearSearch(e,t,r){return h.linearSearch(e,t,r)}static bufferify(e){if(!i.Buffer.isBuffer(e)){if("object"===typeof e&&e.words)return i.Buffer.from(e.toString(l),"hex");if(h.isHexString(e))return i.Buffer.from(e.replace(/^0x/,""),"hex");if("string"===typeof e)return i.Buffer.from(e);if("bigint"===typeof e)return i.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return i.Buffer.from(e.buffer);if("number"===typeof e){let t=e.toString();return t.length%2&&(t="0".concat(t)),i.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return i.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return h.bigNumberify(e)}static bigNumberify(e){if("bigint"===typeof e)return e;if("string"===typeof e)return e.startsWith("0x")&&h.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(i.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){const t=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return BigInt("0x".concat(t))}(e);if("number"===typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"===typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return h.bufferToHex(e,t)}static bufferToHex(e){return"".concat(!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":"").concat((e||i.Buffer.alloc(0)).toString("hex"))}bufferify(e){return h.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(i.Buffer.isBuffer(r))return r;if(this.isHexString(r))return i.Buffer.from(r.replace("0x",""),"hex");if("string"===typeof r)return i.Buffer.from(r);if("bigint"===typeof r)return i.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return i.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const s=function(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex")),n=function(e){const t=new Uint8Array(e);return Array.from(t).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e(s));return i.Buffer.from(n,"hex")}}isHexString(e){return h.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map(((e,r)=>[e,t[r]]))}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var a=h;function l(e){const t=e.words,r=new ArrayBuffer(4*t.length),s=new Uint8Array(r);for(let i=0;i<t.length;i++)s[4*i]=t[i]>>24&255,s[4*i+1]=t[i]>>16&255,s[4*i+2]=t[i]>>8&255,s[4*i+3]=255&t[i];return r}class u extends a{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),(0,s.c)(this,"duplicateOdd",!1),(0,s.c)(this,"concatenator",i.Buffer.concat),(0,s.c)(this,"hashLeaves",!1),(0,s.c)(this,"isBitcoinTree",!1),(0,s.c)(this,"leaves",[]),(0,s.c)(this,"layers",[]),(0,s.c)(this,"sortLeaves",!1),(0,s.c)(this,"sortPairs",!1),(0,s.c)(this,"sort",!1),(0,s.c)(this,"fillDefaultHash",null),(0,s.c)(this,"complete",!1),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"===typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!i.Buffer.isBuffer(r.fillDefaultHash)&&"string"!==typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e,t;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:null!==(e=null===(t=this.fillDefaultHash)||void 0===t?void 0:t.toString())&&void 0!==e?e:null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(i.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let s=0;s<e.length;s+=2){if(s>=r){this.layers[t].push(...e.slice(r));break}if(s+1===e.length&&e.length%2===1){const r=e[e.length-1];let i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([o()(r),o()(r)])),i=o()(this.hashFn(i)),this.layers[t].push(i);continue}if(!this.duplicateOdd){this.layers[t].push(e[s]);continue}}const n=e[s],f=s+1===e.length?n:e[s+1];let h=null;h=this.isBitcoinTree?[o()(n),o()(f)]:[n,f],this.sortPairs&&h.sort(i.Buffer.compare);let a=this.hashFn(this.concatenator(h));this.isBitcoinTree&&(a=o()(this.hashFn(a))),this.layers[t].push(a)}e=this.layers[t]}}addLeaf(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(i.Buffer.compare))),this.leaves.filter((t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves)))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?i.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){if(t[r].equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((e=>this.bufferToHex(e)))}static marshalLeaves(e){return JSON.stringify(e.map((e=>u.bufferToHex(e))),null,2)}static unmarshalLeaves(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(u.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((e,t)=>(Array.isArray(t)?e.push(t.map((e=>this.bufferToHex(e)))):e.push(t),e)),[])}getLayersFlat(){const e=this.layers.reduce(((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e)),[]);return e.unshift(i.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map((e=>this.bufferToHex(e)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?i.Buffer.from([]):this.layers[this.layers.length-1][0]||i.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if("undefined"===typeof e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===i.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s],i=t%2,n=i?t-1:this.isBitcoinTree&&t===e.length-1&&s<this.layers.length-1?t:t+1;n<e.length&&r.push({position:i?"left":"right",data:e[n]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map((e=>this.bufferToHex(e.data)))}getProofs(){const e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,s){const i=t%2;if(-1===e)return void(i||s.push([...r].reverse()));if(t>=this.layers[e].length)return;const n=this.layers[e],o=i?t-1:t+1;let f=!1;o<n.length&&(f=!0,r.push({position:i?"left":"right",data:n[o]}));const h=2*t,a=2*t+1;this.getProofsDFS(e-1,h,r,s),this.getProofsDFS(e-1,a,r,s),f&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((e=>this.bufferToHex(e.data)))}getPositionalHexProof(e,t){return this.getProof(e,t).map((e=>["left"===e.position?0:1,this.bufferToHex(e.data)]))}getProofIndices(e,t){const r=2**t;let s=new Set;for(const h of e){let e=r+h;for(;e>1;)s.add(1^e),e=e/2|0}const i=e.map((e=>r+e)),n=Array.from(s).sort(((e,t)=>e-t)).reverse();s=i.concat(n);const o=new Set,f=[];for(let h of s)if(!o.has(h))for(f.push(h);h>1&&(o.add(h),o.has(1^h));)h=h/2|0;return f.filter((t=>!e.includes(t-r)))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let o=0;o<r;o++){t%2!==0&&s.push({index:o,leavesCount:t}),t=Math.ceil(t/2)}const i=[];let n=e;for(let o=0;o<r;o++){let e=n.map((e=>e%2===0?e+1:e-1)).filter((e=>!n.includes(e)));const t=s.find((e=>{let{index:t}=e;return t===o}));t&&n.includes(t.leavesCount-1)&&(e=e.slice(0,-1)),i.push(e),n=[...new Set(n.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))]}return i}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());if(this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(i.Buffer.compare));let r=e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1));if(!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const s=[],n=[];let o=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],f=this.getPairNode(e,i);s.push(e[i]),f&&n.push(f),o.push(i/2|0)}r=o.filter(((e,t,r)=>r.indexOf(e)===t)),o=[]}return n.filter((e=>!s.includes(e)))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map((t=>e[t]))}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const i of e){const e=[];for(const r of s){if(r%2===0){const t=r+1;if(!s.includes(t)&&i[t]){e.push(i[t]);continue}}const t=r-1;s.includes(t)||!i[t]||e.push(i[t])}r=r.concat(e);const t=new Set;for(const r of s)r%2!==0?r%2!==0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);s=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map((e=>this.bufferToHex(e)))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort(((e,t)=>e===t?0:e>t?1:-1)):e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1)),!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const s=t.map((e=>this.bufferify(e))),i=[],n=[];for(let o=0;o<this.layers.length;o++){const e=this.layers[o];r=r.reduce(((t,r)=>{if(!i.includes(e[r])){const t=this.getPairNode(e,r),o=s.includes(e[r])||s.includes(t);t&&n.push(!o),i.push(e[r]),i.push(t)}return t.push(r/2|0),t}),[])}return n}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let n=0;n<e.length;n++){const t=e[n];let r=null,f=null;if("string"===typeof t)r=this.bufferify(t),f=!0;else if(Array.isArray(t))f=0===t[0],r=this.bufferify(t[1]);else if(i.Buffer.isBuffer(t))r=t,f=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),f="left"===t.position}const h=[];this.isBitcoinTree?(h.push(o()(s)),h[f?"unshift":"push"](o()(r)),s=this.hashFn(this.concatenator(h)),s=o()(this.hashFn(s))):this.sortPairs?-1===i.Buffer.compare(s,r)?(h.push(s,r),s=this.hashFn(this.concatenator(h))):(h.push(r,s),s=this.hashFn(this.concatenator(h))):(h.push(s),h[f?"unshift":"push"](r),s=this.hashFn(this.concatenator(h)))}return 0===i.Buffer.compare(s,r)}verifyMultiProof(e,t,r,s,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,s,n);const o=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),n=n.map((e=>this.bufferify(e)));const f={};for(const[i,l]of this.zip(t,r))f[2**o+i]=l;for(const[i,l]of this.zip(this.getProofIndices(t,o),n))f[i]=l;let h=Object.keys(f).map((e=>Number(e))).sort(((e,t)=>e-t));h=h.slice(0,h.length-1);let a=0;for(;a<h.length;){const e=h[a];if(e>=2&&{}.hasOwnProperty.call(f,1^e)){let t=[f[e-e%2],f[e-e%2+1]];this.sortPairs&&(t=t.sort(i.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];f[e/2|0]=r,h.push(e/2|0)}a+=1}return!t.length||{}.hasOwnProperty.call(f,1)&&f[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const n=t.length,o=s.length,f=[];let h=0,a=0,l=0;for(let u=0;u<o;u++){const e=[s[u]?h<n?t[h++]:f[a++]:r[l++],h<n?t[h++]:f[a++]].sort(i.Buffer.compare);f[u]=this.hashFn(this.concatenator(e))}return 0===i.Buffer.compare(f[o-1],e)}verifyMultiProofForUnevenTree(e,t,r,s,i){e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),i=i.map((e=>this.bufferify(e)));const n=this.calculateRootForUnevenTree(t,r,s,i);return e.equals(n)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map((e=>e.map((e=>this.bufferToHex(e,!1))))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};const s=t.shift(),o=Object.keys(s)[0];if(n[e[r][i]][o]=s[o],t.length){const s=t.shift(),o=Object.keys(s)[0];n[e[r][i]][o]=s[o]}}s.push(n)}t.push(...s)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return(0,f.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(null===e||void 0===e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,s){const i=this.zip(e,t).sort(((e,t)=>{let[r]=e,[s]=t;return r-s})),n=i.map((e=>{let[t]=e;return t})),o=this.getProofIndicesForUnevenTree(n,r);let f=0;const h=[];for(let l=0;l<o.length;l++){const e=o[l],t=f;f+=e.length,h[l]=this.zip(e,s.slice(t,f))}const a=[i];for(let l=0;l<h.length;l++){const e=h[l].concat(a[l]).sort(((e,t)=>{let[r]=e,[s]=t;return r-s})).map((e=>{let[,t]=e;return t})),t=a[l].map((e=>{let[t]=e;return t})),r=[...new Set(t.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))],s=[];for(let i=0;i<r.length;i++){const t=r[i],n=e[2*i],o=e[2*i+1],f=o?this.hashFn(this.concatenator([n,o])):n;s.push([t,f])}a.push(s)}return a[a.length-1][0][1]}}},15696:(e,t,r)=>{var s=r(37500).Buffer;e.exports=function(e){for(var t=new s(e.length),r=0,i=e.length-1;r<=i;++r,--i)t[r]=e[i],t[i]=e[r];return t}},59624:function(e){e.exports=function(){function e(e,t){var r=t?"\u2514":"\u251c";return r+=e?"\u2500 ":"\u2500\u2500\u2510"}function t(e,t){var r=[];for(var s in e)e.hasOwnProperty(s)&&(t&&"function"===typeof e[s]||r.push(s));return r}function r(s,i,n,o,f,h,a){var l,u,c="",g=0,p=o.slice(0);if(p.push([i,n])&&o.length>0&&(o.forEach((function(e,t){t>0&&(c+=(e[1]?" ":"\u2502")+"  "),u||e[0]!==i||(u=!0)})),c+=e(s,n)+s,f&&("object"!==typeof i||i instanceof Date)&&(c+=": "+i),u&&(c+=" (circular ref.)"),a(c)),!u&&"object"===typeof i){var y=t(i,h);y.forEach((function(e){l=++g===y.length,r(e,i[e],l,p,f,h,a)}))}}var s={asLines:function(e,t,s,i){r(".",e,!1,[],t,"function"!==typeof s&&s,i||s)},asTree:function(e,t,s){var i="";return r(".",e,!1,[],t,s,(function(e){i+=e+"\n"})),i}};return s}()}}]);
//# sourceMappingURL=8944.a20efd13.chunk.js.map