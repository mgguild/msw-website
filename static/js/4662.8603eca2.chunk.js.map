{"version":3,"file":"static/js/4662.8603eca2.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/sdk/dist/deployContractDeterministic-0ce6300e.browser.esm.js","../node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js","../node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/sdk/dist/contract-publisher-d9d563f9.browser.esm.js","../node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/sdk/dist/sdk-0d225a7a.browser.esm.js","../node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js"],"sourcesContent":["import { dy as caches, ax as getCreate2FactoryAddress, aJ as fetchAndCacheDeployMetadata, aI as fetchPublishedContractFromPolygon, aE as computeDeploymentInfo, as as GAS_LIMIT_FOR_DEPLOYER, au as DEPLOYER_ABI, at as DEPLOYER_BYTECODE, av as isContractDeployed } from './index-b91bd093.browser.esm.js';\nimport { utils, ContractFactory, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\n\nfunction getFunctionSignature(fnInputs) {\n  return \"(\" + fnInputs.map(i => {\n    return i.type === \"tuple\" ? getFunctionSignature(i.components) : i.type === \"tuple[]\" ? getFunctionSignature(i.components) + `[]` : i.type;\n  }).join(\",\") + \")\";\n}\nfunction generatePluginFunctions(pluginAddress, pluginAbi) {\n  const pluginInterface = new utils.Interface(pluginAbi);\n  const pluginFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n  for (const fnFragment of Object.values(pluginInterface.functions)) {\n    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));\n    if (fn.name.includes(\"_\")) {\n      continue;\n    }\n    pluginFunctions.push({\n      functionSelector: pluginInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs),\n      pluginAddress: pluginAddress\n    });\n  }\n  return pluginFunctions;\n}\nfunction generateExtensionFunctions(extensionAbi) {\n  const extensionInterface = new utils.Interface(extensionAbi);\n  const extensionFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n\n  for (const fnFragment of Object.values(extensionInterface.functions)) {\n    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));\n    if (fn.name.startsWith(\"_\")) {\n      continue;\n    }\n    extensionFunctions.push({\n      functionSelector: extensionInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs)\n    });\n  }\n  return extensionFunctions;\n}\n\n/**\n *\n * Returns txn data for keyless deploys as well as signer deploys.\n * Also provides a list of infra contracts to deploy.\n *\n * @internal\n *\n * @param metadataUri - The metadata uri to use\n * @param storage - The storage to use\n * @param provider - The provider to use\n * @param create2Factory - The create2 factory to use\n */\nasync function getDeploymentInfo(metadataUri, storage, provider, create2Factory, clientId, secretKey) {\n  caches.deploymentPresets = {};\n  const [create2FactoryAddress, {\n    compilerMetadata,\n    extendedMetadata\n  }] = await Promise.all([create2Factory ? create2Factory : getCreate2FactoryAddress(provider), fetchAndCacheDeployMetadata(metadataUri, storage)]);\n  const customParams = {};\n  const finalDeploymentInfo = [];\n  const defaultExtensions = extendedMetadata?.defaultExtensions;\n  if (extendedMetadata?.routerType === \"plugin\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const pluginMetadata = (await Promise.all(publishedExtensions.map(c => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all plugins\n    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(metadata => computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n      metadata: metadata\n    }, clientId, secretKey)));\n\n    // create constructor param input for PluginMap\n    const mapInput = [];\n    pluginMetadata.forEach((metadata, index) => {\n      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);\n      mapInput.push(...input);\n    });\n\n    // get PluginMap deployment transaction\n    const pluginMapTransaction = await computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n      contractName: \"PluginMap\",\n      constructorParams: {\n        _pluginsToAdd: {\n          value: mapInput\n        }\n      }\n    }, clientId, secretKey);\n\n    // address of PluginMap is input for MarketplaceV3's constructor\n    customParams[\"_pluginMap\"] = {\n      value: pluginMapTransaction.transaction.predictedAddress\n    };\n    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);\n  } else if (extendedMetadata?.routerType === \"dynamic\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const extensionMetadata = (await Promise.all(publishedExtensions.map(async c => {\n      return fetchAndCacheDeployMetadata(c.metadataUri, storage);\n    }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all extensions\n    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map(metadata => computeDeploymentInfo(\"extension\", provider, storage, create2FactoryAddress, {\n      metadata: metadata\n    }, clientId, secretKey)));\n\n    // create constructor param input for BaseRouter\n    const routerInput = [];\n    extensionMetadata.forEach((metadata, index) => {\n      const extensionFunctions = generateExtensionFunctions(metadata.abi);\n      routerInput.push({\n        metadata: {\n          name: metadata.name,\n          metadataURI: \"\",\n          implementation: extensionDeploymentInfo[index].transaction.predictedAddress\n        },\n        functions: extensionFunctions\n      });\n    });\n\n    // routerInput as constructor param for BaseRouter\n    customParams[\"_extensions\"] = {\n      value: routerInput\n    };\n    finalDeploymentInfo.push(...extensionDeploymentInfo);\n  }\n  const [implementationDeployInfo, factoryInfo] = await Promise.all([computeDeploymentInfo(\"implementation\", provider, storage, create2FactoryAddress, {\n    metadata: compilerMetadata,\n    constructorParams: customParams\n  }, clientId, secretKey),\n  // get clone factory\n  computeDeploymentInfo(\"infra\", provider, storage, create2FactoryAddress, {\n    contractName: \"TWCloneFactory\"\n  }, clientId, secretKey)]);\n  finalDeploymentInfo.push(factoryInfo);\n  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));\n  finalDeploymentInfo.push(implementationDeployInfo);\n  return finalDeploymentInfo;\n}\n\n/**\n * @internal\n */\nfunction estimateGasForDeploy(initCode) {\n  let gasLimit = utils.arrayify(initCode).map(x => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32000 + 21000;\n  gasLimit = Math.floor(gasLimit * 64 / 63);\n  return gasLimit;\n}\n\n/**\n * @internal\n */\nfunction createTransactionBatches(transactions) {\n  let upperGasLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;\n  transactions = transactions.filter(tx => {\n    return tx.data.length > 0;\n  });\n  if (transactions.length === 0) {\n    return [];\n  }\n  const transactionBatches = [];\n  let sum = 0;\n  let batch = [];\n  transactions.forEach(tx => {\n    const gas = estimateGasForDeploy(tx.data);\n    if (sum + gas > upperGasLimit) {\n      if (batch.length === 0) {\n        transactionBatches.push([tx]);\n      } else {\n        transactionBatches.push(batch);\n        sum = gas;\n        batch = [tx];\n      }\n    } else {\n      sum += gas;\n      batch.push(tx);\n    }\n  });\n  if (batch.length > 0) {\n    transactionBatches.push(batch);\n  }\n  return transactionBatches;\n}\n\n/**\n * @internal\n */\nasync function deployWithThrowawayDeployer(signer, transactions, options) {\n  const transactionBatches = createTransactionBatches(transactions);\n  if (transactionBatches.length === 0) {\n    return;\n  }\n  options?.notifier?.(\"deploying\", \"infra\");\n  const deployTxns = await Promise.all(transactionBatches.map(txBatch => {\n    // Using the deployer contract, send the deploy transactions to common factory with a signer\n    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);\n    return deployer;\n  }));\n  await Promise.all(deployTxns.map(tx => {\n    return tx.deployed();\n  }));\n  options?.notifier?.(\"deployed\", \"infra\");\n}\n\n/**\n * Deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address.\n *\n * @internal\n *\n * @param signer - The signer to use\n * @param bytecode - The bytecode to deploy\n * @param encodedArgs - The encoded constructor args to use\n * @param create2FactoryAddress - The create2 factory address to use\n */\nasync function deployContractDeterministic(signer, transaction, options) {\n  let gasLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 7000000;\n  // Check if the implementation contract is already deployed\n  invariant(signer.provider, \"Provider required\");\n  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);\n  if (!contractDeployed) {\n    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);\n    const tx = {\n      to: transaction.to,\n      data: transaction.data\n    };\n    try {\n      await signer.estimateGas(tx);\n    } catch (e) {\n      console.debug(\"error estimating gas while deploying prebuilt: \", e);\n      tx.gasLimit = BigNumber.from(gasLimit);\n    }\n    options?.notifier?.(\"deploying\", \"preset\");\n    await (await signer.sendTransaction(tx)).wait();\n    options?.notifier?.(\"deployed\", \"preset\");\n  }\n}\n\nexport { deployWithThrowawayDeployer as a, generateExtensionFunctions as b, createTransactionBatches as c, deployContractDeterministic as d, estimateGasForDeploy as e, getDeploymentInfo as g };\n","import { getValidChainRPCs } from '@thirdweb-dev/chains';\n\nfunction isTwUrl(url) {\n  const host = new URL(url).hostname;\n  return host.endsWith(\".thirdweb.com\") || host.endsWith(\".thirdweb-dev.com\") || host === \"localhost\" || host === \"0.0.0.0\";\n}\nfunction getValidPublicRPCUrl(chain) {\n  return getValidChainRPCs(chain).map(rpc => {\n    try {\n      const url = new URL(rpc);\n      // remove client id from url\n      if (url.hostname.endsWith(\".thirdweb.com\")) {\n        url.pathname = \"\";\n        url.search = \"\";\n      }\n      return url.toString();\n    } catch (e) {\n      return rpc;\n    }\n  });\n}\n\nexport { getValidPublicRPCUrl as g, isTwUrl as i };\n","import ContractPublisherAbi from '@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json';\nimport { utils, constants } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { a9 as fetchPreDeployMetadata, a1 as extractConstructorParamsFromAbi, a2 as extractFunctionsFromAbi, cp as RPCConnectionHandler, cq as ContractWrapper, aQ as getContractPublisherAddress, aL as resolveAddress, K as fetchContractMetadataFromAddress, aa as fetchExtendedReleaseMetadata, a4 as resolveContractUriFromAddress, ao as fetchSourceFilesFromMetadata, bw as ProfileSchemaOutput, bx as PublishedContractSchema, a8 as fetchRawPredeployMetadata, Y as fetchContractMetadata, ah as isFeatureEnabled, bj as AbiSchema, aI as fetchPublishedContractFromPolygon, aJ as fetchAndCacheDeployMetadata, aj as joinABIs, am as isIncrementalVersion, bt as FullPublishMetadataSchemaInput } from './index-b91bd093.browser.esm.js';\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-d97b32fd.browser.esm.js';\n\n/**\n * @internal\n */\nasync function extractConstructorParams(predeployMetadataUri, storage) {\n  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractConstructorParamsFromAbi(meta.abi);\n}\n\n/**\n * @internal\n * @param predeployMetadataUri - The predeploy metadata URI to fetch\n * @param storage - The storage to use\n */\nasync function extractFunctions(predeployMetadataUri, storage) {\n  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);\n}\n\n/**\n * Handles publishing contracts (EXPERIMENTAL)\n * @internal\n */\nclass ContractPublisher extends RPCConnectionHandler {\n  constructor(network, options, storage) {\n    super(network, options);\n    this.storage = storage;\n    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisherAbi, options, storage);\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.publisher.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   * @param metadataUri - URI of the contract metadata\n   */\n  async extractConstructorParams(metadataUri) {\n    return extractConstructorParams(metadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployMetadataUri - URI of the predeploy metadata\n   */\n  async extractFunctions(predeployMetadataUri) {\n    return extractFunctions(predeployMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployUri - URI of the predeploy metadata\n   */\n  async fetchCompilerMetadataFromPredeployURI(predeployUri) {\n    return fetchPreDeployMetadata(predeployUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param prepublishUri - URI of the prepublish metadata\n   * @param publisherAddress - Address of the publisher\n   */\n  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {\n    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);\n    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : undefined;\n    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : undefined;\n    return {\n      preDeployMetadata: preDeployMetadataFetched,\n      latestPublishedContractMetadata\n    };\n  }\n\n  /**\n   * @param address - Address of the contract\n   */\n  async fetchCompilerMetadataFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage, this.options);\n  }\n\n  /**\n   * @internal\n   * Get the full information about a published contract\n   * @param contract - Published contract\n   */\n  async fetchPublishedContractInfo(contract) {\n    return {\n      name: contract.id,\n      publishedTimestamp: contract.timestamp,\n      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)\n    };\n  }\n\n  /**\n   * @internal\n   * @param publishedMetadataUri - URI of the published metadata\n   */\n  async fetchFullPublishMetadata(publishedMetadataUri) {\n    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case\n   * // TODO will be easy to do with the multichain pattern of 3.0\n   * @param compilerMetadataUri - URI of the compiler metadata\n   */\n  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {\n    const publishedMetadataUri = await this.publisher.read(\"getPublishedUriFromCompilerUri\", [compilerMetadataUri]);\n    if (publishedMetadataUri.length === 0) {\n      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);\n    }\n    return await Promise.all(publishedMetadataUri.filter(uri => uri.length > 0).map(uri => this.fetchFullPublishMetadata(uri)));\n  }\n\n  /**\n   * @internal\n   * TODO clean this up (see method above, too)\n   */\n  async resolveContractUriFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());\n    invariant(contractUri, \"Could not resolve contract URI from address\");\n    return contractUri;\n  }\n\n  /**\n   * Fetch all sources for a contract from its address\n   * @param address - Address of the contract\n   */\n  async fetchContractSourcesFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);\n    return await fetchSourceFilesFromMetadata(metadata, this.storage);\n  }\n\n  /**\n   * Fetch ABI from a contract, or undefined if not found\n   * @param address - Address of the contract\n   */\n  async fetchContractAbiFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const meta = await fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage);\n    return meta.abi;\n  }\n\n  /**\n   * @internal\n   * @param profileMetadata - Profile metadata\n   */\n  updatePublisherProfile = /* @__PURE__ */buildTransactionFunction(async profileMetadata => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const profileUri = await this.storage.upload(profileMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"setPublisherProfileUri\",\n      args: [publisher, profileUri]\n    });\n  });\n\n  /**\n   * @internal\n   * @param publisherAddress - Address of the publisher\n   */\n  async getPublisherProfile(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const profileUri = await this.publisher.read(\"getPublisherProfileUri\", [resolvedPublisherAddress]);\n    if (!profileUri || profileUri.length === 0) {\n      return {};\n    }\n    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress - Address of the publisher\n   */\n  async getAll(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const data = await this.publisher.read(\"getAllPublishedContracts\", [resolvedPublisherAddress]);\n    // since we can fetch from multiple publisher contracts, just keep the latest one in the list\n    const map = data.reduce((acc, curr) => {\n      // replaces the previous contract with the latest one\n      acc[curr.contractId] = curr;\n      return acc;\n    }, {});\n    return Object.entries(map).map(_ref => {\n      let [, struct] = _ref;\n      return this.toPublishedContract(struct);\n    });\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress - Address of the publisher\n   * @param contractId - ID of the contract\n   */\n  async getAllVersions(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const contractStructs = await this.publisher.read(\"getPublishedContractVersions\", [resolvedPublisherAddress, contractId]);\n    if (contractStructs.length === 0) {\n      throw Error(\"Not found\");\n    }\n    return contractStructs.map(d => this.toPublishedContract(d));\n  }\n  async getVersion(publisherAddress, contractId) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    if (version === \"latest\") {\n      return this.getLatest(resolvedPublisherAddress, contractId);\n    }\n    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(contract => this.fetchPublishedContractInfo(contract)));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.version === version);\n    invariant(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the published timestamp\n    return allVersions.find(contract => contract.timestamp === versionMatch.publishedTimestamp);\n  }\n  async getLatest(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const model = await this.publisher.read(\"getPublishedContract\", [resolvedPublisherAddress, contractId]);\n    if (model && model.publishMetadataUri) {\n      return this.toPublishedContract(model);\n    }\n    return undefined;\n  }\n  publish = /* @__PURE__ */buildTransactionFunction(async (predeployUri, extraMetadata) => {\n    const extraMetadataCleaned = this.cleanupOldPublishFlowData(extraMetadata);\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);\n    const compilerMetadata = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);\n    const isPlugin = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"PluginRouter\");\n    const isDynamic = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"DynamicContract\");\n    extraMetadataCleaned.routerType = isPlugin ? \"plugin\" : isDynamic ? \"dynamic\" : \"none\";\n\n    // For a dynamic contract Router, try to fetch plugin/extension metadata\n    if (isDynamic || isPlugin) {\n      const defaultExtensions = extraMetadataCleaned.defaultExtensions;\n      if (defaultExtensions && defaultExtensions.length > 0) {\n        try {\n          const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n            return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, this.storage, this.options.clientId, this.options.secretKey);\n          }));\n          const publishedExtensionUris = publishedExtensions.map(ext => ext.metadataUri);\n          const extensionABIs = (await Promise.all(publishedExtensionUris.map(async uri => {\n            return fetchAndCacheDeployMetadata(uri, this.storage);\n          }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata.abi);\n          const composite = joinABIs([compilerMetadata.abi, ...extensionABIs]);\n          extraMetadataCleaned.compositeAbi = AbiSchema.parse(composite);\n        } catch {}\n      }\n    }\n\n    // ensure version is incremental\n    const latestContract = await this.getLatest(publisher, predeployMetadata.name);\n    if (latestContract && latestContract.metadataUri) {\n      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);\n      const latestVersion = latestMetadata.publishedMetadata.version;\n      if (!isIncrementalVersion(latestVersion, extraMetadataCleaned.version)) {\n        throw Error(`Version ${extraMetadataCleaned.version} is not greater than ${latestVersion}`);\n      }\n    }\n    const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();\n    const bytecode = fetchedBytecode.startsWith(\"0x\") ? fetchedBytecode : `0x${fetchedBytecode}`;\n    const bytecodeHash = utils.solidityKeccak256([\"bytes\"], [bytecode]);\n    const contractId = predeployMetadata.name;\n    const fullMetadata = await FullPublishMetadataSchemaInput.parseAsync({\n      ...extraMetadataCleaned,\n      metadataUri: predeployMetadata.metadataUri,\n      bytecodeUri: predeployMetadata.bytecodeUri,\n      name: predeployMetadata.name,\n      analytics: predeployMetadata.analytics,\n      publisher\n    });\n    const fullMetadataUri = await this.storage.upload(fullMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"publishContract\",\n      args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, constants.AddressZero],\n      parse: receipt => {\n        const events = this.publisher.parseLogs(\"ContractPublished\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ContractPublished event found\");\n        }\n        const contract = events[0].args.publishedContract;\n        return {\n          receipt,\n          data: async () => this.toPublishedContract(contract)\n        };\n      }\n    });\n  });\n  unpublish = /* @__PURE__ */buildTransactionFunction(async (publisher, contractId) => {\n    const resolvedPublisher = await resolveAddress(publisher);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"unpublishContract\",\n      args: [resolvedPublisher, contractId]\n    });\n  });\n  toPublishedContract(contractModel) {\n    return PublishedContractSchema.parse({\n      id: contractModel.contractId,\n      timestamp: contractModel.publishTimestamp,\n      metadataUri: contractModel.publishMetadataUri\n    });\n  }\n  cleanupOldPublishFlowData(extraMetadata) {\n    if (extraMetadata.compositeAbi) {\n      delete extraMetadata.compositeAbi;\n    }\n    return {\n      ...extraMetadata,\n      isDeployableViaFactory: false,\n      isDeployableViaProxy: false,\n      factoryDeploymentData: {\n        ...extraMetadata.factoryDeploymentData,\n        implementationAddresses: {},\n        factoryAddresses: {}\n      }\n    };\n  }\n}\n\nvar contractPublisher = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ContractPublisher: ContractPublisher\n});\n\nexport { ContractPublisher as C, extractFunctions as a, contractPublisher as c, extractConstructorParams as e };\n","import { a_ as getChainProvider, aI as fetchPublishedContractFromPolygon, aH as THIRDWEB_DEPLOYER$1, aJ as fetchAndCacheDeployMetadata, ax as getCreate2FactoryAddress, aF as encodeConstructorParamsForImplementation, aE as computeDeploymentInfo, av as isContractDeployed, a6 as resolveImplementation, K as fetchContractMetadataFromAddress, ao as fetchSourceFilesFromMetadata, a1 as extractConstructorParamsFromAbi, a4 as resolveContractUriFromAddress, aQ as getContractPublisherAddress, aa as fetchExtendedReleaseMetadata, cp as RPCConnectionHandler, aL as resolveAddress, aM as signTypedDataInternal, aS as ChainId, cq as ContractWrapper, aV as NATIVE_TOKEN_ADDRESS, cr as extractFeatures, ab as detectFeatures, aR as getMultichainRegistryAddress, bj as AbiSchema, ar as COMMON_FACTORY, aw as isEIP155Enforced, cs as CUSTOM_GAS_FOR_CHAIN, aG as getCreate2FactoryDeploymentInfo, aO as CONTRACT_ADDRESSES, ct as AddressZero, P as PackInitializer, b as MarketplaceV3Initializer, M as MarketplaceInitializer, f as SplitInitializer, V as VoteInitializer, g as TokenInitializer, T as TokenDropInitializer, a as EditionInitializer, E as EditionDropInitializer, c as MultiwrapInitializer, e as SignatureDropInitializer, N as NFTCollectionInitializer, d as NFTDropInitializer, aC as computeForwarderAddress, h as PREBUILT_CONTRACTS_MAP, k as getContractName, bF as CommonPlatformFeeSchema, bE as CommonPrimarySaleSchema, bG as CommonTrustedForwarderSchema, bB as CommonContractSchema, bD as CommonRoyaltySchema, bH as CommonSymbolSchema, aA as computeDeploymentAddress, az as getInitBytecodeWithSalt, aT as setSupportedChains, j as getContractTypeForRemoteName, b3 as getSignerAndProvider, ak as getCompositeABI, b1 as isChainConfig, aP as getContractAddressByChainId, cu as getProcessEnv, bR as DropErc721ContractSchema, i as PREBUILT_CONTRACTS_APPURI_MAP, aZ as EventType } from './index-b91bd093.browser.esm.js';\nimport { isBrowser, ThirdwebStorage } from '@thirdweb-dev/storage';\nimport { C as ContractPublisher } from './contract-publisher-d9d563f9.browser.esm.js';\nimport TWRegistryABI from '@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json';\nimport TWRegistryRouterABI from '@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json';\nimport { utils, Contract, Wallet, constants, BigNumber, ContractFactory as ContractFactory$1 } from 'ethers';\nimport { g as getDefaultGasOverrides, d as buildTransactionFunction, T as Transaction, f as buildDeployTransactionFunction, D as DeployTransaction } from './transactions-d97b32fd.browser.esm.js';\nimport { i as isNativeToken, a as fetchCurrencyValue, C as ContractEncoder } from './fetchCurrencyValue-e91195b2.browser.esm.js';\nimport EventEmitter from 'eventemitter3';\nimport invariant from 'tiny-invariant';\nimport { n as normalizePriceValue } from './normalizePriceValue-ce7058bf.browser.esm.js';\nimport { defaultChains } from '@thirdweb-dev/chains';\nimport { GENERATED_ABI } from '@thirdweb-dev/generated-abis';\nimport { g as getDeploymentInfo, c as createTransactionBatches, a as deployWithThrowawayDeployer, d as deployContractDeterministic } from './deployContractDeterministic-0ce6300e.browser.esm.js';\nimport TWFactoryAbi from '@thirdweb-dev/contracts-js/dist/abis/TWFactory.json';\n\nlet alreadyChecked = false;\n\n/**\n * @internal\n */\nfunction checkClientIdOrSecretKey(message, clientId, secretKey) {\n  if (alreadyChecked) {\n    return;\n  }\n  alreadyChecked = true;\n  if (clientId || secretKey) {\n    return;\n  }\n  console.warn(message);\n}\n\n/**\n *\n * @internal\n * @param contractName - The name of the contract to predict the address for\n * @param chainId - The chain id to use\n * @param storage - The storage to use\n */\nasync function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage) {\n  let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n  let clientId = arguments.length > 4 ? arguments[4] : undefined;\n  let secretKey = arguments.length > 5 ? arguments[5] : undefined;\n  let constructorParamMap = arguments.length > 6 ? arguments[6] : undefined;\n  const provider = getChainProvider(chainId, {\n    clientId,\n    secretKey\n  });\n  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER$1, contractName, contractVersion, storage, clientId, secretKey);\n  const publishUri = publishedContract.metadataUri;\n  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);\n  const create2Factory = await getCreate2FactoryAddress(provider);\n  invariant(create2Factory, \"Thirdweb stack not found\");\n  const {\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishUri, storage);\n  let encodedArgs;\n\n  // if pluginMetadata is not empty, then it's a plugin-pattern router contract\n  if (extendedMetadata?.routerType === \"plugin\" || extendedMetadata?.routerType === \"dynamic\") {\n    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);\n    encodedArgs = deploymentInfo.find(contract => contract.type === \"implementation\")?.encodedArgs;\n  } else {\n    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey);\n  }\n  return encodedArgs;\n}\n\n/**\n *\n * @public\n * @param contractName - The name of the contract to predict the address for\n * @param chainId - The chain id to use\n * @param storage - The storage to use\n */\nasync function predictThirdwebContractAddress(contractName, chainId, storage) {\n  let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n  let clientId = arguments.length > 4 ? arguments[4] : undefined;\n  let secretKey = arguments.length > 5 ? arguments[5] : undefined;\n  const provider = getChainProvider(chainId, {\n    clientId,\n    secretKey\n  });\n  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER$1, contractName, contractVersion, storage, clientId, secretKey);\n  const publishUri = publishedContract.metadataUri;\n  const create2Factory = await getCreate2FactoryAddress(provider);\n  invariant(create2Factory, \"Thirdweb stack not found\");\n  const {\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishUri, storage);\n  if (extendedMetadata?.routerType === \"plugin\" || extendedMetadata?.routerType === \"dynamic\") {\n    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);\n    const implementation = deploymentInfo.find(contract => contract.type === \"implementation\")?.transaction.predictedAddress;\n    invariant(implementation, \"Error computing address for plugin router\");\n    return implementation;\n  }\n  const implementation = await computeDeploymentInfo(\"implementation\", provider, storage, create2Factory, {\n    contractName: contractName\n  }, clientId, secretKey);\n  return implementation.transaction.predictedAddress;\n}\n\n/**\n *\n * @public\n * @param contractName - The name of the contract to predict the address for\n * @param chainId - The chain id to use\n * @param storage - The storage to use\n * @param clientId - The client id to use\n */\nasync function getThirdwebContractAddress(contractName, chainId, storage) {\n  let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n  let clientId = arguments.length > 4 ? arguments[4] : undefined;\n  let secretKey = arguments.length > 5 ? arguments[5] : undefined;\n  const provider = getChainProvider(chainId, {\n    clientId: clientId,\n    secretKey: secretKey\n  });\n  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);\n  const isDeployed = await isContractDeployed(contractAddress, provider);\n  invariant(isDeployed, \"Contract not deployed yet\");\n  return contractAddress;\n}\n\nconst VerificationStatus = {\n  FAILED: \"Fail - Unable to verify\",\n  SUCCESS: \"Pass - Verified\",\n  PENDING: \"Pending in queue\",\n  ALREADY_VERIFIED: \"Contract source code already verified\",\n  AUTOMATICALLY_VERIFIED: \"Already Verified\"\n};\n\nconst RequestStatus = {\n  OK: \"1\",\n  NOTOK: \"0\"\n};\n\n//\n// ==================================\n// ======== Core Functions ==========\n// ==================================\n//\n\n/**\n * @public\n *\n * Verifies a Thirdweb Prebuilt Contract, e.g. Marketplace, DropERC721, etc\n *\n * @example\n * ```javascript\n *\n * const explorerAPIUrl = \"\" // e.g. https://api.etherscan.io/api\n * const explorerAPIKey = \"\" // Generate API key on the explorer\n * const chainId = 1 // Change according to the network\n *\n * await sdk.verifier.verifyThirdwebPrebuiltImplementation(\n *   \"DropERC721\",\n *   chainId,\n *   explorerAPIUrl,\n *   explorerAPIKey,\n *   storage // this could be used from the SDK instance, e.g. sdk.storage\n * );\n * ```\n * @param contractName - Name of the contract to verify\n * @param chainId - Chain ID of the network\n * @param explorerAPIUrl - Explorer API URL\n * @param explorerAPIKey - Explorer API Key\n * @param storage - Storage instance\n */\nasync function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage) {\n  let contractVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"latest\";\n  let clientId = arguments.length > 6 ? arguments[6] : undefined;\n  let secretKey = arguments.length > 7 ? arguments[7] : undefined;\n  let constructorArgs = arguments.length > 8 ? arguments[8] : undefined;\n  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);\n  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, contractVersion, clientId, secretKey, constructorArgs);\n  console.info(`Verifying ${contractName} at address ${contractAddress}`);\n  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs?.toString().replace(\"0x\", \"\"));\n  return guid;\n}\n\n/**\n * @public\n *\n * Verifies any contract\n *\n * @example\n * ```javascript\n *\n * const contractAddress = \"\"\n * const explorerAPIUrl = \"\" // e.g. https://api.etherscan.io/api\n * const explorerAPIKey = \"\" // Generate API key on the explorer\n * const chainId = 1 // Change according to the network\n *\n * await sdk.verifier.verify(\n *   contractAddress,\n *   chainId,\n *   explorerAPIUrl,\n *   explorerAPIKey,\n *   storage // this could be used from the SDK instance, e.g. sdk.storage\n * );\n * ```\n * @param contractAddress - Address of the contract to verify\n * @param chainId - Chain ID of the network\n * @param explorerAPIUrl - Explorer API URL\n * @param explorerAPIKey - Explorer API Key\n * @param storage - Storage instance\n */\nasync function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {\n  try {\n    const provider = getChainProvider(chainId, {});\n    contractAddress = (await resolveImplementation(contractAddress, provider)).address;\n    const compilerMetadata = await fetchContractMetadataFromAddress(contractAddress, provider, storage);\n    const compilerVersion = compilerMetadata.metadata.compiler.version;\n    const sources = await fetchSourceFilesFromMetadata(compilerMetadata, storage);\n    const sourcesWithUrl = compilerMetadata.metadata.sources;\n    const sourcesWithContents = {};\n    for (const path of Object.keys(sourcesWithUrl)) {\n      const sourceCode = sources.find(source => path === source.filename);\n      if (!sourceCode) {\n        throw new Error(`Could not find source file for ${path}`);\n      }\n      sourcesWithContents[path] = {\n        content: sourceCode.source\n      };\n    }\n    const compilerInput = {\n      language: \"Solidity\",\n      sources: sourcesWithContents,\n      settings: {\n        optimizer: compilerMetadata.metadata.settings.optimizer,\n        evmVersion: compilerMetadata.metadata.settings.evmVersion,\n        remappings: compilerMetadata.metadata.settings.remappings,\n        outputSelection: {\n          \"*\": {\n            \"*\": [\"abi\", \"evm.bytecode\", \"evm.deployedBytecode\", \"evm.methodIdentifiers\", \"metadata\"],\n            \"\": [\"ast\"]\n          }\n        }\n      }\n    };\n    const compilationTarget = compilerMetadata.metadata.settings.compilationTarget;\n    const targets = Object.keys(compilationTarget);\n    const contractPath = targets[0];\n    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata.abi, provider, storage);\n    const requestBody = {\n      apikey: explorerAPIKey,\n      module: \"contract\",\n      action: \"verifysourcecode\",\n      contractaddress: contractAddress,\n      sourceCode: JSON.stringify(compilerInput),\n      codeformat: \"solidity-standard-json-input\",\n      contractname: `${contractPath}:${compilerMetadata.name}`,\n      compilerversion: `v${compilerVersion}`,\n      constructorArguements: encodedArgs\n    };\n    const parameters = new URLSearchParams({\n      ...requestBody\n    });\n    const result = await fetch(explorerAPIUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      body: parameters.toString()\n    });\n    const data = await result.json();\n    if (data.status === RequestStatus.OK) {\n      return data.result;\n    } else {\n      throw new Error(`${data.result}`);\n    }\n  } catch (e) {\n    throw new Error(e.toString());\n  }\n}\n\n//\n// ==================================\n// ======== Helper Functions ========\n// ==================================\n//\n\n/**\n * @internal\n *\n * Check status of the contract submitted for verification to the explorer\n * @param explorerAPIUrl - Explorer API URL\n * @param explorerAPIKey - Explorer API Key\n * @param guid - GUID of the contract verification\n */\nasync function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {\n  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}\"`;\n  return new Promise((resolve, reject) => {\n    const intervalId = setInterval(async () => {\n      try {\n        const result = await fetch(endpoint, {\n          method: \"GET\"\n        });\n        const data = await result.json();\n        if (data?.result !== VerificationStatus.PENDING) {\n          clearInterval(intervalId);\n          resolve(data);\n        }\n      } catch (e) {\n        clearInterval(intervalId);\n        reject(e);\n      }\n    }, 3000);\n  });\n}\n\n/**\n * @internal\n *\n * Check if the contract is already verified on etherscan\n * @param contractAddress - Address of the contract to verify\n * @param chainId - Chain ID of the network\n * @param explorerAPIUrl - Explorer API URL\n * @param explorerAPIKey - Explorer API Key\n *\n * @param clientId - Client ID: Get from https://thirdweb.com/create-api-key\n */\nasync function isVerifiedOnEtherscan(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, clientId) {\n  const provider = getChainProvider(chainId, {\n    clientId\n  });\n  invariant(await isContractDeployed(contractAddress, provider), \"Contract not deployed yet.\");\n  const endpoint = `${explorerAPIUrl}?module=contract&action=getsourcecode&address=${contractAddress}&apikey=${explorerAPIKey}\"`;\n  try {\n    const result = await fetch(endpoint, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n      }\n    });\n    const data = await result.json();\n    const etherscanResult = data.result[0];\n    if (etherscanResult.ABI === \"Contract source code not verified\") {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    throw new Error(`Error checking verification for contract ${contractAddress}: ${e}`);\n  }\n}\n\n/**\n * @internal\n *\n * Fetch the deploy transaction from the given contract address and extract the encoded constructor parameters\n * @param explorerAPIUrl - Explorer API URL\n * @param explorerAPIKey - Explorer API Key\n * @param contractAddress - Address of the contract to verify\n * @param abi - ABI of the contract to verify\n * @param provider - Provider instance\n * @param storage - Storage instance\n */\nasync function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider, storage) {\n  const constructorParamTypes = extractConstructorParamsFromAbi(abi);\n  if (constructorParamTypes.length === 0) {\n    return \"\";\n  }\n  const result = await fetch(`${explorerAPIUrl}?module=contract&action=getcontractcreation&contractaddresses=${contractAddress}&apikey=${explorerAPIKey}`);\n  const data = await result.json();\n  if (data && data.status === RequestStatus.OK && data.result[0] !== undefined) {\n    const contract = new utils.Interface(abi);\n    const txHash = data.result[0].txHash;\n    let constructorArgs = \"\";\n    if (contract.deploy.inputs.length === 0) {\n      return \"\";\n    }\n    const tx = await provider.getTransaction(txHash);\n    const txDeployBytecode = tx.data;\n\n    // first: attempt to get it from Publish\n    try {\n      const bytecode = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage);\n      if (bytecode) {\n        // contract was realeased, use the deployable bytecode method (proper solution)\n        const bytecodeHex = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n        let create2FactoryAddress;\n        try {\n          create2FactoryAddress = await getCreate2FactoryAddress(provider);\n        } catch (error) {}\n\n        // if deterministic deploy through create2factory, remove salt length too\n        const create2SaltLength = tx.to === create2FactoryAddress ? 64 : 0;\n        constructorArgs = txDeployBytecode.substring(bytecodeHex.length + create2SaltLength);\n      }\n    } catch (e) {\n      // contracts not published through thirdweb\n    }\n\n    // second: attempt to decode it from solc metadata bytecode\n    if (!constructorArgs) {\n      // couldn't find bytecode from Publish, using regex to locate consturctor args thruogh solc metadata\n      // https://docs.soliditylang.org/en/v0.8.17/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n      // {6} = solc version\n      // {4} = 0033, but noticed some contracts have values other than 00 33. (uniswap)\n      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\\w]{6}[\\w]{4})(?!.*\\1)(.*)$/g)];\n\n      // regex finds the LAST occurence of solc metadata bytes, result always in same position\n      if (matches.length > 0) {\n        // TODO: we currently don't handle error string embedded in the bytecode, need to strip ascii (upgradeableProxy) in patterns[2]\n        // https://etherscan.io/address/0xee6a57ec80ea46401049e92587e52f5ec1c24785#code\n        constructorArgs = matches[0][2];\n      }\n    }\n\n    // third: attempt to guess it from the ABI inputs\n    if (!constructorArgs) {\n      // TODO: need to guess array / struct properly\n      const constructorParamByteLength = constructorParamTypes.length * 64;\n      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);\n    }\n    try {\n      // sanity check that the constructor params are valid\n      // TODO: should we sanity check after each attempt?\n      utils.defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);\n    } catch (e) {\n      throw new Error(\"Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.\");\n    }\n    return constructorArgs;\n  } else {\n    // Could not retrieve constructor parameters, using empty parameters as fallback\n    return \"\";\n  }\n}\n\n/**\n * @internal\n *\n * Fetches the Publish metadata on the ContractPublisher registry (on polygon) for the given contract address (on any chain)\n * @param contractAddress - Address of the contract to verify\n * @param provider - Provider instance\n * @param storage - Storage instance\n * @returns\n */\nasync function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage) {\n  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider);\n  if (compilerMetaUri) {\n    const ContractPublisherAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json')).default;\n    const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(\"polygon\", {}));\n    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);\n    if (publishedMetadataUri.length === 0) {\n      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);\n    }\n    const pubmeta = await Promise.all(publishedMetadataUri.filter(uri => uri.length > 0).map(uri => fetchExtendedReleaseMetadata(uri, storage)));\n    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : undefined;\n  }\n  return undefined;\n}\n\n/**\n * Handles verification of new contracts on any EVM\n * @public\n */\nclass ContractVerifier extends RPCConnectionHandler {\n  constructor(network, options, storage) {\n    super(network, options);\n    this.storage = storage;\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n  }\n\n  /**\n   * Verifies a Thirdweb contract\n   *\n   * @example\n   * ```javascript\n   *\n   * // Note: If verifying on a network different from the SDK instance's network,\n   * //       update the verifier's chain/network as below:\n   * //\n   * //       sdk.verifier.updateSignerOrProvider(chainId);\n   *\n   * const explorerAPIUrl = \"\" // e.g. https://api.etherscan.io/api\n   * const explorerAPIKey = \"\" // Generate API key on the explorer\n   *\n   * await sdk.verifier.verifyThirdwebContract(\n   *   \"DropERC721\",\n   *   explorerAPIUrl,\n   *   explorerAPIKey,\n   * );\n   * ```\n   * @param contractName - Name of the contract to verify\n   * @param explorerAPIUrl - Explorer API URL\n   * @param explorerAPIKey - Explorer API key\n   */\n  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey) {\n    let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n    let constructorArgs = arguments.length > 4 ? arguments[4] : undefined;\n    const chainId = (await this.getProvider().getNetwork()).chainId;\n    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, contractVersion, this.options.clientId, this.options.secretKey, constructorArgs);\n    console.info(\"Checking verification status...\");\n    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);\n    console.info(verificationStatus);\n  }\n\n  /**\n   * Verifies any contract\n   *\n   * @example\n   * ```javascript\n   *\n   * // Note: If verifying on a network different from the SDK instance's network,\n   * //       update the verifier's chain/network as below:\n   * //\n   * //       sdk.verifier.updateSignerOrProvider(chainId);\n   *\n   * const contractAddress = \"\"\n   * const explorerAPIUrl = \"\" // e.g. https://api.etherscan.io/api\n   * const explorerAPIKey = \"\" // Generate API key on the explorer\n   *\n   * await sdk.verifier.verifyContract(\n   *   contractAddress,\n   *   explorerAPIUrl,\n   *   explorerAPIKey,\n   * );\n   * ```\n   * @param contractAddress - Address of the contract to verify\n   * @param explorerAPIUrl - Explorer API URL\n   * @param explorerAPIKey - Explorer API key\n   */\n  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {\n    const chainId = (await this.getProvider().getNetwork()).chainId;\n    let encodedArgs;\n    if (constructorArgs) {\n      const paramTypes = Object.values(constructorArgs).map(arg => {\n        invariant(arg.type, \"Param type is required\");\n        return arg.type;\n      });\n      const paramValues = Object.values(constructorArgs).map(arg => {\n        return arg.value;\n      });\n      encodedArgs = utils.defaultAbiCoder.encode(paramTypes, paramValues);\n    }\n    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);\n    console.info(\"Checking verification status...\");\n    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);\n    console.info(verificationStatus);\n  }\n}\n\n/**\n * publicly available wallet for local nodes\n */\nconst LOCAL_NODE_PKEY = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n\n/**\n *\n * {@link UserWallet} events that you can subscribe to using `sdk.wallet.events`.\n *\n * @public\n */\n\n/**\n * Connect and Interact with a user wallet\n * @example\n * ```javascript\n * const balance = await sdk.wallet.balance();\n * ```\n * @public\n */\nclass UserWallet {\n  events = new EventEmitter();\n  constructor(network, options, storage) {\n    this.connection = new RPCConnectionHandler(network, options);\n    this.options = options;\n    this.events = new EventEmitter();\n    this.storage = storage;\n  }\n\n  // TODO disconnect()\n  // TODO switchChain()\n  // TODO tokens()\n  // TODO NFTs()\n\n  // TODO this will become the source of truth of the signer and have every contract read from it\n  // TODO separate signer and provider logics\n  connect(network) {\n    this.connection.updateSignerOrProvider(network);\n    this.events.emit(\"signerChanged\", this.connection.getSigner());\n  }\n\n  /**\n   * Transfer native or ERC20 tokens from this wallet to another wallet\n   * @example\n   * ```javascript\n   *  // transfer 0.8 ETH\n   * await sdk.wallet.transfer(\"0x...\", 0.8);\n   *  // transfer 0.8 tokens of `tokenContractAddress`\n   * await sdk.wallet.transfer(\"0x...\", 0.8, tokenContractAddress);\n   * ```\n   * @param to - the account to send funds to\n   * @param amount - the amount in tokens\n   * @param currencyAddress - Optional - ERC20 contract address of the token to transfer\n   */\n  async transfer(to, amount) {\n    let currencyAddress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NATIVE_TOKEN_ADDRESS;\n    const [resolvedTo, resolvedCurrency, amountInWei] = await Promise.all([resolveAddress(to), resolveAddress(currencyAddress), normalizePriceValue(this.connection.getProvider(), amount, currencyAddress)]);\n    const signer = this.requireWallet();\n    if (isNativeToken(resolvedCurrency)) {\n      // native token transfer\n      const from = await signer.getAddress();\n      const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());\n      const tx = await signer.sendTransaction({\n        from,\n        to: resolvedTo,\n        value: amountInWei,\n        ...gasOverrides\n      });\n      return {\n        receipt: await tx.wait()\n      };\n    } else {\n      // ERC20 token transfer\n      const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n      return {\n        receipt: await this.createErc20(resolvedCurrency, ERC20Abi).sendTransaction(\"transfer\", [resolvedTo, amountInWei])\n      };\n    }\n  }\n\n  /**\n   * Fetch the native or ERC20 token balance of this wallet\n   * @example\n   * ```javascript\n   * // native currency balance\n   * const balance = await sdk.wallet.balance();\n   * // ERC20 token balance\n   * const erc20balance = await sdk.wallet.balance(tokenContractAddress);\n   *\n   * ```\n   */\n  async balance() {\n    let currencyAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NATIVE_TOKEN_ADDRESS;\n    this.requireWallet();\n    const resolvedCurrency = await resolveAddress(currencyAddress);\n    const provider = this.connection.getProvider();\n    let balance;\n    if (isNativeToken(resolvedCurrency)) {\n      balance = await provider.getBalance(await this.getAddress());\n    } else {\n      const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n      balance = await this.createErc20(resolvedCurrency, ERC20Abi).read(\"balanceOf\", [await this.getAddress()]);\n    }\n    return await fetchCurrencyValue(provider, resolvedCurrency, balance);\n  }\n\n  /**\n   * Get the currently connected address\n   * @example\n   * ```javascript\n   * const address = await sdk.wallet.getAddress();\n   * ```\n   */\n  async getAddress() {\n    return await this.requireWallet().getAddress();\n  }\n\n  /**\n   * Get the currently connected wallet's chainId\n   * @internal\n   */\n  async getChainId() {\n    return await this.requireWallet().getChainId();\n  }\n\n  /**\n   * Get the number of transactions sent from this address.\n   * @param blockTag - Optional - the block tag to read the nonce from\n   */\n  async getNonce(blockTag) {\n    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);\n    return txCount;\n  }\n\n  /**\n   * Checks whether there's a signer connected with the SDK\n   * @internal\n   */\n  isConnected() {\n    try {\n      this.requireWallet();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Sign any message with the connected wallet private key\n   * @param message - the message to sign\n   * @returns The signed message\n   *\n   * @example\n   * ```javascript\n   * // This is the message to be signed\n   * const message = \"Sign this message...\";\n   *\n   * // Now we can sign the message with the connected wallet\n   * const signature = await sdk.wallet.sign(message);\n   * ```\n   */\n  async sign(message) {\n    const signer = this.requireWallet();\n    return await signer.signMessage(message);\n  }\n\n  /**\n   * Sign a typed data structure (EIP712) with the connected wallet private key\n   * @param domain - the domain as EIP712 standard\n   * @param types - the structure and data types as defined by the EIP712 standard\n   * @param message - the data to sign\n   * @returns The payload and its associated signature\n   *\n   * @example\n   * ```javascript\n   * // This is the message to be signed\n   * // Now we can sign the message with the connected wallet\n   * const { payload, signature } = await sdk.wallet.signTypedData(\n   *   {\n          name: \"MyEIP721Domain\",\n          version: \"1\",\n          chainId: 1,\n          verifyingContract: \"0x...\",\n        },\n        { MyStruct: [ { name: \"to\", type: \"address\" }, { name: \"quantity\", type: \"uint256\" } ] },\n        { to: \"0x...\", quantity: 1 },\n   * );\n   * ```\n   */\n  async signTypedData(domain, types, message) {\n    return await signTypedDataInternal(this.requireWallet(), domain, types, message);\n  }\n\n  /**\n   * Recover the signing address from a signed message\n   * @param message - the original message that was signed\n   * @param signature - the signature to recover the address from\n   * @returns The address that signed the message\n   *\n   * @example\n   * ```javascript\n   * const message = \"Sign this message...\";\n   * const signature = await sdk.wallet.sign(message);\n   *\n   * // Now we can recover the signing address\n   * const address = sdk.wallet.recoverAddress(message, signature);\n   * ```\n   */\n  recoverAddress(message, signature) {\n    const messageHash = utils.hashMessage(message);\n    const messageHashBytes = utils.arrayify(messageHash);\n    return utils.recoverAddress(messageHashBytes, signature);\n  }\n\n  /**\n   * Send a raw transaction to the blockchain from the connected wallet\n   * @param transactionRequest - raw transaction data to send to the blockchain\n   */\n  async sendRawTransaction(transactionRequest) {\n    const signer = this.requireWallet();\n    // set default gas values\n    const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());\n    transactionRequest = {\n      ...gasOverrides,\n      ...transactionRequest\n    };\n    return signer.sendTransaction(transactionRequest);\n  }\n\n  /**\n   * Execute a raw transaction to the blockchain from the connected wallet and wait for it to be mined\n   * @param transactionRequest - raw transaction data to send to the blockchain\n   */\n  async executeRawTransaction(transactionRequest) {\n    const tx = await this.sendRawTransaction(transactionRequest);\n    return {\n      receipt: await tx.wait()\n    };\n  }\n\n  /**\n   * Request funds from a running local node to the currently connected wallet\n   * @param amount - the amount in native currency (in ETH) to request\n   */\n  async requestFunds(amount) {\n    const chainId = await this.getChainId();\n    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {\n      const localWallet = new UserWallet(new Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options, this.storage);\n      return localWallet.transfer(await this.getAddress(), amount);\n    } else {\n      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);\n    }\n  }\n\n  /** ***********************\n   * PRIVATE FUNCTIONS\n   * ***********************/\n\n  requireWallet() {\n    const signer = this.connection.getSigner();\n    invariant(signer, \"This action requires a connected wallet. Please pass a valid signer to the SDK.\");\n    return signer;\n  }\n  createErc20(currencyAddress, ERC20Abi) {\n    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, ERC20Abi, this.options, this.storage);\n  }\n}\n\n/**\n * Return all the detected features names in the abi\n * @param abi - parsed array of abi entries\n * @returns Array of all detected features names\n * @internal\n * @deprecated use getAllExtensionNames instead\n */\nfunction getAllDetectedFeatureNames(abi) {\n  const features = [];\n  extractFeatures(detectFeatures(abi), features);\n  return features.map(f => f.name);\n}\n\n/**\n * Return all the detected extension names in the abi\n * @param abi - parsed array of abi entries\n * @returns Array of all detected features names\n * @public\n */\nfunction getAllDetectedExtensionNames(abi) {\n  return getAllDetectedFeatureNames(abi);\n}\n\nfunction createStorage(storage, options) {\n  if (storage) {\n    return storage;\n  } else if (options?.gatewayUrls) {\n    return new ThirdwebStorage({\n      gatewayUrls: options.gatewayUrls,\n      clientId: options.clientId,\n      secretKey: options.secretKey\n    });\n  } else {\n    return new ThirdwebStorage({\n      clientId: options?.clientId,\n      secretKey: options?.secretKey\n    });\n  }\n}\n\n/**\n * @internal\n */\nclass MultichainRegistry {\n  constructor(network, storage) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.storage = storage;\n    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWRegistryABI, options, storage);\n    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWRegistryRouterABI, options, storage);\n  }\n  async updateSigner(signer) {\n    this.registryLogic.updateSignerOrProvider(signer);\n    this.registryRouter.updateSignerOrProvider(signer);\n  }\n  async getContractMetadataURI(chainId, address) {\n    return await this.registryLogic.read(\"getMetadataUri\", [chainId, await resolveAddress(address)]);\n  }\n  async getContractMetadata(chainId, address) {\n    const uri = await this.getContractMetadataURI(chainId, address);\n    if (!uri) {\n      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);\n    }\n    // TODO define the metadata JSON schema\n    return await this.storage.downloadJSON(uri);\n  }\n  async getContractAddresses(walletAddress) {\n    return (await this.registryLogic.read(\"getAll\", [await resolveAddress(walletAddress)])).filter(result => utils.isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== constants.AddressZero).map(result => ({\n      address: result.deploymentAddress,\n      chainId: result.chainId.toNumber()\n    }));\n  }\n  addContract = /* @__PURE__ */buildTransactionFunction(async contract => {\n    const deployerAddress = await this.registryRouter.getSignerAddress();\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.registryLogic,\n      method: \"add\",\n      args: [deployerAddress, contract.address, contract.chainId, contract.metadataURI || \"\"]\n    });\n  });\n  addContracts = /* @__PURE__ */buildTransactionFunction(async contracts => {\n    const deployerAddress = await this.registryRouter.getSignerAddress();\n    const encoded = [];\n    const contractEncoder = new ContractEncoder(this.registryLogic);\n    contracts.forEach(contact => {\n      encoded.push(contractEncoder.encode(\"add\", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || \"\"]));\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.registryRouter,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n  removeContract = /* @__PURE__ */buildTransactionFunction(async contract => {\n    const deployerAddress = await this.registryRouter.getSignerAddress();\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.registryLogic,\n      method: \"remove\",\n      args: [deployerAddress, await resolveAddress(contract.address), contract.chainId]\n    });\n  });\n  removeContracts = /* @__PURE__ */buildTransactionFunction(async contracts => {\n    const deployerAddress = await this.registryRouter.getSignerAddress();\n    const contractEncoder = new ContractEncoder(this.registryLogic);\n    const encoded = await Promise.all(contracts.map(async contract => contractEncoder.encode(\"remove\", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.registryRouter,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n}\n\n/**\n *\n * @param abi - The abi to extract params from\n * @param functionName - The function name to extract params from\n * @returns\n * @internal\n */\nfunction extractFunctionParamsFromAbi(abi, functionName) {\n  const parsedAbi = AbiSchema.parse(abi || []);\n  for (const input of parsedAbi) {\n    if (input.type === \"function\" && input.name === functionName) {\n      return input.inputs || [];\n    }\n  }\n  return [];\n}\n\n/**\n *\n * @internal\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param create2Factory - The create2 factory to use\n */\nasync function computeCloneFactoryAddress(provider, storage, create2Factory, clientId, secretKey) {\n  if (!create2Factory) {\n    create2Factory = await getCreate2FactoryAddress(provider);\n  }\n  return (await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n    contractName: \"TWCloneFactory\"\n  }, clientId, secretKey)).transaction.predictedAddress;\n}\n\n/**\n * @internal\n */\nfunction convertParamValues(constructorParamTypes, constructorParamValues) {\n  // check that both arrays are same length\n  if (constructorParamTypes.length !== constructorParamValues.length) {\n    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);\n  }\n  return constructorParamTypes.map((p, index) => {\n    if (p === \"tuple\" || p.endsWith(\"[]\")) {\n      if (typeof constructorParamValues[index] === \"string\") {\n        return JSON.parse(constructorParamValues[index]);\n      } else {\n        return constructorParamValues[index];\n      }\n    }\n    if (p === \"bytes32\") {\n      invariant(utils.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got \"${constructorParamValues[index]}\".`);\n      return utils.hexZeroPad(constructorParamValues[index], 32);\n    }\n    if (p.startsWith(\"bytes\")) {\n      invariant(utils.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got \"${constructorParamValues[index]}\".`);\n      return constructorParamValues[index];\n    }\n    if (p.startsWith(\"uint\") || p.startsWith(\"int\")) {\n      return BigNumber.from(constructorParamValues[index].toString());\n    }\n    return constructorParamValues[index];\n  });\n}\n\n/**\n * Deploy Nick's Create2 factory on a given network.\n * Deployment is keyless. Signer is needed to fund the keyless signer address.\n * Ref: https://github.com/Arachnid/deterministic-deployment-proxy\n *\n * @public\n * @param signer - The signer to use\n */\nasync function deployCreate2Factory(signer, options) {\n  invariant(signer.provider, \"No provider\");\n  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, signer.provider);\n  if (commonFactoryExists) {\n    return COMMON_FACTORY;\n  }\n  const enforceEip155 = await isEIP155Enforced(signer.provider);\n  const networkId = (await signer.provider.getNetwork()).chainId;\n  const chainId = enforceEip155 ? networkId : 0;\n  console.debug(`ChainId ${networkId} enforces EIP155: ${enforceEip155}`);\n  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, {\n    gasPrice: CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice,\n    gasLimit: CUSTOM_GAS_FOR_CHAIN[networkId].gasLimit\n  }) : getCreate2FactoryDeploymentInfo(chainId, {});\n  const factoryExists = await isContractDeployed(deploymentInfo.deployment, signer.provider);\n\n  // deploy community factory if not already deployed\n  if (!factoryExists) {\n    const gasPrice = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasPrice ? CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice : 100 * 10 ** 9;\n    const gasLimit = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasLimit ? CUSTOM_GAS_FOR_CHAIN[networkId].gasLimit : 100000;\n    invariant(gasLimit, \"gasLimit undefined for create2 factory deploy\");\n    invariant(gasPrice, \"gasPrice undefined for create2 factory deploy\");\n\n    // send balance to the keyless signer\n    const valueToSend = BigNumber.from(gasPrice).mul(gasLimit);\n    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(valueToSend)) {\n      await (await signer.sendTransaction({\n        to: deploymentInfo.signer,\n        value: valueToSend\n      })).wait();\n    }\n\n    // deploy\n    try {\n      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);\n      options?.notifier?.(\"deploying\", \"create2Factory\");\n      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();\n      options?.notifier?.(\"deployed\", \"create2Factory\");\n    } catch (err) {\n      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);\n    }\n  }\n  return deploymentInfo.deployment;\n}\n\n/**\n * @public\n */\nconst SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];\n\n/**\n *\n * @param chainId - chain id\n * @returns The array of trusted forwarders for the given chain id\n * @internal\n */\nfunction getDefaultTrustedForwarders(chainId) {\n  const chainEnum = SUPPORTED_CHAIN_IDS.find(c => c === chainId);\n  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum]?.biconomyForwarder : AddressZero;\n  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum]?.openzeppelinForwarder : AddressZero;\n  return [openzeppelinForwarder, biconomyForwarder].filter(a => a !== AddressZero);\n}\n\n/**\n * In the past we default `platform_fee_recipient` and `primary_sale_recipient` to AddressZero.\n * However due to a recent change in our smart contract extensions (PrimarySale & PlatformFee), AddressZero is no longer an accepted value for those fields.\n * So now we set the default value to the signer address.\n * https://github.com/thirdweb-dev/contracts/pull/530\n *\n * @param signerAddress - The address of the contract deployer\n * @param recipient - The address that will receive the platform fees and/or sale fees\n * @returns `signerAddress` if the `recipient` is AddressZero, otherwise returns `recipient`\n * @internal\n */\nfunction overrideRecipientAddress(signerAddress, recipient) {\n  if (recipient === constants.AddressZero) {\n    return signerAddress;\n  }\n  return recipient;\n}\n\n/**\n *\n * @param contractType - The contract type to get deploy arguments for\n * @param metadata - The metadata to get deploy arguments for\n * @param contractURI - The contract URI to get deploy arguments for\n * @returns\n * @internal\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// TODO: Update function interface: Remove unused param\nasync function getDeployArguments(contractType, metadata, contractURI, signer, storage) {\n  const signerAddress = await signer.getAddress();\n  const trustedForwarders = [];\n\n  // add any custom forwarders passed in\n  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n    trustedForwarders.push(...metadata.trusted_forwarders);\n  }\n  switch (contractType) {\n    case NFTDropInitializer.contractType:\n    case NFTCollectionInitializer.contractType:\n      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];\n    case SignatureDropInitializer.contractType:\n      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];\n    case MultiwrapInitializer.contractType:\n      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];\n    case EditionDropInitializer.contractType:\n    case EditionInitializer.contractType:\n      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];\n    case TokenDropInitializer.contractType:\n    case TokenInitializer.contractType:\n      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];\n    case VoteInitializer.contractType:\n      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);\n      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];\n    case SplitInitializer.contractType:\n      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map(s => s.address), splitsMetadata.recipients.map(s => BigNumber.from(s.sharesBps))];\n    case MarketplaceInitializer.contractType:\n    case MarketplaceV3Initializer.contractType:\n      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];\n    case PackInitializer.contractType:\n      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);\n      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];\n    default:\n      return [];\n  }\n}\nasync function getTrustedForwarders(provider, storage, contractName) {\n  const chainId = (await provider.getNetwork()).chainId;\n  const chainEnum = SUPPORTED_CHAIN_IDS.find(c => c === chainId);\n  const trustedForwarders = contractName && contractName === PackInitializer.name ? [] : chainEnum ? getDefaultTrustedForwarders(chainId) : [await computeForwarderAddress(provider, storage)]; // TODO: make this default for all chains (standard + others)\n\n  return trustedForwarders;\n}\n\n// @deprecated - should not be needed anymore, rely on the publish data instead\nconst APPROVED_IMPLEMENTATIONS = {\n  [ChainId.Mainnet]: {\n    \"nft-drop\": \"0x60fF9952e0084A6DEac44203838cDC91ABeC8736\",\n    \"edition-drop\": \"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550\",\n    \"token-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\",\n    \"signature-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\"\n  },\n  [ChainId.Polygon]: {\n    \"nft-drop\": \"0xB96508050Ba0925256184103560EBADA912Fcc69\",\n    \"edition-drop\": \"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550\",\n    \"token-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\",\n    \"signature-drop\": \"0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5\"\n  },\n  [ChainId.Fantom]: {\n    \"nft-drop\": \"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2\",\n    \"edition-drop\": \"0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B\",\n    \"token-drop\": \"0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa\",\n    \"signature-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\"\n  },\n  [ChainId.Avalanche]: {\n    \"nft-drop\": \"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6\",\n    \"edition-drop\": \"0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766\",\n    \"token-drop\": \"0xca0B071899E575BA86495D46c5066971b6f3A901\",\n    \"signature-drop\": \"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3\"\n  },\n  [ChainId.Optimism]: {\n    \"nft-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\",\n    \"edition-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\",\n    \"token-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"signature-drop\": \"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD\"\n  },\n  [ChainId.Arbitrum]: {\n    \"nft-drop\": \"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a\",\n    \"edition-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"token-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\",\n    \"signature-drop\": \"0x2dF9851af45dd41C8584ac55D983C604da985Bc7\"\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    \"nft-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"edition-drop\": \"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2\",\n    \"token-drop\": \"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10\",\n    \"signature-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\"\n  },\n  [ChainId.Goerli]: {\n    \"nft-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"edition-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\",\n    \"token-drop\": \"0x5680933221B752EB443654a014f88B101F868d50\",\n    \"signature-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\"\n  },\n  [ChainId.Mumbai]: {\n    \"nft-drop\": \"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a\",\n    \"edition-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"token-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\",\n    \"signature-drop\": \"0x2dF9851af45dd41C8584ac55D983C604da985Bc7\"\n  },\n  [ChainId.FantomTestnet]: {\n    \"nft-drop\": \"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD\",\n    \"edition-drop\": \"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE\",\n    \"token-drop\": \"0xFBd7D24d80ee005671E731a7287DEB6073264dD1\",\n    \"signature-drop\": \"0x5A8eA4Adad8289746D073947BA06D69A62499aaf\"\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    \"nft-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"edition-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\",\n    \"token-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\",\n    \"signature-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\"\n  },\n  [ChainId.OptimismGoerli]: {\n    \"nft-drop\": \"0xCcddcec1831646Beff2753249f1B9C580327E89F\",\n    \"edition-drop\": \"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A\",\n    \"token-drop\": \"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C\",\n    \"signature-drop\": \"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9\"\n  },\n  [ChainId.ArbitrumGoerli]: {\n    \"nft-drop\": \"0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6\",\n    \"edition-drop\": \"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6\",\n    \"token-drop\": \"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3\",\n    \"signature-drop\": \"0xE1eE43D23f247b6A9aF81fcE2766E76709482728\"\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    \"nft-drop\": \"\",\n    \"edition-drop\": \"\",\n    \"token-drop\": \"\",\n    \"signature-drop\": \"\" // TODO\n  },\n  [ChainId.Hardhat]: {\n    \"nft-drop\": \"\",\n    \"edition-drop\": \"\",\n    \"token-drop\": \"\",\n    \"signature-drop\": \"\" // TODO\n  },\n  [ChainId.Localhost]: {\n    \"nft-drop\": \"\",\n    \"edition-drop\": \"\",\n    \"token-drop\": \"\",\n    \"signature-drop\": \"\" // TODO\n  }\n};\n\n/**\n * @internal\n * @param chainId - The chainId to get the approved implementation for\n * @param contractType - The contract type to get the approved implementation for\n */\nfunction getApprovedImplementation(chainId,\n// TODO use SupportedChainId once we deploy to all chains\ncontractType) {\n  if (chainId in APPROVED_IMPLEMENTATIONS) {\n    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];\n    if (contractType in approvedImpls) {\n      return approvedImpls[contractType];\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n */\nclass ContractFactory extends ContractWrapper {\n  // Map from contract type to version to deploy specific versions by default\n  DEFAULT_VERSION_MAP = {\n    [NFTDropInitializer.contractType]: 3,\n    [NFTCollectionInitializer.contractType]: 1,\n    [SignatureDropInitializer.contractType]: 4,\n    [MultiwrapInitializer.contractType]: 1,\n    [EditionDropInitializer.contractType]: 2,\n    [EditionInitializer.contractType]: 1,\n    [TokenDropInitializer.contractType]: 2,\n    [TokenInitializer.contractType]: 1,\n    [VoteInitializer.contractType]: 1,\n    [SplitInitializer.contractType]: 1,\n    [MarketplaceInitializer.contractType]: 2,\n    [MarketplaceV3Initializer.contractType]: 3,\n    [PackInitializer.contractType]: 2\n  };\n  constructor(factoryAddr, network, storage, options) {\n    super(network, factoryAddr, TWFactoryAbi, options, storage);\n    this.storage = storage;\n  }\n  deploy = /* @__PURE__ */buildTransactionFunction(async (contractType, contractMetadata, eventEmitter, version, options, onExecute) => {\n    const contract = PREBUILT_CONTRACTS_MAP[contractType];\n    const metadata = await contract.schema.deploy.parseAsync(contractMetadata);\n\n    // TODO: is there any special pre-processing we need to do before uploading?\n    const contractURI = await this.storage.upload(metadata);\n    const implementationAddress = (await this.getImplementation(contract, version)) || undefined;\n    if (!implementationAddress || implementationAddress === constants.AddressZero) {\n      throw new Error(`No implementation found for ${contractType}`);\n    }\n    const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required to deploy contracts\");\n    const args = await getDeployArguments(contractType, metadata, contractURI, signer, this.storage);\n    const encodedFunc = Contract.getInterface(ABI).encodeFunctionData(\"initialize\", args);\n    const blockNumber = await this.getProvider().getBlockNumber();\n    const salt = options?.saltForProxyDeploy ? utils.id(options.saltForProxyDeploy) : utils.formatBytes32String(blockNumber.toString());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this,\n      method: \"deployProxyByImplementation\",\n      args: [implementationAddress, encodedFunc, salt],\n      parse: receipt => {\n        if (onExecute) {\n          onExecute();\n        }\n        const events = this.parseLogs(\"ProxyDeployed\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ProxyDeployed event found\");\n        }\n        const contractAddress = events[0].args.proxy;\n        eventEmitter.emit(\"contractDeployed\", {\n          status: \"completed\",\n          contractAddress,\n          transactionHash: receipt.transactionHash\n        });\n        return contractAddress;\n      }\n    });\n  });\n\n  // TODO once IContractFactory is implemented, this can be probably be moved to its own class\n  deployProxyByImplementation = /* @__PURE__ */buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, saltForProxyDeploy, onExecute) => {\n    const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);\n    const blockNumber = await this.getProvider().getBlockNumber();\n    const salt = saltForProxyDeploy ? utils.id(saltForProxyDeploy) : utils.formatBytes32String(blockNumber.toString());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this,\n      method: \"deployProxyByImplementation\",\n      args: [implementationAddress, encodedFunc, salt],\n      parse: receipt => {\n        if (onExecute) {\n          onExecute();\n        }\n        const events = this.parseLogs(\"ProxyDeployed\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ProxyDeployed event found\");\n        }\n        const contractAddress = events[0].args.proxy;\n        eventEmitter.emit(\"contractDeployed\", {\n          status: \"completed\",\n          contractAddress,\n          transactionHash: receipt.transactionHash\n        });\n        return contractAddress;\n      }\n    });\n  });\n\n  /**\n   *\n   * @param contractType - the contract type to deploy\n   * @param metadata - the metadata for the contract\n   * @param contractURI - the contract URI\n   * @returns\n   * @internal\n   */\n  async getDeployArguments(contractType, metadata, contractURI) {\n    let trustedForwarders = [];\n    // override default forwarders if custom ones are passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders = metadata.trusted_forwarders;\n    }\n    const signerAddress = await this.getSignerAddress();\n    switch (contractType) {\n      case NFTDropInitializer.contractType:\n      case NFTCollectionInitializer.contractType:\n        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];\n      case SignatureDropInitializer.contractType:\n        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];\n      case MultiwrapInitializer.contractType:\n        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];\n      case EditionDropInitializer.contractType:\n      case EditionInitializer.contractType:\n        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];\n      case TokenDropInitializer.contractType:\n      case TokenInitializer.contractType:\n        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];\n      case VoteInitializer.contractType:\n        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);\n        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];\n      case SplitInitializer.contractType:\n        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map(s => s.address), splitsMetadata.recipients.map(s => BigNumber.from(s.sharesBps))];\n      case MarketplaceInitializer.contractType:\n        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];\n      case MarketplaceV3Initializer.contractType:\n        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceV3Metadata.platform_fee_recipient), marketplaceV3Metadata.platform_fee_basis_points];\n      case PackInitializer.contractType:\n        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);\n        return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];\n      default:\n        return [];\n    }\n  }\n  async getImplementation(contract, version) {\n    const encodedType = utils.formatBytes32String(contract.name);\n    const chainId = await this.getChainID();\n    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);\n    // return approved implementation if it exists and we're not overriding the version\n    if (approvedImplementation && approvedImplementation.length > 0 && version === undefined) {\n      return approvedImplementation;\n    }\n    return this.read(\"getImplementation\", [encodedType, version !== undefined ? version : this.DEFAULT_VERSION_MAP[contract.contractType]]);\n  }\n  async getLatestVersion(contractType) {\n    const name = getContractName(contractType);\n    if (!name) {\n      throw new Error(`Invalid contract type ${contractType}`);\n    }\n    const encodedType = utils.formatBytes32String(name);\n    return this.read(\"currentVersion\", [encodedType]);\n  }\n}\n\n/**\n * @internal\n */\nclass ContractRegistry extends ContractWrapper {\n  constructor(registryAddress, network, storage, TWRegistryABI, options) {\n    super(network, registryAddress, TWRegistryABI, options, storage);\n  }\n  async getContractAddresses(walletAddress) {\n    // TODO @fixme the filter here is necessary because for some reason getAll returns a 0x0 address for the first entry\n    return (await this.read(\"getAll\", [await resolveAddress(walletAddress)])).filter(adr => utils.isAddress(adr) && adr.toLowerCase() !== constants.AddressZero);\n  }\n  addContract = /* @__PURE__ */buildTransactionFunction(async contractAddress => {\n    return await this.addContracts.prepare([contractAddress]);\n  });\n  addContracts = /* @__PURE__ */buildTransactionFunction(async contractAddresses => {\n    const deployerAddress = await this.getSignerAddress();\n    const contractEncoder = new ContractEncoder(this);\n    const encoded = (await Promise.all(contractAddresses.map(addr => resolveAddress(addr)))).map(address => contractEncoder.encode(\"add\", [deployerAddress, address]));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n  removeContract = /* @__PURE__ */buildTransactionFunction(async contractAddress => {\n    return await this.removeContracts.prepare([contractAddress]);\n  });\n  removeContracts = /* @__PURE__ */buildTransactionFunction(async contractAddresses => {\n    const deployerAddress = await this.getSignerAddress();\n    const contractEncoder = new ContractEncoder(this);\n    const encoded = (await Promise.all(contractAddresses.map(addr => resolveAddress(addr)))).map(address => contractEncoder.encode(\"remove\", [deployerAddress, address]));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n}\n\nconst LoyaltyCardContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();\nconst LoyaltyCardContractDeploy = /* @__PURE__ */(() => LoyaltyCardContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();\n\nconst AirdropContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonSymbolSchema))();\nconst AirdropContractDeploy = /* @__PURE__ */(() => AirdropContractInput.merge(CommonTrustedForwarderSchema))();\n\n/**\n * Direct deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address and salt (if provided).\n *\n * @public\n *\n * @param bytecode - The bytecode to deploy\n * @param abi - The abi to use\n * @param signer - The signer to use\n * @param constructorArgs - The constructor args to use\n * @param saltForCreate2 - The salt to use\n */\nasync function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {\n  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;\n  invariant(signer.provider, \"Provider is required\");\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n\n  // 1. Deploy CREATE2 factory (if not already exists)\n  const create2Factory = await deployCreate2Factory(signer);\n\n  // 2. Encode constructor params\n  const constructorParams = extractConstructorParamsFromAbi(abi);\n  const constructorParamTypes = constructorParams.map(p => {\n    return p.type;\n  });\n  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);\n  const paramTypesForEncoder = constructorParams.map(p => {\n    if (p.type === \"tuple[]\") {\n      return utils.ParamType.from(p);\n    } else {\n      return p.type;\n    }\n  });\n  const encodedArgs = utils.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);\n\n  // 3. Construct deployment transaction\n  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);\n  const contractDeployed = await isContractDeployed(address, signer.provider);\n  let initBytecodeWithSalt = \"\";\n  if (!contractDeployed) {\n    console.debug(`deploying contract via create2 factory at: ${address}`);\n    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);\n    const tx = {\n      to: create2Factory,\n      data: initBytecodeWithSalt\n    };\n    try {\n      await signer.estimateGas(tx);\n    } catch (e) {\n      console.debug(\"error estimating gas while deploying prebuilt: \", e);\n      tx.gasLimit = BigNumber.from(gasLimit);\n    }\n\n    // 4. Deploy\n    await (await signer.sendTransaction(tx)).wait();\n  } else {\n    throw new Error(`Contract already deployed at ${address}`);\n  }\n  return address;\n}\n\n/**\n * Direct deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address and salt (if provided).\n *\n * @public\n *\n * @param publishMetadataUri - The metadata uri to use\n * @param signer - The signer to use\n * @param storage - The storage to use\n * @param constructorArgs - The constructor args to use\n * @param saltForCreate2 - The salt to use\n */\nasync function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {\n  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  invariant(extendedMetadata?.deployType === \"standard\", \"Must be direct deploy\");\n  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);\n}\n\n/**\n * Direct deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address and salt (if provided).\n *\n * @public\n *\n * @param contractName - The name of the contract to deploy\n * @param publisherAddress - The publisher address to use\n * @param contractVersion - The contract version to use\n * @param constructorArgs - The constructor args to use\n * @param signer - The signer to use\n * @param storage - The storage to use\n * @param clientId - The client id to use\n * @param secretKey - The secret key to use\n * @param constructorArgs - The constructor args to use\n * @param saltForCreate2 - The salt to use\n */\nasync function directDeployDeterministicPublished(contractName, publisherAddress) {\n  let contractVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n  let constructorArgs = arguments.length > 3 ? arguments[3] : undefined;\n  let signer = arguments.length > 4 ? arguments[4] : undefined;\n  let storage = arguments.length > 5 ? arguments[5] : undefined;\n  let clientId = arguments.length > 6 ? arguments[6] : undefined;\n  let secretKey = arguments.length > 7 ? arguments[7] : undefined;\n  let saltForCreate2 = arguments.length > 8 ? arguments[8] : undefined;\n  let gasLimit = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 7000000;\n  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  invariant(extendedMetadata?.deployType === \"standard\", \"Must be direct deploy\");\n  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);\n}\nasync function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n\n  // 1. Deploy CREATE2 factory (if not already exists)\n  const create2Factory = await getCreate2FactoryAddress(provider);\n\n  // 2. Encode constructor params\n  const constructorParams = extractConstructorParamsFromAbi(abi);\n  const constructorParamTypes = constructorParams.map(p => {\n    return p.type;\n  });\n  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);\n  const paramTypesForEncoder = constructorParams.map(p => {\n    if (p.type === \"tuple[]\") {\n      return utils.ParamType.from(p);\n    } else {\n      return p.type;\n    }\n  });\n  const encodedArgs = utils.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);\n\n  // 3. Construct deployment transaction\n  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);\n  return address;\n}\nasync function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  invariant(extendedMetadata?.deployType === \"standard\", \"Must be direct deploy\");\n  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);\n}\nasync function predictAddressDeterministicPublished(contractName, publisherAddress) {\n  let contractVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n  let constructorArgs = arguments.length > 3 ? arguments[3] : undefined;\n  let provider = arguments.length > 4 ? arguments[4] : undefined;\n  let storage = arguments.length > 5 ? arguments[5] : undefined;\n  let clientId = arguments.length > 6 ? arguments[6] : undefined;\n  let secretKey = arguments.length > 7 ? arguments[7] : undefined;\n  let saltForCreate2 = arguments.length > 8 ? arguments[8] : undefined;\n  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  invariant(extendedMetadata?.deployType === \"standard\", \"Must be direct deploy\");\n  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);\n}\n\n/**\n * The main entry point for the thirdweb SDK\n * @public\n */\nclass ThirdwebSDK extends RPCConnectionHandler {\n  /**\n   * Get an instance of the thirdweb SDK based on an AbstractWallet\n   *\n   * @example\n   * ```javascript\n   * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\"\n   *\n   * const wallet = new AbstractWalletImplementation();\n   * const sdk = await ThirdwebSDK.fromWallet(wallet, \"mainnet\");\n   * ```\n   *\n   * @param wallet - the implementation of the AbstractWallet class to use for signing\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns An instance of the SDK\n   *\n   * @beta\n   */\n  static async fromWallet(wallet, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 ? arguments[3] : undefined;\n    const signer = await wallet.getSigner();\n    return ThirdwebSDK.fromSigner(signer, network, options, storage);\n  }\n\n  /**\n   * Get an instance of the thirdweb SDK based on an existing ethers signer\n   *\n   * @example\n   * ```javascript\n   * // get a signer from somewhere (createRandom is being used purely for example purposes)\n   * const signer = Wallet.createRandom();\n   *\n   * // get an instance of the SDK with the signer already setup\n   * const sdk = ThirdwebSDK.fromSigner(signer, \"mainnet\");\n   * ```\n   *\n   * @param signer - a ethers Signer to be used for transactions\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns An instance of the SDK\n   *\n   * @beta\n   */\n  static fromSigner(signer, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 ? arguments[3] : undefined;\n    let signerWithProvider = signer;\n    if (network) {\n      try {\n        const provider = getChainProvider(network, options);\n        signerWithProvider = signer.connect(provider);\n      } catch {\n        // We have to catch here because browser wallets throw when trying to override provider\n      }\n    }\n    const sdk = new ThirdwebSDK(network || signerWithProvider, network ? addChainToSupportedChains(network, options) : options, storage);\n    sdk.updateSignerOrProvider(signerWithProvider);\n    return sdk;\n  }\n\n  /**\n   * Get an instance of the thirdweb SDK based on a private key.\n   *\n   * @remarks\n   * This should only be used for backend services or scripts, with the private key stored in a secure way.\n   * **NEVER** expose your private key to the public in any way.\n   *\n   * @example\n   * ```javascript\n   * const sdk = ThirdwebSDK.fromPrivateKey(\"SecretPrivateKey\", \"mainnet\");\n   * ```\n   *\n   * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**\n   * @param network - the network (chain) to connect to (e.g. \"mainnet\", \"rinkeby\", \"polygon\", \"mumbai\"...) or a fully formed RPC url\n   * @param options - the SDK options to use\n   * @param storage - optional storage implementation to use\n   * @returns An instance of the SDK\n   *\n   * @public\n   */\n  static fromPrivateKey(privateKey, network) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let storage = arguments.length > 3 ? arguments[3] : undefined;\n    const provider = getChainProvider(network, options);\n    const signer = new Wallet(privateKey, provider);\n    return new ThirdwebSDK(signer, addChainToSupportedChains(network, options), storage);\n  }\n\n  /**\n   * @internal\n   * the cache of contracts that we have already seen\n   */\n  contractCache = new Map();\n  /**\n   * @internal\n   * should never be accessed directly, use {@link ThirdwebSDK.getPublisher} instead\n   */\n\n  /**\n   * Internal handler for uploading and downloading files\n   */\n\n  /**\n   * New contract deployer\n   */\n\n  /**\n   * Contract verifier\n   */\n\n  /**\n   * The registry of deployed contracts\n   */\n\n  /**\n   * Interact with the connected wallet\n   */\n\n  /**\n   * Upload and download files from IPFS or from your own storage service\n   */\n\n  constructor(network) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let storage = arguments.length > 2 ? arguments[2] : undefined;\n    const apiKeyType = \"clientId\" ;\n    let warnMessage = `No API key. Please provide a ${apiKeyType}. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key`;\n    checkClientIdOrSecretKey(warnMessage, options.clientId, options.secretKey);\n    options = addChainToSupportedChains(network, options);\n    super(network, options);\n    setSupportedChains(options?.supportedChains);\n    const configuredStorage = createStorage(storage, options);\n    this.storage = configuredStorage;\n    this.storageHandler = configuredStorage;\n    this.wallet = new UserWallet(network, options, configuredStorage);\n    this.deployer = new ContractDeployer(network, options, configuredStorage);\n    this.verifier = new ContractVerifier(network, options, configuredStorage);\n    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);\n    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);\n  }\n  get auth() {\n    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.\n      Please visit https://portal.thirdweb.com/wallets/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).\n\n      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);\n  }\n\n  /**\n   * Get an instance of a NFT Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const dropContract = await sdk.getDropContract(\"0x1234...\");\n   * + const dropContract = await sdk.getContract(\"0x1234...\", \"nft-drop\");\n   * ```\n   */\n  async getNFTDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"nft-drop\");\n  }\n\n  /**\n   * Get an instance of a Signature Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const signatureDrop = await sdk.getSignatureDrop(\"0x1234...\");\n   * + const signatureDrop = await sdk.getContract(\"0x1234...\", \"signature-drop\");\n   * ```\n   */\n  async getSignatureDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"signature-drop\");\n  }\n\n  /**\n   * Get an instance of a NFT Collection Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const signatureDrop = await sdk.getNFTCollection(\"0x1234...\");\n   * + const signatureDrop = await sdk.getContract(\"0x1234...\", \"nft-collection\");\n   * ```\n   */\n  async getNFTCollection(contractAddress) {\n    return await this.getContract(contractAddress, \"nft-collection\");\n  }\n\n  /**\n   * Get an instance of a Edition Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const editionDrop = await sdk.getEditionDrop(\"0x1234...\");\n   * + const editionDrop = await sdk.getContract(\"0x1234...\", \"edition-drop\");\n   * ```\n   */\n  async getEditionDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"edition-drop\");\n  }\n\n  /**\n   * Get an instance of a Edition contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const edition = await sdk.getEdition(\"0x1234...\");\n   * + const edition = await sdk.getContract(\"0x1234...\", \"edition\");\n   * ```\n   */\n  async getEdition(contractAddress) {\n    return await this.getContract(contractAddress, \"edition\");\n  }\n\n  /**\n   * Get an instance of a Token Drop contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const tokenDrop = await sdk.getTokenDrop(\"0x1234...\");\n   * + const tokenDrop = await sdk.getContract(\"0x1234...\", \"token-drop\");\n   * ```\n   */\n  async getTokenDrop(contractAddress) {\n    return await this.getContract(contractAddress, \"token-drop\");\n  }\n\n  /**\n   * Get an instance of a Token contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const token = await sdk.getToken(\"0x1234...\");\n   * + const token = await sdk.getContract(\"0x1234...\", \"token\");\n   * ```\n   */\n  async getToken(contractAddress) {\n    return await this.getContract(contractAddress, \"token\");\n  }\n\n  /**\n   * Get an instance of a Vote contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const vote = await sdk.getVote(\"0x1234...\");\n   * + const vote = await sdk.getContract(\"0x1234...\", \"vote\");\n   * ```\n   */\n  async getVote(contractAddress) {\n    return await this.getContract(contractAddress, \"vote\");\n  }\n\n  /**\n   * Get an instance of a Split contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const split = await sdk.getSplit(\"0x1234...\");\n   * + const split = await sdk.getContract(\"0x1234...\", \"split\");\n   * ```\n   */\n  async getSplit(contractAddress) {\n    return await this.getContract(contractAddress, \"split\");\n  }\n\n  /**\n   * Get an instance of a Marketplace contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const marketplace = await sdk.getMarketplace(\"0x1234...\");\n   * + const marketplace = await sdk.getContract(\"0x1234...\", \"marketplace\");\n   * ```\n   */\n  async getMarketplace(contractAddress) {\n    return await this.getContract(contractAddress, \"marketplace\");\n  }\n\n  /**\n   * Get an instance of a Marketplace contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const marketplace = await sdk.getMarketplaceV3(\"0x1234...\");\n   * + const marketplace = await sdk.getContract(\"0x1234...\", \"marketplace-v3\");\n   * ```\n   */\n  async getMarketplaceV3(contractAddress) {\n    return await this.getContract(contractAddress, \"marketplace-v3\");\n  }\n\n  /**\n   * Get an instance of a Pack contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const pack = await sdk.getPack(\"0x1234...\");\n   * + const pack = await sdk.getContract(\"0x1234...\", \"pack\");\n   * ```\n   */\n  async getPack(contractAddress) {\n    return await this.getContract(contractAddress, \"pack\");\n  }\n\n  /**\n   * Get an instance of a Pack contract\n   * @param contractAddress - the address of the deployed contract\n   * @deprecated\n   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.\n   * ```diff\n   * - const multiWrap = await sdk.getMultiwrap(\"0x1234...\");\n   * + const multiWrap = await sdk.getContract(\"0x1234...\", \"multiwrap\");\n   * ```\n   */\n  async getMultiwrap(contractAddress) {\n    return await this.getContract(contractAddress, \"multiwrap\");\n  }\n\n  /**\n   * Get an instance of a Custom ThirdwebContract\n   * @param address - the address of the deployed contract\n   * @returns The contract\n   * @public\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   * ```\n   */\n\n  /**\n   * Get an instance of a Custom ThirdwebContract\n   * @param address - the address of the deployed contract\n   * @param contractType - the {@link ContractType} of the contract to load\n   * @returns The contract\n   * @public\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\", \"nft-drop\");\n   * ```\n   */\n\n  /**\n   * Get an instance of a Custom ThirdwebContract\n   * @param address - the address of the deployed contract\n   * @param abi - the ABI ({@link ContractInterface}) of the contract to load\n   * @returns The contract\n   * @public\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\", ABI);\n   * ```\n   */\n\n  async getContract(address, contractTypeOrABI) {\n    const resolvedAddress = await resolveAddress(address);\n\n    // if we have a contract in the cache we will return it\n    // we will do this **without** checking any contract type things for simplicity, this may have to change in the future?\n    if (this.contractCache.has(resolvedAddress)) {\n      // we know this will be there since we check the has above\n      return this.contractCache.get(resolvedAddress);\n    }\n    if (resolvedAddress in GENERATED_ABI) {\n      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);\n    }\n    let newContract;\n\n    // if we don't have a contractType or ABI then we will have to resolve it regardless\n    // we also handle it being \"custom\" just in case...\n    if (!contractTypeOrABI || contractTypeOrABI === \"custom\") {\n      try {\n        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);\n        newContract = await this.getContractFromAbi(resolvedAddress, metadata.abi);\n      } catch (e) {\n        // fallback to\n        // try resolving the contract type (legacy contracts)\n        const resolvedContractType = await this.resolveContractType(resolvedAddress);\n        if (resolvedContractType && resolvedContractType !== \"custom\") {\n          // otherwise if it's a prebuilt contract we can just use the contract type\n          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(resolvedAddress, this.getProvider(), this.storage);\n          newContract = await this.getContractFromAbi(resolvedAddress, contractAbi);\n        } else {\n          // we cant fetch the ABI, and we don't know the contract type, throw the original error\n          throw e;\n        }\n      }\n    }\n    // if it's a builtin contract type we can just use the contract type to initialize the contract instance\n    else if (typeof contractTypeOrABI === \"string\" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {\n      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);\n    }\n    // otherwise it has to be an ABI\n    else {\n      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);\n    }\n\n    // set whatever we have on the cache\n    this.contractCache.set(resolvedAddress, newContract);\n    // return it\n    return newContract;\n  }\n\n  /**\n   * @internal\n   * @deprecated use {@link getContract} directly instead\n   */\n  async getBuiltInContract(address, contractType) {\n    return await this.getContract(address, contractType);\n  }\n\n  /**\n   * @param contractAddress - the address of the contract to attempt to resolve the contract type for\n   * @returns The {@link ContractType} for the given contract address\n   *\n   */\n  async resolveContractType(contractAddress) {\n    try {\n      const IThirdwebContractABI = (await import('@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json')).default;\n      const contract = new Contract(await resolveAddress(contractAddress), IThirdwebContractABI,\n      // !provider only! - signer can break things here!\n      this.getProvider());\n      const remoteContractType = utils.toUtf8String(await contract.contractType())\n      // eslint-disable-next-line no-control-regex\n      .replace(/\\x00/g, \"\");\n      return getContractTypeForRemoteName(remoteContractType);\n    } catch (err) {\n      return \"custom\";\n    }\n  }\n\n  /**\n   * Return all the contracts deployed by the specified address\n   * @param walletAddress - the deployed address\n   * @example\n   * ```javascript\n   * const contracts = sdk.getContractList(\"{{wallet_address}}\");\n   * ```\n   */\n  async getContractList(walletAddress) {\n    // TODO - this only reads from the current registry chain, not the multichain registry\n    const addresses = (await (await this.deployer.getRegistry())?.getContractAddresses(await resolveAddress(walletAddress))) || [];\n    const chainId = (await this.getProvider().getNetwork()).chainId;\n    return await Promise.all(addresses.map(async address => {\n      return {\n        address: address,\n        chainId,\n        contractType: () => this.resolveContractType(address),\n        metadata: async () => (await this.getContract(address)).metadata.get(),\n        extensions: async () => getAllDetectedExtensionNames((await this.getContract(address)).abi)\n      };\n    }));\n  }\n  async getMultichainContractList(walletAddress) {\n    let chains = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultChains;\n    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);\n    const chainMap = chains.reduce((acc, chain) => {\n      acc[chain.chainId] = chain;\n      return acc;\n    }, {});\n    const sdkMap = {};\n    return contracts.map(_ref => {\n      let {\n        address,\n        chainId\n      } = _ref;\n      if (!chainMap[chainId]) {\n        // if we don't have the chain in our list of supported chains then we can't resolve the contract type regardless, don't even try to set up the SDK\n        return {\n          address,\n          chainId,\n          contractType: async () => \"custom\",\n          metadata: async () => ({\n            name: \"\"\n          }),\n          extensions: async () => []\n        };\n      }\n      try {\n        let chainSDK = sdkMap[chainId];\n        if (!chainSDK) {\n          chainSDK = new ThirdwebSDK(chainId, {\n            ...this.options,\n            // need to disable readonly settings for this to work\n            readonlySettings: undefined,\n            // @ts-expect-error - zod doesn't like this\n            supportedChains: chains\n          }, this.storage);\n          sdkMap[chainId] = chainSDK;\n        }\n        return {\n          address,\n          chainId,\n          contractType: () => chainSDK.resolveContractType(address),\n          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),\n          extensions: async () => getAllDetectedExtensionNames((await chainSDK.getContract(address)).abi)\n        };\n      } catch (e) {\n        return {\n          address,\n          chainId,\n          contractType: async () => \"custom\",\n          metadata: async () => ({\n            name: \"\"\n          }),\n          extensions: async () => []\n        };\n      }\n    });\n  }\n\n  /**\n   * Update the active signer or provider for all contracts\n   * @param network - the new signer or provider\n   */\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.updateContractSignerOrProvider();\n  }\n  updateContractSignerOrProvider() {\n    this.wallet.connect(this.getSignerOrProvider());\n    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());\n    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());\n    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());\n    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());\n    for (const [, contract] of this.contractCache) {\n      contract.onNetworkUpdated(this.getSignerOrProvider());\n    }\n  }\n\n  /**\n   * Get an instance of a Custom contract from a json ABI\n   * @param address - the address of the deployed contract\n   * @param abi - the JSON abi\n   * @returns The contract\n   * @beta\n   * @example\n   * ```javascript\n   * // Import your ABI from a JSON file\n   * import myABI from \"./path/to/myABI.json\";\n   *\n   * const contract = sdk.getContractFromAbi(\n   *   \"{{contract_address}}\",\n   *   // Pass in the \"abi\" field from the JSON file\n   *   myABI.abi\n   * );\n   * ```\n   */\n  async getContractFromAbi(address, abi) {\n    const [resolvedAddress, {\n      SmartContract\n    }] = await Promise.all([resolveAddress(address), import('./smart-contract-b5448018.browser.esm.js')]);\n    if (this.contractCache.has(resolvedAddress)) {\n      return this.contractCache.get(resolvedAddress);\n    }\n    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);\n    const parsedABI = typeof abi === \"string\" ? JSON.parse(abi) : abi;\n    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedABI), provider, this.options, this.storage), this.storageHandler, this.options, (await provider.getNetwork()).chainId);\n    this.contractCache.set(resolvedAddress, contract);\n    return contract;\n  }\n\n  /**\n   * Get the native balance of a given address (wallet or contract)\n   * @example\n   * ```javascript\n   * const balance = await sdk.getBalance(\"0x...\");\n   * console.log(balance.displayValue);\n   * ```\n   * @param address - the address to check the balance for\n   */\n  async getBalance(address) {\n    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));\n  }\n\n  /**\n   * @internal\n   */\n  getPublisher() {\n    return this._publisher;\n  }\n}\nfunction addChainToSupportedChains(network, options) {\n  if (isChainConfig(network)) {\n    options = {\n      ...options,\n      // @ts-expect-error - we know that the network is assignable despite the readonly mismatch\n      supportedChains: [network, ...(options?.supportedChains || [])]\n    };\n  }\n  return options;\n}\nconst THIRDWEB_DEPLOYER = \"0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024\";\n\n/**\n * Handles deploying new contracts\n * @public\n */\nclass ContractDeployer extends RPCConnectionHandler {\n  /**\n   * @internal\n   * should never be accessed directly, use {@link ContractDeployer.getFactory} instead\n   */\n\n  /**\n   * @internal\n   * should never be accessed directly, use {@link ContractDeployer.getRegistry} instead\n   */\n\n  transactionListener = event => {\n    if (event.status === \"submitted\") {\n      this.events.emit(\"contractDeployed\", {\n        status: \"submitted\",\n        transactionHash: event.transactionHash\n      });\n    }\n  };\n  constructor(network, options, storage) {\n    super(network, options);\n    this.storage = storage;\n    this.events = new EventEmitter();\n    // Initialize factory and registry (we don't need to make these calls async)\n    this.getFactory();\n    this.getRegistry();\n  }\n\n  /**\n   * Deploys an NFT Collection contract\n   *\n   * @remarks Deploys an NFT Collection contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployNFTCollection({\n   *   name: \"My Collection\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployNFTCollection = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new NFTDrop contract\n   *\n   * @remarks Deploys an NFT Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployNFTDrop({\n   *   name: \"My Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployNFTDrop = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new LoyaltyCard contract\n   *\n   * @remarks Deploys a LoyaltyCard contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployLoyaltyCard({\n   *   name: \"My Loyalty Program\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployLoyaltyCard = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    const parsedMetadata = await LoyaltyCardContractDeploy.parseAsync(metadata);\n    const contractURI = await this.storage.upload(parsedMetadata);\n    const trustedForwarders = [];\n    // add any custom forwarders passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders.push(...metadata.trusted_forwarders);\n    }\n    const signerAddress = await this.getSigner()?.getAddress();\n    const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points, parsedMetadata.platform_fee_basis_points, parsedMetadata.platform_fee_recipient];\n    return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER, \"LoyaltyCard\", deployArgs, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new OpenEditionERC721 contract\n   *\n   * @remarks Deploys a OpenEdition contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployOpenEdition({\n   *   name: \"My Open Edition\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployOpenEdition = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    const parsedMetadata = await DropErc721ContractSchema.deploy.parseAsync(metadata);\n    const contractURI = await this.storage.upload(parsedMetadata);\n    const trustedForwarders = [];\n    // add any custom forwarders passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders.push(...metadata.trusted_forwarders);\n    }\n    const signerAddress = await this.getSigner()?.getAddress();\n    const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points];\n    return await this.deployPublishedContract.prepare(THIRDWEB_DEPLOYER, \"OpenEditionERC721\", deployArgs, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new SignatureDrop contract\n   *\n   * @remarks Deploys a SignatureDrop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deploySignatureDrop({\n   *   name: \"My Signature Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deploySignatureDrop = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Multiwrap contract\n   *\n   * @remarks Deploys a Multiwrap contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployMultiwrap({\n   *   name: \"My Multiwrap\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   * @beta\n   */\n  deployMultiwrap = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Edition contract\n   *\n   * @remarks Deploys an Edition contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployEdition({\n   *   name: \"My Edition\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployEdition = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new EditionDrop contract\n   *\n   * @remarks Deploys an Edition Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployEditionDrop({\n   *   name: \"My Edition Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployEditionDrop = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Token contract\n   *\n   * @remarks Deploys a Token contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployToken({\n   *   name: \"My Token\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployToken = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Token Drop contract\n   *\n   * @remarks Deploys a Token Drop contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployTokenDrop({\n   *   name: \"My Token Drop\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployTokenDrop = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Marketplace contract\n   *\n   * @remarks Deploys a Marketplace contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployMarketplace({\n   *   name: \"My Marketplace\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployMarketplace = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Marketplace-V3 contract\n   *\n   * @remarks Deploys a Marketplace-V3 contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployMarketplaceV3({\n   *   name: \"My Marketplace\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployMarketplaceV3 = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Pack contract\n   *\n   * @remarks Deploys a Pack contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployPack({\n   *   name: \"My Pack\",\n   *   primary_sale_recipient: \"your-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployPack = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Split contract\n   *\n   * @remarks Deploys a Split contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deploySplit({\n   *   name: \"My Split\",\n   *   primary_sale_recipient: \"your-address\",\n   *   recipients: [\n   *    {\n   *      address: \"your-address\",\n   *      sharesBps: 80 * 100, // 80%\n   *    },\n   *    {\n   *      address: \"another-address\",\n   *      sharesBps: 20 * 100, // 20%\n   *    },\n   *   ],\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deploySplit = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new Vote contract\n   *\n   * @remarks Deploys an Vote contract and returns the address of the deployed contract\n   *\n   * @example\n   * ```javascript\n   * const contractAddress = await sdk.deployer.deployVote({\n   *   name: \"My Vote\",\n   *   primary_sale_recipient: \"your-address\",\n   *   voting_token_address: \"your-token-contract-address\",\n   * });\n   * ```\n   * @param metadata - the contract metadata\n   * @returns The address of the deployed contract\n   */\n  deployVote = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata, \"latest\", options);\n  });\n  deployAirdropERC20 = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);\n    const contractURI = await this.storage.upload(parsedMetadata);\n    const trustedForwarders = [];\n    // add any custom forwarders passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders.push(...metadata.trusted_forwarders);\n    }\n    const signerAddress = await this.getSigner()?.getAddress();\n    const deployArgs = [signerAddress, contractURI, trustedForwarders];\n    return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER, \"AirdropERC20\", deployArgs, \"latest\", options);\n  });\n  deployAirdropERC721 = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);\n    const contractURI = await this.storage.upload(parsedMetadata);\n    const trustedForwarders = [];\n    // add any custom forwarders passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders.push(...metadata.trusted_forwarders);\n    }\n    const signerAddress = await this.getSigner()?.getAddress();\n    const deployArgs = [signerAddress, contractURI, trustedForwarders];\n    return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER, \"AirdropERC721\", deployArgs, \"latest\", options);\n  });\n  deployAirdropERC1155 = /* @__PURE__ */buildDeployTransactionFunction(async (metadata, options) => {\n    const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);\n    const contractURI = await this.storage.upload(parsedMetadata);\n    const trustedForwarders = [];\n    // add any custom forwarders passed in\n    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {\n      trustedForwarders.push(...metadata.trusted_forwarders);\n    }\n    const signerAddress = await this.getSigner()?.getAddress();\n    const deployArgs = [signerAddress, contractURI, trustedForwarders];\n    return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER, \"AirdropERC1155\", deployArgs, \"latest\", options);\n  });\n\n  /**\n   * Deploys a new prebuilt contract\n   *\n   * @public\n   * @param contractType - the type of contract to deploy\n   * @param contractMetadata - the metadata to deploy the contract with\n   * @param version - the version of the contract to deploy\n   * @returns A promise of the address of the newly deployed contract\n   */\n  deployBuiltInContract = /* @__PURE__ */buildDeployTransactionFunction((() => {\n    var _this = this;\n    return async function (contractType, contractMetadata) {\n      let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n      let options = arguments.length > 3 ? arguments[3] : undefined;\n      const signer = _this.getSigner();\n      invariant(signer, \"A signer is required to deploy contracts\");\n      const parsedMetadata = {\n        app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType],\n        ...(await PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parseAsync(contractMetadata))\n      };\n      if (_this.hasLocalFactory()) {\n        // old behavior for unit tests, deploy from local factory\n        // parse version into the first number of the version string (or undefined if unparseable)\n        let parsedVersion = undefined;\n        try {\n          parsedVersion = parseInt(version);\n          if (isNaN(parsedVersion)) {\n            parsedVersion = undefined;\n          }\n        } catch (e) {\n          parsedVersion = undefined;\n        }\n        const factory = await _this.getFactory();\n        if (!factory) {\n          throw new Error(\"Factory not found\");\n        }\n        factory.on(EventType.Transaction, _this.transactionListener);\n        return factory.deploy.prepare(contractType, parsedMetadata, _this.events, parsedVersion, options, () => {\n          factory.off(EventType.Transaction, _this.transactionListener);\n        });\n      }\n\n      // For all other chains, fetch from published contracts\n      // resolve contract name from type\n      const contractName = getContractName(contractType);\n      invariant(contractName, \"Contract name not found\");\n      // first upload the contract metadata\n      const contractURI = await _this.storage.upload(parsedMetadata);\n      // then get the deploy arguments\n      const constructorParams = await getDeployArguments(contractType, parsedMetadata, contractURI, signer, _this.storage);\n\n      // fetch the publish URI from the ContractPublisher contract\n      const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, version);\n      return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);\n    };\n  })());\n\n  /**\n   * @internal\n   * @param contractType - the type of contract to deploy\n   */\n  async getLatestBuiltInContractVersion(contractType) {\n    const factory = await this.getFactory();\n    if (!factory) {\n      throw new Error(\"Factory not found\");\n    }\n    return await factory.getLatestVersion(contractType);\n  }\n\n  /**\n   * Deploy any published contract by its name\n   * @param publisherAddress - the address of the publisher\n   * @param contractName - the name of the contract to deploy\n   * @param constructorParams - the constructor params to pass to the contract\n   *\n   * @deprecated use deployPublishedContract instead\n   * @internal\n   */\n  deployReleasedContract = /* @__PURE__ */buildDeployTransactionFunction((() => {\n    var _this2 = this;\n    return async function (publisherAddress, contractName, constructorParams) {\n      let version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n      let options = arguments.length > 4 ? arguments[4] : undefined;\n      const publishedContract = await _this2.fetchPublishedContractFromPolygon(publisherAddress, contractName, version);\n      return await _this2.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);\n    };\n  })());\n\n  /**\n   * Deploy any published contract by its name\n   * @param publisherAddress - the address of the publisher\n   * @param contractName - the name of the contract to deploy\n   * @param constructorParams - the constructor params to pass to the contract\n   * @param version - Optional: the version of the contract to deploy or \"latest\"\n   * @param options - Optional: the deploy options\n   */\n  deployPublishedContract = this.deployReleasedContract;\n\n  /**\n   * Deploy any published contract by its name\n   * @param contractName - the name of the contract to deploy\n   * @param constructorParams - the constructor params to pass to the contract\n   * @param publisherAddress - the address of the publisher\n   * @param version - Optional: the version of the contract to deploy or \"latest\"\n   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address\n   */\n  async deployPublishedContractDeterministic(contractName, constructorParams) {\n    let publisherAddress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : THIRDWEB_DEPLOYER;\n    let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n    let saltForCreate2 = arguments.length > 4 ? arguments[4] : undefined;\n    const signer = this.getSigner();\n    invariant(signer, \"Signer is required\");\n    return directDeployDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, signer, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);\n  }\n\n  /**\n   * Predict Create2 address of a contract\n   * @param contractName - the name of the contract\n   * @param constructorParams - the constructor params to pass to the contract\n   * @param publisherAddres -s the address of the publisher\n   * @param version - Optional: the version of the contract to deploy or \"latest\"\n   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address\n   */\n  async predictAddressDeterministic(contractName, constructorParams) {\n    let publisherAddress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : THIRDWEB_DEPLOYER;\n    let contractVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"latest\";\n    let saltForCreate2 = arguments.length > 4 ? arguments[4] : undefined;\n    const provider = this.getProvider();\n    invariant(provider, \"Provider is required\");\n    return predictAddressDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, provider, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);\n  }\n\n  /**\n   * Deploy a proxy contract of a given implementation via the given factory\n   * @param factoryAddress - the address of the factory\n   * @param implementationAddress - the address of the implementation\n   * @param implementationAbi - the abi of the implementation\n   * @param initializerFunction - the initializer function to call\n   * @param initializerArgs - the initializer args to pass to the initializer function\n   */\n  deployViaFactory = /* @__PURE__ */buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs, saltForProxyDeploy) => {\n    const resolvedFactoryAddress = await resolveAddress(factoryAddress);\n    const resolvedImplementationAddress = await resolveAddress(implementationAddress);\n    const signer = this.getSigner();\n    invariant(signer, \"signer is required\");\n    // TODO only require factory interface here - IProxyFactory\n    const proxyFactory = new ContractFactory(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);\n    proxyFactory.on(EventType.Transaction, this.transactionListener);\n    return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, saltForProxyDeploy, () => {\n      proxyFactory.off(EventType.Transaction, this.transactionListener);\n    });\n  });\n\n  /**\n   * Deploy a proxy contract of a given implementation directly\n   * @param implementationAddress - the address of the implementation\n   * @param implementationAbi - the abi of the implementation\n   * @param initializerFunction - the initializer function to call\n   * @param initializerArgs - the initializer args to pass to the initializer function\n   */\n  deployProxy = /* @__PURE__ */buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {\n    const resolvedAddress = await resolveAddress(implementationAddress);\n    const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);\n    const {\n      TWProxy__factory\n    } = await import('@thirdweb-dev/contracts-js/factories/TWProxy__factory');\n    return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);\n  });\n\n  /**\n   * Deploy a proxy contract of a given implementation via thirdweb's Clone factory\n   * @param publishMetadataUri - the uri of the publish metadata\n   * @param constructorParamValues - the constructor param values\n   * @param deployMetadata - the deploy metadata\n   * @param signer - the signer to use\n   * @param options - the deploy options\n   * @internal\n   */\n  deployViaAutoFactory = /* @__PURE__ */buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options) => {\n    // any evm deployment flow\n\n    // 1. Deploy CREATE2 factory (if not already exists)\n    const create2Factory = await deployCreate2Factory(signer, options);\n\n    // 2. get deployment info for any evm\n    const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory, this.options.clientId, this.options.secretKey);\n    const implementationAddress = deploymentInfo.find(i => i.type === \"implementation\")?.transaction.predictedAddress;\n\n    // 3. deploy infra + plugins + implementation using a throwaway Deployer contract\n\n    // filter out already deployed contracts (data is empty)\n    const transactionsToSend = deploymentInfo.filter(i => i.transaction.data && i.transaction.data.length > 0);\n    const transactionsforDirectDeploy = transactionsToSend.filter(i => {\n      return i.type !== \"infra\";\n    }).map(i => i.transaction);\n    const transactionsForThrowawayDeployer = transactionsToSend.filter(i => {\n      return i.type === \"infra\";\n    }).map(i => i.transaction);\n\n    // deploy via throwaway deployer, multiple infra contracts in one transaction\n    await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options);\n\n    // send each transaction directly to Create2 factory\n    // process txns one at a time\n    for (const tx of transactionsforDirectDeploy) {\n      try {\n        await deployContractDeterministic(signer, tx, options);\n      } catch (e) {\n        console.debug(`Error deploying contract at ${tx.predictedAddress}`, e?.message);\n        throw e;\n      }\n    }\n    const resolvedImplementationAddress = await resolveAddress(implementationAddress);\n\n    // 4. deploy proxy with TWStatelessFactory (Clone factory) and return address\n    const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory, this.options.clientId, this.options.secretKey);\n    options?.notifier?.(\"deploying\", \"proxy\");\n    const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues, options?.saltForProxyDeploy);\n    options?.notifier?.(\"deployed\", \"proxy\");\n    return proxyDeployTransaction;\n  });\n\n  /**\n   * Deploy a proxy contract of a given implementation via a custom factory\n   * @param constructorParamValues - the constructor param values\n   * @param deployMetadata - the deploy metadata\n   * @param signer - the signer to use\n   * @param chainId - the chain id to deploy to\n   * @internal\n   */\n  deployViaCustomFactory = /* @__PURE__ */buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {\n    const customFactoryAddress = deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.customFactoryAddresses[chainId];\n    const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);\n    invariant(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);\n    invariant(deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.factoryFunction, `customFactoryFunction not set'`);\n    const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage, this.options);\n    const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map(p => p.type);\n    const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);\n\n    // eslint-disable-next-line prefer-const\n    let deployedImplementationAddress;\n    const deployTransaction = await Transaction.fromContractInfo({\n      contractAddress: resolvedCustomFactoryAddress,\n      contractAbi: customFactoryMetadata.abi,\n      provider: this.getProvider(),\n      signer,\n      method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,\n      args: factoryFunctionparamValues,\n      parse: () => {\n        return deployedImplementationAddress;\n      },\n      storage: this.storage\n    });\n    deployedImplementationAddress = await deployTransaction.simulate();\n    return deployTransaction;\n  });\n\n  /**\n   * @internal\n   */\n  async getRegistry() {\n    // if we already have a registry just return it back\n    if (this._registry) {\n      return this._registry;\n    }\n\n    // otherwise get the registry address for the active chain and get a new one\n\n    // have to do it like this otherwise we run it over and over and over\n    // \"this._registry\" has to be assigned to the promise upfront.\n    return this._registry = this.getProvider().getNetwork().then(async _ref2 => {\n      let {\n        chainId\n      } = _ref2;\n      const registryAddress = getContractAddressByChainId(chainId, \"twRegistry\");\n      if (!registryAddress) {\n        return undefined;\n      }\n      const TWRegistryABI = (await import('@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json')).default;\n      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.storage, TWRegistryABI, this.options);\n    });\n  }\n  async getFactory() {\n    // if we already have a factory just return it back\n    if (this._factory) {\n      return this._factory;\n    }\n\n    // otherwise get the factory address for the active chain and get a new one\n\n    // have to do it like this otherwise we run it over and over and over\n    // \"this._factory\" has to be assigned to the promise upfront.\n    return this._factory = this.getProvider().getNetwork().then(async _ref3 => {\n      let {\n        chainId\n      } = _ref3;\n      const factoryAddress = getContractAddressByChainId(chainId, \"twFactory\");\n      if (!factoryAddress) {\n        return undefined;\n      }\n      const factory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);\n      return factory;\n    });\n  }\n\n  /**\n   * @internal\n   */\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.updateContractSignerOrProvider();\n  }\n  updateContractSignerOrProvider() {\n    // has to be promises now\n    this._factory?.then(factory => {\n      factory?.updateSignerOrProvider(this.getSignerOrProvider());\n    }).catch(() => {\n      // ignore\n    });\n    // has to be promises now\n    this._registry?.then(registry => {\n      registry?.updateSignerOrProvider(this.getSignerOrProvider());\n    }).catch(() => {\n      // ignore\n    });\n  }\n\n  /**\n   * @internal\n   * @param publishMetadataUri - the uri of the publish metadata\n   * @param constructorParamValues - the constructor param values\n   * @param options - the deploy options\n   */\n  deployContractFromUri = /* @__PURE__ */buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options) => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const {\n      compilerMetadata,\n      extendedMetadata\n    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);\n    const forceDirectDeploy = options?.forceDirectDeploy || false;\n    const chainId = (await this.getProvider().getNetwork()).chainId;\n    const isNetworkEnabled = extendedMetadata?.networksForDeployment?.networksEnabled.includes(chainId) || extendedMetadata?.networksForDeployment?.allNetworks;\n    if (extendedMetadata?.networksForDeployment && !isNetworkEnabled && compilerMetadata.name !== \"AccountFactory\" // ignore network restrictions for simple AccountFactory\n    ) {\n      throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);\n    }\n    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== \"standard\") && !forceDirectDeploy) {\n      if (extendedMetadata.deployType === \"customFactory\") {\n        return await this.deployViaCustomFactory.prepare(constructorParamValues, {\n          compilerMetadata,\n          extendedMetadata\n        }, signer, chainId);\n      } else {\n        invariant(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);\n        const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map(p => p.type);\n        const paramValues = convertParamValues(initializerParamTypes, constructorParamValues);\n        const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];\n        if (!implementationAddress || extendedMetadata.deployType === \"autoFactory\") {\n          return await this.deployViaAutoFactory.prepare(publishMetadataUri, {\n            compilerMetadata,\n            extendedMetadata\n          }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues, options);\n        }\n        const resolvedImplementationAddress = await resolveAddress(implementationAddress);\n        invariant(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);\n        if (extendedMetadata.isDeployableViaFactory) {\n          // deploy via a factory (prioritise factory)\n          invariant(extendedMetadata.factoryDeploymentData.factoryAddresses, \"isDeployableViaFactory is true so factoryAddresses is required\");\n          const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];\n          invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);\n          const resolvedFactoryAddress = await resolveAddress(factoryAddress);\n          return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues, options?.saltForProxyDeploy);\n        } else if (extendedMetadata.isDeployableViaProxy) {\n          // deploy a proxy directly\n          return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues);\n        }\n      }\n    }\n    const bytecode = compilerMetadata.bytecode.startsWith(\"0x\") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;\n    if (!utils.isHexString(bytecode)) {\n      throw new Error(`Contract bytecode is invalid.\\n\\n${bytecode}`);\n    }\n    const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map(p => p.type);\n    const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);\n    return this.deployContractWithAbi.prepare(compilerMetadata.abi, bytecode, paramValues);\n  });\n\n  /**\n   * @public\n   * @param abi - the abi of the contract\n   * @param bytecode - the bytecode of the contract\n   * @param constructorParams - the constructor params to pass to the contract\n   */\n  deployContractWithAbi = /* @__PURE__ */buildDeployTransactionFunction(async (abi, bytecode, constructorParams) => {\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    invariant(signer, \"Signer is required to deploy contracts\");\n    const factory = new ContractFactory$1(abi, bytecode).connect(signer);\n    return new DeployTransaction({\n      args: constructorParams,\n      provider,\n      signer,\n      factory,\n      storage: this.storage,\n      events: this.events\n    });\n  });\n\n  /**\n   * @public\n   * @param publishMetadataUri - the uri of the publish metadata\n   * @param options - the deploy options\n   */\n  async getTransactionsForDeploy(publishMetadataUri, options) {\n    let transactions = [];\n    const provider = this.getProvider();\n    invariant(provider, \"A provider is required\");\n    const {\n      extendedMetadata\n    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);\n    const forceDirectDeploy = options?.forceDirectDeploy || false;\n    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === \"autoFactory\") && !forceDirectDeploy) {\n      const chainId = (await this.getProvider().getNetwork()).chainId;\n      const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];\n      if (!implementationAddress || extendedMetadata.deployType === \"autoFactory\") {\n        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());\n        transactions.push({\n          contractType: \"create2Factory\",\n          addresses: [create2FactoryAddress]\n        });\n        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress, this.options.clientId, this.options.secretKey);\n        const transactionsToSend = deploymentInfo.filter(i => i.transaction.data && i.transaction.data.length > 0);\n        const transactionsforDirectDeploy = transactionsToSend.filter(i => {\n          return i.type !== \"infra\";\n        }).map(i => i.transaction);\n        transactionsforDirectDeploy.forEach(tx => {\n          transactions.push({\n            contractType: \"preset\",\n            addresses: [tx.predictedAddress]\n          });\n        });\n        const transactionsForThrowawayDeployer = transactionsToSend.filter(i => {\n          return i.type === \"infra\";\n        }).map(i => i.transaction);\n        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);\n        transactionBatches.forEach(batch => {\n          const addresses = batch.map(tx => tx.predictedAddress);\n          transactions.push({\n            contractType: \"infra\",\n            addresses: addresses\n          });\n        });\n      }\n      transactions = (await Promise.all(transactions.map(async tx => {\n        const addresses = (await Promise.all(tx.addresses.map(async address => {\n          const isDeployed = await isContractDeployed(address, provider);\n          return isDeployed ? null : address;\n        }))).filter(Boolean);\n        return addresses.length > 0 ? tx : null;\n      }))).filter(Boolean);\n      transactions.push({\n        contractType: \"proxy\",\n        addresses: []\n      });\n    } else {\n      transactions.push({\n        contractType: \"custom\",\n        addresses: []\n      });\n    }\n    return transactions;\n  }\n\n  /**\n   * Listen to all deploy transactions from this deployer\n   * @param listener - the listener to add\n   */\n  addDeployListener(listener) {\n    this.events.on(\"contractDeployed\", listener);\n  }\n\n  /**\n   * Remove a deploy listener\n   * @param listener - the listener to remove\n   */\n  removeDeployListener(listener) {\n    this.events.off(\"contractDeployed\", listener);\n  }\n\n  /**\n   * Remove all deploy listeners\n   */\n  removeAllDeployListeners() {\n    this.events.removeAllListeners(\"contractDeployed\");\n  }\n\n  // PRIVATE METHODS\n\n  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version) {\n    const address = await resolveAddress(publisherAddress);\n    // TODO don't create a new sdk instance here, instead read from contract directly with provider\n    // this will allow moving deployer out of this file and help with tree shaking\n    const publishedContract = await new ThirdwebSDK(\"polygon\", {\n      clientId: this.options.clientId,\n      secretKey: this.options.secretKey\n    }, this.storage).getPublisher().getVersion(address, contractName, version);\n    if (!publishedContract) {\n      throw new Error(`No published contract found for '${contractName}' at version '${version}' by '${address}'`);\n    }\n    return publishedContract;\n  }\n  hasLocalFactory() {\n    return !!getProcessEnv(\"factoryAddress\");\n  }\n}\n\nexport { APPROVED_IMPLEMENTATIONS as A, ContractVerifier as C, LOCAL_NODE_PKEY as L, SUPPORTED_CHAIN_IDS as S, ThirdwebSDK as T, UserWallet as U, ContractDeployer as a, getAllDetectedExtensionNames as b, checkClientIdOrSecretKey as c, verify as d, extractFunctionParamsFromAbi as e, checkVerificationStatus as f, getAllDetectedFeatureNames as g, computeCloneFactoryAddress as h, isVerifiedOnEtherscan as i, getThirdwebContractAddress as j, getEncodedConstructorParamsForThirdwebContract as k, deployCreate2Factory as l, directDeployDeterministic as m, directDeployDeterministicWithUri as n, directDeployDeterministicPublished as o, predictThirdwebContractAddress as p, predictAddressDeterministic as q, predictAddressDeterministicWithUri as r, predictAddressDeterministicPublished as s, convertParamValues as t, getDeployArguments as u, verifyThirdwebPrebuiltImplementation as v, getTrustedForwarders as w, getApprovedImplementation as x, getDefaultTrustedForwarders as y };\n","import { C as Connector } from '../../../../dist/connector-05689d68.browser.esm.js';\nimport { utils, BigNumber, providers, Signer, ethers, constants } from 'ethers';\nimport { i as isTwUrl } from '../../../../dist/url-a45219bd.browser.esm.js';\nimport { s as setAnalyticsHeaders } from '../../../../dist/headers-a27423d3.browser.esm.js';\nimport { EntryPoint__factory } from '@account-abstraction/contracts';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-d7c057bf.browser.esm.js';\nimport { A as ACCOUNT_CORE_ABI, E as ENTRYPOINT_ADDRESS } from '../../../../dist/constants-5a6f7f26.browser.esm.js';\nimport { getDynamicFeeData, ThirdwebSDK, LOCAL_NODE_PKEY, getChainProvider, getGasPrice } from '@thirdweb-dev/sdk';\nimport { Celo, CeloAlfajoresTestnet, CeloBaklavaTestnet } from '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nasync function hexlifyUserOp(op) {\n  const userOp = await utils.resolveProperties(op);\n  return Object.keys(userOp).map(key => {\n    let val = userOp[key];\n    if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n      val = utils.hexValue(val);\n    }\n    return [key, val];\n  }).reduce((set, _ref) => {\n    let [k, v] = _ref;\n    return {\n      ...set,\n      [k]: v\n    };\n  }, {});\n}\n\n// v0.6 userOpHash calculation\nasync function getUserOpHashV06(userOp, entryPoint, chainId) {\n  const op = await utils.resolveProperties(userOp);\n  const hashedUserOp = {\n    sender: op.sender,\n    nonce: op.nonce,\n    initCodeHash: utils.keccak256(op.initCode),\n    callDataHash: utils.keccak256(op.callData),\n    callGasLimit: op.callGasLimit,\n    verificationGasLimit: op.verificationGasLimit,\n    preVerificationGas: op.preVerificationGas,\n    maxFeePerGas: op.maxFeePerGas,\n    maxPriorityFeePerGas: op.maxPriorityFeePerGas,\n    paymasterAndDataHash: utils.keccak256(op.paymasterAndData)\n  };\n  const userOpType = {\n    components: [{\n      type: \"address\",\n      name: \"sender\"\n    }, {\n      type: \"uint256\",\n      name: \"nonce\"\n    }, {\n      type: \"bytes32\",\n      name: \"initCodeHash\"\n    }, {\n      type: \"bytes32\",\n      name: \"callDataHash\"\n    }, {\n      type: \"uint256\",\n      name: \"callGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"verificationGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"preVerificationGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxFeePerGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxPriorityFeePerGas\"\n    }, {\n      type: \"bytes32\",\n      name: \"paymasterAndDataHash\"\n    }],\n    name: \"hashedUserOp\",\n    type: \"tuple\"\n  };\n  const encoded = utils.defaultAbiCoder.encode([userOpType], [{\n    ...hashedUserOp\n  }]);\n  // remove leading word (total length) and trailing word (zero-length signature)\n\n  const userOpHash = utils.keccak256(encoded);\n  const enc = utils.defaultAbiCoder.encode([\"bytes32\", \"address\", \"uint256\"], [userOpHash, entryPoint, chainId]);\n  return utils.keccak256(enc);\n}\nconst generateRandomUint192 = () => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;\n};\nconst randomNonce = () => {\n  let hexString = generateRandomUint192().toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  hexString = \"0x\" + hexString;\n  return BigNumber.from(utils.concat([hexString, \"0x0000000000000000\"]));\n};\n\n/**\n * an API to external a UserOperation with paymaster info\n */\nclass PaymasterAPI {}\n\nconst DEBUG = false; // TODO set as public flag\n\nclass HttpRpcClient {\n  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {\n    this.bundlerUrl = bundlerUrl;\n    this.entryPointAddress = entryPointAddress;\n    this.chainId = chainId;\n    const headers = {};\n    if (isTwUrl(this.bundlerUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (secretKey) {\n        headers[\"x-secret-key\"] = secretKey;\n      } else if (clientId) {\n        headers[\"x-client-id\"] = clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      setAnalyticsHeaders(headers);\n    }\n    this.userOpJsonRpcProvider = new providers.JsonRpcProvider({\n      url: this.bundlerUrl,\n      headers\n    }, {\n      name: \"Connected bundler network\",\n      chainId\n    });\n    this.initializing = this.validateChainId();\n  }\n  async validateChainId() {\n    // validate chainId is in sync with expected chainid\n    const chain = await this.userOpJsonRpcProvider.send(\"eth_chainId\", []);\n    const bundlerChain = parseInt(chain);\n    if (bundlerChain !== this.chainId) {\n      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);\n    }\n  }\n\n  /**\n   * send a UserOperation to the bundler\n   * @param userOp1 - The UserOperation to send\n   * @returns userOpHash the id of this operation, for getUserOperationTransaction\n   */\n  async sendUserOpToBundler(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_sendUserOperation\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_sendUserOperation\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async estimateUserOpGas(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_estimateUserOperationGas\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_estimateUserOperationGas\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async printUserOperation(method, _ref) {\n    {\n      return;\n    }\n  }\n}\n\nclass VerifyingPaymasterAPI extends PaymasterAPI {\n  constructor(paymasterUrl, entryPoint, clientId, secretKey) {\n    super();\n    this.paymasterUrl = paymasterUrl;\n    this.entryPoint = entryPoint;\n    this.clientId = clientId;\n    this.secretKey = secretKey;\n  }\n  async getPaymasterAndData(userOp) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (isTwUrl(this.paymasterUrl)) {\n      if (this.secretKey && this.clientId) {\n        throw new Error(\"Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.\");\n      }\n      if (this.secretKey) {\n        headers[\"x-secret-key\"] = this.secretKey;\n      } else if (this.clientId) {\n        headers[\"x-client-id\"] = this.clientId;\n        if (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis) {\n          headers[\"x-bundle-id\"] = globalThis.APP_BUNDLE_ID;\n        }\n      }\n\n      // Dashboard token.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token.\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      setAnalyticsHeaders(headers);\n    }\n\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const response = await fetch(this.paymasterUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [await hexlifyUserOp(userOp), this.entryPoint]\n      })\n    });\n    const res = await response.json();\n    if (!response.ok) {\n      const error = res.error || response.statusText;\n      const code = res.code || \"UNKNOWN\";\n      throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (DEBUG) {\n      console.debug(\"Paymaster result:\", res);\n    }\n    if (res.result) {\n      // some paymasters return a string, some return an object with more data\n      if (typeof res.result === \"string\") {\n        return {\n          paymasterAndData: res.result\n        };\n      } else {\n        return res.result;\n      }\n    } else {\n      const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);\n    }\n  }\n}\nconst getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);\n\n/**\n * This class encapsulates Ethers.js listener function and necessary UserOperation details to\n * discover a TransactionReceipt for the operation.\n *\n * TODO refactor this to a simple event listener on the entry point\n */\nclass UserOperationEventListener {\n  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.entryPoint = entryPoint;\n    this.sender = sender;\n    this.userOpHash = userOpHash;\n    this.nonce = nonce;\n    this.timeout = timeout;\n    _defineProperty(this, \"resolved\", false);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.boundLisener = this.listenerCallback.bind(this);\n  }\n  start() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);\n    // listener takes time... first query directly:\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      const res = await this.entryPoint.queryFilter(filter, -10); // look at last 10 blocks\n      if (res.length > 0) {\n        void this.listenerCallback(res[0]);\n      } else {\n        this.entryPoint.once(filter, this.boundLisener);\n      }\n    }, 100);\n  }\n  stop() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.entryPoint.off(\"UserOperationEvent\", this.boundLisener);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async listenerCallback() {\n    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {\n      param[_key] = arguments[_key];\n    }\n    // TODO clean this up..\n    // eslint-disable-next-line prefer-rest-params\n    const event = arguments[arguments.length - 1];\n    if (!event.args) {\n      console.error(\"got event without args\", event);\n      return;\n    }\n    // TODO: can this happen? we register to event by userOpHash..\n    if (event.args.userOpHash !== this.userOpHash) {\n      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);\n      return;\n    }\n    const transactionReceipt = await event.getTransactionReceipt();\n\n    // before returning the receipt, update the status from the event.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!event.args.success) {\n      await this.extractFailureReason(transactionReceipt);\n    }\n    this.stop();\n    this.resolve(transactionReceipt);\n    this.resolved = true;\n  }\n  async extractFailureReason(receipt) {\n    receipt.status = 0;\n    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);\n    if (revertReasonEvents[0]) {\n      let message = revertReasonEvents[0].args.revertReason;\n      if (message.startsWith(\"0x08c379a0\")) {\n        // Error(string)\n        message = utils.defaultAbiCoder.decode([\"string\"], \"0x\" + message.substring(10)).toString();\n      }\n      this.reject(new Error(`UserOp failed with reason: ${message}`));\n    }\n  }\n}\n\nclass ERC4337EthersSigner extends Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    utils.defineReadOnly(this, \"provider\", erc4337provider);\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction, options) {\n    const tx = await ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    try {\n      let errorMsg = \"Unknown Error\";\n      if (errorIn.error) {\n        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;\n      } else if (errorIn.body && typeof errorIn.body === \"string\") {\n        const errorBody = JSON.parse(errorIn.body);\n        const errorStatus = errorIn.status || \"UNKNOWN\";\n        const errorCode = errorBody?.code || \"UNKNOWN\";\n        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;\n        if (failedOpMessage?.includes(\"FailedOp\")) {\n          let paymasterInfo = \"\";\n          // TODO: better error extraction methods will be needed\n          const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n          if (matched) {\n            const split = matched[1].split(\",\");\n            paymasterInfo = `(paymaster address: ${split[1]})`;\n            failedOpMessage = split[2];\n          }\n          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;\n        } else {\n          errorMsg = `RPC error: ${failedOpMessage}\nStatus: ${errorStatus}\nCode: ${errorCode}`;\n        }\n      }\n      const error = new Error(errorMsg);\n      error.stack = errorIn.stack;\n      return error;\n    } catch (error) {}\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (!transactionRequest.to) {\n      throw new Error(\"Missing call target\");\n    }\n    if (!transactionRequest.data && !transactionRequest.value) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error(\"Missing call data or value\");\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connect(provider) {\n    throw new Error(\"changing providers is not supported\");\n  }\n  async getAddress() {\n    if (!this.address) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n  async signMessage(message) {\n    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();\n    if (isNotDeployed && this.config.deployOnSign) {\n      console.log(\"Account contract not deployed yet. Deploying account before signing message\");\n      const tx = await this.sendTransaction({\n        to: await this.getAddress(),\n        data: \"0x\"\n      });\n      await tx.wait();\n    }\n    return await this.originalSigner.signMessage(message);\n  }\n  async signTransaction(transaction, options) {\n    const tx = await ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const userOpString = JSON.stringify(await hexlifyUserOp(userOperation));\n    return userOpString;\n  }\n}\n\nclass ERC4337EthersProvider extends providers.BaseProvider {\n  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {\n    super({\n      name: \"ERC-4337 Custom Network\",\n      chainId\n    });\n    this.chainId = chainId;\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.originalProvider = originalProvider;\n    this.httpRpcClient = httpRpcClient;\n    this.entryPoint = entryPoint;\n    this.smartAccountAPI = smartAccountAPI;\n    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);\n  }\n  getSigner() {\n    return this.signer;\n  }\n  async perform(method, params) {\n    if (method === \"sendTransaction\" || method === \"getTransactionReceipt\") {\n      // TODO: do we need 'perform' method to be available at all?\n      // there is nobody out there to use it for ERC-4337 methods yet, we have nothing to override in fact.\n      throw new Error(\"Should not get here. Investigate.\");\n    }\n    if (method === \"estimateGas\") {\n      // gas estimation does nothing at this layer, sendTransaction will do the gas estimation for the userOp\n      return BigNumber.from(500000);\n    }\n    return await this.originalProvider.perform(method, params);\n  }\n  async getTransaction(transactionHash) {\n    // TODO\n    return await super.getTransaction(transactionHash);\n  }\n  async getTransactionReceipt(transactionHash) {\n    const userOpHash = await transactionHash;\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();\n    });\n  }\n  async getSenderAccountAddress() {\n    return await this.smartAccountAPI.getAccountAddress();\n  }\n  async waitForTransaction(transactionHash, confirmations, timeout) {\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);\n      listener.start();\n    });\n  }\n\n  // fabricate a response in a format usable by ethers users...\n  async constructUserOpTransactionResponse(userOp1) {\n    const userOp = await utils.resolveProperties(userOp1);\n    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);\n    const waitForUserOp = async () => await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, userOp.sender, userOpHash, userOp.nonce).start();\n    });\n    return {\n      hash: userOpHash,\n      confirmations: 0,\n      from: userOp.sender,\n      nonce: 0,\n      // not the real nonce, but good enough for this purpose\n      gasLimit: BigNumber.from(userOp.callGasLimit),\n      // ??\n      value: BigNumber.from(0),\n      data: utils.hexValue(userOp.callData),\n      // should extract the actual called method from this \"execFromEntryPoint()\" call\n      chainId: this.chainId,\n      wait: async confirmations => {\n        const transactionReceipt = await waitForUserOp();\n        if (userOp.initCode.length !== 0) {\n          // checking if the wallet has been deployed by the transaction; it must be if we are here\n          await this.smartAccountAPI.checkAccountPhantom();\n        }\n        return transactionReceipt;\n      }\n    };\n  }\n  async detectNetwork() {\n    return this.originalProvider.detectNetwork();\n  }\n}\n\n/**\n * wrap an existing provider to tunnel requests through Account Abstraction.\n * @param originalProvider - The normal provider\n * @param config - see {@link ClientConfig} for more info\n * @param originalSigner - use this signer as the owner. of this wallet. By default, use the provider's signer\n */\nfunction create4337Provider(config, accountApi, originalProvider, chainId) {\n  const entryPoint = EntryPoint__factory.connect(config.entryPointAddress, originalProvider);\n  const httpRpcClient = new HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);\n  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);\n}\n\nconst DUMMY_SIGNATURE = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  // entryPoint connected to \"zero\" address. allowed to make static calls (e.g. to getSenderAddress)\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    _defineProperty(this, \"isPhantom\", true);\n    this.provider = params.provider;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    this.gasless = params.gasless;\n\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers.constants.AddressZero);\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n\n  /**\n   * return current account's nonce.\n   */\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target - The target contract address\n   * @param value - The value to send to the target contract\n   * @param data - The calldata to send to the target contract\n   */\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash - The hash to sign\n   */\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return \"0x\";\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp - userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return getUserOpHashV06(userOp, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (!this.senderAddress) {\n      if (this.accountAddress) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (!initCode || initCode === \"0x\") {\n      return 0;\n    }\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = \"0x\" + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  async createUnsignedUserOp(httpRpcClient, info, options) {\n    // construct the userOp without gasLimit or preVerifictaionGas\n    const initCode = await this.getInitCode();\n    const value = parseNumber(info.value) ?? BigNumber.from(0);\n    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(tx => tx.encode());\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      const feeData = await getDynamicFeeData(this.provider);\n      if (!maxPriorityFeePerGas) {\n        maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n      }\n      if (!maxFeePerGas) {\n        maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n        const network = await this.provider.getNetwork();\n        const chainId = network.chainId;\n        if (chainId === Celo.chainId || chainId === CeloAlfajoresTestnet.chainId || chainId === CeloBaklavaTestnet.chainId) {\n          maxPriorityFeePerGas = maxFeePerGas;\n        }\n      }\n    }\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      throw new Error(\"maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely\");\n    }\n    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);\n    const partialOp = {\n      sender,\n      nonce,\n      initCode,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      callGasLimit: BigNumber.from(1000000),\n      verificationGasLimit: BigNumber.from(1000000),\n      preVerificationGas: BigNumber.from(1000000),\n      paymasterAndData: \"0x\",\n      signature: DUMMY_SIGNATURE\n    };\n\n    // paymaster data + maybe used for estimation as well\n    const gasless = options?.gasless !== undefined ? options.gasless : this.gasless;\n    if (gasless) {\n      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);\n      const paymasterAndData = paymasterResult.paymasterAndData;\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        partialOp.paymasterAndData = paymasterAndData;\n      }\n      // paymaster can have the gas limits in the response\n      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n        partialOp.callGasLimit = BigNumber.from(paymasterResult.callGasLimit);\n        partialOp.verificationGasLimit = BigNumber.from(paymasterResult.verificationGasLimit);\n        partialOp.preVerificationGas = BigNumber.from(paymasterResult.preVerificationGas);\n      } else {\n        // otherwise fallback to bundler for gas limits\n        let estimates;\n        try {\n          estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n        } catch (error) {\n          throw this.unwrapBundlerError(error);\n        }\n        partialOp.callGasLimit = BigNumber.from(estimates.callGasLimit);\n        partialOp.verificationGasLimit = BigNumber.from(estimates.verificationGasLimit);\n        partialOp.preVerificationGas = BigNumber.from(estimates.preVerificationGas);\n        // need paymaster to re-sign after estimates\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);\n          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;\n          }\n        }\n      }\n    } else {\n      // query bundler for gas limits\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = BigNumber.from(estimates.callGasLimit);\n      partialOp.verificationGasLimit = BigNumber.from(estimates.verificationGasLimit);\n      partialOp.preVerificationGas = BigNumber.from(estimates.preVerificationGas);\n    }\n    return {\n      ...partialOp,\n      signature: \"\"\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp - The UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature\n    };\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or null if not found\n   * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout - stop waiting after this timeout\n   * @param interval - time to wait between polls.\n   * @returns The transactionHash this userOp was mined, or null if not found.\n   */\n  async getUserOpReceipt(userOpHash) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30000;\n    let interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const events = await this.entryPointView.queryFilter(this.entryPointView.filters.UserOperationEvent(userOpHash));\n      if (events[0]) {\n        return events[0].transactionHash;\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    return null;\n  }\n  unwrapBundlerError(error) {\n    const message = error?.error?.message || error.error || error.message || error;\n    return new Error(message);\n  }\n}\nfunction parseNumber(a) {\n  if (!a || a === \"\") {\n    return null;\n  }\n  return BigNumber.from(a.toString());\n}\n\nclass AccountAPI extends BaseAccountAPI {\n  constructor(params, originalProvider) {\n    super({\n      ...params,\n      provider: originalProvider\n    });\n    this.params = params;\n    // Technically dont need the signer here, but we need to encode/estimate gas with it so a signer is required\n    // We don't want to use the localSigner directly since it might be connected to another chain\n    // so we just use the public hardhat pkey instead\n    this.sdk = ThirdwebSDK.fromPrivateKey(LOCAL_NODE_PKEY, params.chain, {\n      clientId: params.clientId,\n      secretKey: params.secretKey,\n      // @ts-expect-error expected chain type error\n      supportedChains: typeof params.chain === \"object\" ? [params.chain] : undefined\n    });\n  }\n  async getChainId() {\n    return await this.provider.getNetwork().then(n => n.chainId);\n  }\n  async getAccountContract() {\n    if (!this.accountContract) {\n      if (this.params.accountInfo?.abi) {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);\n      } else {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), ACCOUNT_CORE_ABI);\n      }\n    }\n    return this.accountContract;\n  }\n  async getAccountInitCode() {\n    const factory = await this.getFactoryContract();\n    console.log(\"Deploying smart wallet via factory\");\n    const localSigner = await this.params.localSigner.getAddress();\n    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);\n    try {\n      console.log(\"Cost to deploy smart wallet: \", (await tx.estimateGasCost()).ether, \"ETH\");\n    } catch (e) {\n      console.error(\"Cost to deploy smart wallet: unknown\", e);\n    }\n    return utils.hexConcat([factory.getAddress(), tx.encode()]);\n  }\n  async getFactoryContract() {\n    if (this.factoryContract) {\n      return this.factoryContract;\n    }\n    if (this.params.factoryInfo?.abi) {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);\n    } else {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);\n    }\n    return this.factoryContract;\n  }\n  async getCounterFactualAddress() {\n    if (this.params.accountAddress) {\n      return this.params.accountAddress;\n    }\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    return this.params.factoryInfo.getAccountAddress(factory, localSigner);\n  }\n  async getNonce() {\n    if (await this.checkAccountPhantom()) {\n      return BigNumber.from(0);\n    }\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.getNonce(accountContract);\n  }\n  async prepareExecute(target, value, data) {\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.execute(accountContract, target, value, data);\n  }\n  async prepareExecuteBatch(targets, values, datas) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.prepare(\"executeBatch\", [targets, values, datas]);\n  }\n  async signUserOpHash(userOpHash) {\n    return await this.params.localSigner.signMessage(utils.arrayify(userOpHash));\n  }\n  async isAcountDeployed() {\n    return !(await this.checkAccountPhantom());\n  }\n}\n\nclass SmartWalletConnector extends Connector {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  async initialize(params) {\n    const config = this.config;\n    const originalProvider = getChainProvider(config.chain, {\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    });\n    this.chainId = (await originalProvider.getNetwork()).chainId;\n    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com/v2`;\n    const entryPointAddress = config.entryPointAddress || ENTRYPOINT_ADDRESS;\n    const deployOnSign = config.deployOnSign ?? true;\n    const localSigner = await params.personalWallet.getSigner();\n    const providerConfig = {\n      chain: config.chain,\n      localSigner,\n      entryPointAddress,\n      bundlerUrl,\n      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),\n      gasless: config.gasless,\n      deployOnSign: deployOnSign,\n      factoryAddress: config.factoryAddress,\n      accountAddress: params.accountAddress,\n      factoryInfo: config.factoryInfo || this.defaultFactoryInfo(),\n      accountInfo: config.accountInfo || this.defaultAccountInfo(),\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    };\n    this.personalWallet = params.personalWallet;\n    const accountApi = new AccountAPI(providerConfig, originalProvider);\n    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);\n    this.accountApi = accountApi;\n  }\n  async connect(connectionArgs) {\n    await this.initialize(connectionArgs);\n    return await this.getAddress();\n  }\n  getProvider() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider);\n  }\n  async getSigner() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider.getSigner());\n  }\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n  async isConnected() {\n    try {\n      const address = await this.getAddress();\n      return !!address;\n    } catch (e) {\n      return false;\n    }\n  }\n  async disconnect() {\n    this.personalWallet = undefined;\n    this.aaProvider = undefined;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const currentChainId = (await provider.getNetwork()).chainId;\n    if (currentChainId !== chainId) {\n      // only throw if actually trying to switch chains\n      throw new Error(\"Not supported.\");\n    }\n  }\n  setupListeners() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateChains(chains) {}\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction - The transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const accountContract = await this.getAccountContract();\n    const signer = await this.getSigner();\n    const signerAddress = await signer.getAddress();\n    const restrictions = (await accountContract.account.getAllSigners()).filter(item => ethers.utils.getAddress(item.signer) === ethers.utils.getAddress(signerAddress))[0]?.permissions;\n    if (!restrictions) {\n      return false;\n    }\n    return restrictions.approvedCallTargets.includes(transaction.getTarget());\n  }\n\n  /// PREPARED TRANSACTIONS\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transaction - the transaction to send\n   * @param config - optional the transaction configuration\n   * @returns The awaitable transaction\n   */\n  async send(transaction, options) {\n    const signer = await this.getSigner();\n    return signer.sendTransaction({\n      to: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue()\n    }, options);\n  }\n\n  /**\n   * Execute a single transaction (waiting for confirmations)\n   * @param transaction - The transaction to execute\n   * @returns The transaction receipt\n   */\n  async execute(transaction, options) {\n    const tx = await this.send(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions - The transactions to execute\n   * @returns The transaction receipt\n   */\n  async executeBatch(transactions, options) {\n    const tx = await this.sendBatch(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// RAW TRANSACTIONS\n\n  async sendRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    return signer.sendTransaction(transaction, options);\n  }\n  async executeRaw(transaction, options) {\n    const tx = await this.sendRaw(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const batch = await this.prepareBatchRaw(transactions);\n    return signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: batch.tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData: batch.batchData // batched tx flag\n    });\n  }\n  async executeBatchRaw(transactions, options) {\n    const tx = await this.sendBatchRaw(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// ESTIMATION\n\n  async estimate(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return this.estimateTx({\n      target: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue(),\n      gasLimit: await transaction.getOverrides().gasLimit,\n      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,\n      nonce: await transaction.getOverrides().nonce\n    }, options);\n  }\n  async estimateRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const tx = await ethers.utils.resolveProperties(transaction);\n    return this.estimateTx({\n      target: tx.to || constants.AddressZero,\n      data: tx.data?.toString() || \"\",\n      value: tx.value || BigNumber.from(0),\n      gasLimit: tx.gasLimit,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      nonce: tx.nonce\n    }, options);\n  }\n  async estimateBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n  async estimateBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchRaw(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  //// DEPLOYMENT\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns The transaction receipt\n   */\n  async deploy(options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const tx = await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: \"0x\"\n    }, {\n      ...options,\n      batchData: {\n        targets: [],\n        data: [],\n        values: []\n      } // batched tx flag to avoid hitting the Router fallback method\n    });\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return await this.accountApi.isAcountDeployed();\n  }\n  async deployIfNeeded(options) {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      await this.deploy(options);\n    }\n  }\n\n  //// PERMISSIONS\n\n  async grantPermissions(target, permissions) {\n    await this.deployIfNeeded();\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantPermissions(target, permissions);\n  }\n  async revokePermissions(target) {\n    await this.deployIfNeeded();\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAccess(target);\n  }\n  async addAdmin(target) {\n    await this.deployIfNeeded();\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantAdminPermissions(target);\n  }\n  async removeAdmin(target) {\n    await this.deployIfNeeded();\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAdminPermissions(target);\n  }\n  async getAllActiveSigners() {\n    const isDeployed = await this.isDeployed();\n    if (isDeployed) {\n      const accountContract = await this.getAccountContract();\n      return accountContract.account.getAllAdminsAndSigners();\n    } else {\n      const personalWallet = await this.personalWallet?.getSigner();\n      if (!personalWallet) {\n        throw new Error(\"Personal wallet not connected\");\n      }\n      return [{\n        isAdmin: true,\n        signer: await personalWallet.getAddress(),\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      }];\n    }\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns The account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      throw new Error(\"Account contract is not deployed yet. You can deploy it manually using SmartWallet.deploy(), or by executing a transaction from this wallet.\");\n    }\n    // getting a new instance everytime\n    // to avoid caching issues pre/post deployment\n    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.accountInfo?.abi) {\n      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);\n    } else {\n      return sdk.getContract(await this.getAddress());\n    }\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns The account factory contract.\n   */\n  async getFactoryContract() {\n    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.factoryInfo?.abi) {\n      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);\n    }\n    return sdk.getContract(this.config.factoryAddress);\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async (factory, owner) => {\n        return factory.prepare(\"createAccount\", [owner, ethers.utils.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async (factory, owner) => {\n        return await factory.call(\"getAddress\", [owner, ethers.utils.toUtf8Bytes(\"\")]);\n      }\n    };\n  }\n  defaultAccountInfo() {\n    return {\n      execute: async (account, target, value, data) => {\n        return account.prepare(\"execute\", [target, value, data]);\n      },\n      getNonce: async account => {\n        return account.call(\"getNonce\", []);\n      }\n    };\n  }\n\n  /// PRIVATE METHODS\n\n  async estimateTx(tx, options) {\n    if (!this.accountApi || !this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    let deployGasLimit = BigNumber.from(0);\n    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);\n    if (!isDeployed) {\n      deployGasLimit = await this.estimateDeploymentGasLimit();\n    }\n    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), getGasPrice(provider)]);\n    const resolved = await utils.resolveProperties(userOp);\n    const transactionGasLimit = BigNumber.from(resolved.callGasLimit);\n    const transactionCost = transactionGasLimit.mul(gasPrice);\n    const deployCost = deployGasLimit.mul(gasPrice);\n    const totalCost = deployCost.add(transactionCost);\n    return {\n      ether: utils.formatEther(totalCost),\n      wei: totalCost,\n      details: {\n        deployGasLimit,\n        transactionGasLimit,\n        gasPrice,\n        transactionCost,\n        deployCost,\n        totalCost\n      }\n    };\n  }\n  async estimateDeploymentGasLimit() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const initCode = await this.accountApi.getInitCode();\n    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);\n    return BigNumber.from(verificationGasLimit).add(initGas);\n  }\n  async prepareBatchRaw(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const resolvedTxs = await Promise.all(transactions.map(transaction => ethers.utils.resolveProperties(transaction)));\n    const targets = resolvedTxs.map(tx => tx.to || constants.AddressZero);\n    const data = resolvedTxs.map(tx => tx.data || \"0x\");\n    const values = resolvedTxs.map(tx => tx.value || BigNumber.from(0));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n  async prepareBatchTx(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const targets = transactions.map(tx => tx.getTarget());\n    const data = transactions.map(tx => tx.encode());\n    const values = await Promise.all(transactions.map(tx => tx.getValue()));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n}\n\nexport { SmartWalletConnector };\n"],"names":["getFunctionSignature","fnInputs","map","i","type","components","join","generateExtensionFunctions","extensionAbi","extensionInterface","utils","extensionFunctions","fnFragment","Object","values","functions","fn","getFunction","getSighash","name","startsWith","push","functionSelector","functionSignature","inputs","async","getDeploymentInfo","metadataUri","storage","provider","create2Factory","clientId","secretKey","caches","deploymentPresets","create2FactoryAddress","compilerMetadata","extendedMetadata","Promise","all","getCreate2FactoryAddress","fetchAndCacheDeployMetadata","customParams","finalDeploymentInfo","defaultExtensions","routerType","invariant","publishedExtensions","e","fetchPublishedContractFromPolygon","publisherAddress","extensionName","extensionVersion","pluginMetadata","c","fetchedMetadata","pluginDeploymentInfo","metadata","computeDeploymentInfo","mapInput","forEach","index","input","pluginAddress","pluginAbi","pluginInterface","pluginFunctions","includes","generatePluginFunctions","transaction","predictedAddress","abi","pluginMapTransaction","contractName","constructorParams","_pluginsToAdd","value","extensionMetadata","extensionDeploymentInfo","routerInput","metadataURI","implementation","implementationDeployInfo","factoryInfo","createTransactionBatches","transactions","upperGasLimit","arguments","length","undefined","GAS_LIMIT_FOR_DEPLOYER","filter","tx","data","transactionBatches","sum","batch","gas","initCode","gasLimit","x","reduce","Math","ceil","floor","estimateGasForDeploy","deployWithThrowawayDeployer","signer","options","_options$notifier","_options$notifier2","notifier","call","deployTxns","txBatch","ContractFactory","DEPLOYER_ABI","DEPLOYER_BYTECODE","connect","deploy","deployed","deployContractDeterministic","isContractDeployed","_options$notifier3","_options$notifier4","console","debug","concat","to","estimateGas","BigNumber","from","sendTransaction","wait","isTwUrl","url","host","URL","hostname","endsWith","getValidPublicRPCUrl","chain","getValidChainRPCs","rpc","pathname","search","toString","ContractPublisher","RPCConnectionHandler","constructor","network","super","_defineProperty","buildTransactionFunction","this","getSigner","publisher","getAddress","profileUri","upload","profileMetadata","Transaction","fromContractWrapper","contractWrapper","method","args","predeployUri","extraMetadata","extraMetadataCleaned","cleanupOldPublishFlowData","predeployMetadata","fetchRawPredeployMetadata","fetchContractMetadata","isPlugin","isFeatureEnabled","AbiSchema","parse","isDynamic","publishedExtensionUris","ext","extensionABIs","uri","composite","joinABIs","compositeAbi","latestContract","getLatest","latestVersion","fetchPublishedContractInfo","publishedMetadata","version","isIncrementalVersion","Error","fetchedBytecode","download","bytecodeUri","text","bytecode","bytecodeHash","contractId","fullMetadata","FullPublishMetadataSchemaInput","parseAsync","analytics","fullMetadataUri","constants","receipt","events","parseLogs","logs","contract","publishedContract","toPublishedContract","resolvedPublisher","resolveAddress","ContractWrapper","getContractPublisherAddress","ContractPublisherAbi","updateSignerOrProvider","extractConstructorParams","predeployMetadataUri","meta","fetchPreDeployMetadata","extractConstructorParamsFromAbi","extractFunctions","extractFunctionsFromAbi","fetchCompilerMetadataFromPredeployURI","fetchPrePublishMetadata","prepublishUri","preDeployMetadataFetched","latestPublishedContract","preDeployMetadata","latestPublishedContractMetadata","fetchCompilerMetadataFromAddress","address","resolvedAddress","fetchContractMetadataFromAddress","getProvider","id","publishedTimestamp","timestamp","fetchFullPublishMetadata","publishedMetadataUri","fetchExtendedReleaseMetadata","resolvePublishMetadataFromCompilerMetadata","compilerMetadataUri","read","resolveContractUriFromAddress","contractUri","fetchContractSourcesFromAddress","fetchSourceFilesFromMetadata","fetchContractAbiFromAddress","getPublisherProfile","resolvedPublisherAddress","ProfileSchemaOutput","downloadJSON","getAll","acc","curr","entries","_ref","struct","getAllVersions","contractStructs","d","getVersion","allVersions","versionMatch","find","model","publishMetadataUri","contractModel","PublishedContractSchema","publishTimestamp","isDeployableViaFactory","isDeployableViaProxy","factoryDeploymentData","implementationAddresses","factoryAddresses","alreadyChecked","getThirdwebContractAddress","chainId","contractVersion","getChainProvider","contractAddress","publishUri","THIRDWEB_DEPLOYER$1","_deploymentInfo$find2","predictThirdwebContractAddress","isDeployed","VerificationStatus","RequestStatus","OK","NOTOK","verifyThirdwebPrebuiltImplementation","explorerAPIUrl","explorerAPIKey","constructorArgs","encodedArgs","constructorParamMap","_deploymentInfo$find","encodeConstructorParamsForImplementation","getEncodedConstructorParamsForThirdwebContract","info","verify","replace","encodedConstructorArgs","resolveImplementation","compilerVersion","compiler","sources","sourcesWithUrl","sourcesWithContents","path","keys","sourceCode","source","filename","content","compilerInput","language","settings","optimizer","evmVersion","remappings","outputSelection","compilationTarget","contractPath","constructorParamTypes","result","fetch","json","status","txHash","getTransaction","txDeployBytecode","compilerMetaUri","default","Contract","getPublishedUriFromCompilerUri","pubmeta","fetchDeployBytecodeFromPublishedContractMetadata","bytecodeHex","error","create2SaltLength","substring","matches","matchAll","constructorParamByteLength","decode","fetchConstructorParams","requestBody","apikey","module","action","contractaddress","JSON","stringify","codeformat","contractname","compilerversion","constructorArguements","parameters","URLSearchParams","headers","body","checkVerificationStatus","guid","endpoint","resolve","reject","intervalId","setInterval","clearInterval","ContractVerifier","verifyThirdwebContract","getNetwork","verificationStatus","verifyContract","paramTypes","arg","paramValues","encode","LOCAL_NODE_PKEY","UserWallet","EventEmitter","connection","emit","transfer","amount","currencyAddress","NATIVE_TOKEN_ADDRESS","resolvedTo","resolvedCurrency","amountInWei","normalizePriceValue","requireWallet","isNativeToken","gasOverrides","isBrowser","getDefaultGasOverrides","ERC20Abi","createErc20","balance","getBalance","fetchCurrencyValue","getChainId","getNonce","blockTag","getTransactionCount","isConnected","sign","message","signMessage","signTypedData","domain","types","signTypedDataInternal","recoverAddress","signature","messageHash","messageHashBytes","sendRawTransaction","transactionRequest","executeRawTransaction","requestFunds","ChainId","Localhost","Hardhat","Wallet","getSignerOrProvider","getAllDetectedExtensionNames","features","extractFeatures","detectFeatures","f","getAllDetectedFeatureNames","MultichainRegistry","deployerAddress","registryRouter","getSignerAddress","registryLogic","encoded","contractEncoder","ContractEncoder","contracts","contact","getMultichainRegistryAddress","TWRegistryABI","TWRegistryRouterABI","updateSigner","getContractMetadataURI","getContractMetadata","getContractAddresses","walletAddress","deploymentAddress","toLowerCase","toNumber","extractFunctionParamsFromAbi","functionName","parsedAbi","convertParamValues","constructorParamValues","p","deployCreate2Factory","COMMON_FACTORY","enforceEip155","isEIP155Enforced","networkId","deploymentInfo","CUSTOM_GAS_FOR_CHAIN","getCreate2FactoryDeploymentInfo","gasPrice","deployment","_CUSTOM_GAS_FOR_CHAIN","_CUSTOM_GAS_FOR_CHAIN2","valueToSend","mul","lt","err","Mainnet","Goerli","Polygon","Mumbai","Fantom","FantomTestnet","Avalanche","AvalancheFujiTestnet","Optimism","OptimismGoerli","Arbitrum","ArbitrumGoerli","BinanceSmartChainMainnet","BinanceSmartChainTestnet","overrideRecipientAddress","signerAddress","recipient","getDeployArguments","contractType","contractURI","trustedForwarders","trusted_forwarders","NFTDropInitializer","NFTCollectionInitializer","erc721metadata","schema","symbol","primary_sale_recipient","fee_recipient","seller_fee_basis_points","platform_fee_basis_points","platform_fee_recipient","SignatureDropInitializer","signatureDropmetadata","MultiwrapInitializer","multiwrapMetadata","EditionDropInitializer","EditionInitializer","erc1155metadata","TokenDropInitializer","TokenInitializer","erc20metadata","VoteInitializer","voteMetadata","voting_token_address","voting_delay_in_blocks","voting_period_in_blocks","proposal_token_threshold","voting_quorum_fraction","SplitInitializer","splitsMetadata","recipients","s","sharesBps","MarketplaceInitializer","MarketplaceV3Initializer","marketplaceMetadata","PackInitializer","packsMetadata","APPROVED_IMPLEMENTATIONS","factoryAddr","TWFactoryAbi","contractMetadata","eventEmitter","onExecute","PREBUILT_CONTRACTS_MAP","implementationAddress","getImplementation","ABI","getAbi","encodedFunc","getInterface","encodeFunctionData","blockNumber","getBlockNumber","salt","saltForProxyDeploy","proxy","transactionHash","implementationAbi","initializerFunction","initializerArgs","marketplaceV3Metadata","encodedType","approvedImplementation","approvedImpls","getApprovedImplementation","getChainID","DEFAULT_VERSION_MAP","getLatestVersion","getContractName","ContractRegistry","registryAddress","addContracts","prepare","contractAddresses","addr","removeContracts","adr","LoyaltyCardContractInput","CommonContractSchema","merge","CommonRoyaltySchema","CommonSymbolSchema","LoyaltyCardContractDeploy","CommonPlatformFeeSchema","CommonPrimarySaleSchema","CommonTrustedForwarderSchema","AirdropContractInput","AirdropContractDeploy","directDeployDeterministic","saltForCreate2","bytecodePrefixed","paramTypesForEncoder","computeDeploymentAddress","initBytecodeWithSalt","getInitBytecodeWithSalt","predictAddressDeterministic","ThirdwebSDK","fromWallet","wallet","fromSigner","signerWithProvider","sdk","addChainToSupportedChains","fromPrivateKey","privateKey","_options2","warnMessage","warn","Map","setSupportedChains","supportedChains","configuredStorage","gatewayUrls","ThirdwebStorage","createStorage","storageHandler","deployer","ContractDeployer","verifier","multiChainRegistry","_publisher","auth","getNFTDrop","getContract","getSignatureDrop","getNFTCollection","getEditionDrop","getEdition","getTokenDrop","getToken","getVote","getSplit","getMarketplace","getMarketplaceV3","getPack","getMultiwrap","contractTypeOrABI","contractCache","has","get","GENERATED_ABI","getContractFromAbi","newContract","initialize","getPublisher","resolvedContractType","resolveContractType","contractAbi","set","getBuiltInContract","IThirdwebContractABI","remoteContractType","getContractTypeForRemoteName","getContractList","_await$this$deployer$","addresses","getRegistry","extensions","getMultichainContractList","chains","defaultChains","chainMap","sdkMap","chainSDK","readonlySettings","updateContractSignerOrProvider","onNetworkUpdated","SmartContract","getSignerAndProvider","parsedABI","getCompositeABI","_options3","isChainConfig","THIRDWEB_DEPLOYER","event","buildDeployTransactionFunction","deployBuiltInContract","_this$getSigner","parsedMetadata","deployArgs","deployReleasedContract","_this$getSigner2","DropErc721ContractSchema","deployPublishedContract","_this$getSigner3","_this$getSigner4","_this$getSigner5","_this","app_uri","PREBUILT_CONTRACTS_APPURI_MAP","hasLocalFactory","parsedVersion","parseInt","isNaN","factory","getFactory","on","EventType","transactionListener","off","deployContractFromUri","_this2","factoryAddress","resolvedFactoryAddress","resolvedImplementationAddress","proxyFactory","deployProxyByImplementation","encodedInitializer","TWProxy__factory","deployContractWithAbi","deployMetadata","_deploymentInfo$find3","transactionsToSend","transactionsforDirectDeploy","transactionsForThrowawayDeployer","cloneFactory","computeCloneFactoryAddress","proxyDeployTransaction","deployViaFactory","_deployMetadata$exten","_deployMetadata$exten2","customFactoryAddress","customFactoryInput","customFactoryAddresses","resolvedCustomFactoryAddress","factoryFunction","customFactoryMetadata","factoryFunctionparamValues","deployedImplementationAddress","deployTransaction","fromContractInfo","simulate","_extendedMetadata$net","_extendedMetadata$net2","forceDirectDeploy","isNetworkEnabled","networksForDeployment","networksEnabled","allNetworks","deployType","deployViaCustomFactory","implementationInitializerFunction","deployViaAutoFactory","deployProxy","ContractFactory$1","DeployTransaction","getLatestBuiltInContractVersion","deployPublishedContractDeterministic","directDeployDeterministicPublished","predictAddressDeterministicPublished","_registry","then","_ref2","getContractAddressByChainId","_factory","_ref3","_this$_factory","_this$_registry","catch","registry","getTransactionsForDeploy","Boolean","addDeployListener","listener","removeDeployListener","removeAllDeployListeners","removeAllListeners","getProcessEnv","hexlifyUserOp","op","userOp","key","val","k","v","randomNonce","hexString","generateRandomUint192","rand1","BigInt","random","rand2","rand3","rand4","rand5","rand6","PaymasterAPI","HttpRpcClient","bundlerUrl","entryPointAddress","bundleId","globalThis","APP_BUNDLE_ID","TW_AUTH_TOKEN","TW_CLI_AUTH_TOKEN","setAnalyticsHeaders","userOpJsonRpcProvider","providers","initializing","validateChainId","send","bundlerChain","sendUserOpToBundler","userOp1","hexifiedUserOp","jsonRequestData","printUserOperation","estimateUserOpGas","VerifyingPaymasterAPI","paymasterUrl","entryPoint","getPaymasterAndData","response","jsonrpc","params","res","ok","statusText","code","paymasterAndData","_res$error","getVerifyingPaymaster","UserOperationEventListener","sender","userOpHash","nonce","timeout","boundLisener","listenerCallback","bind","start","filters","UserOperationEvent","setTimeout","queryFilter","once","stop","_len","param","Array","_key","_this$nonce","log","transactionReceipt","getTransactionReceipt","success","extractFailureReason","resolved","revertReasonEvents","UserOperationRevertReason","blockHash","revertReason","ERC4337EthersSigner","Signer","config","originalSigner","erc4337provider","httpRpcClient","smartAccountAPI","_tx$data","ethers","verifyAllNecessaryFields","multidimensionalNonce","unsigned","createUnsignedUserOp","target","maxFeePerGas","maxPriorityFeePerGas","userOperation","signUserOp","transactionResponse","constructUserOpTransactionResponse","unwrapError","errorIn","errorMsg","_errorBody$error","_errorBody$error2","_failedOpMessage","errorBody","errorStatus","errorCode","failedOpMessage","reason","paymasterInfo","matched","match","split","stack","getSenderAccountAddress","checkAccountPhantom","deployOnSign","signTransaction","_tx$data2","ERC4337EthersProvider","originalProvider","perform","getAccountAddress","waitForTransaction","confirmations","getUserOpHash","waitForUserOp","hash","callGasLimit","callData","detectNetwork","BaseAccountAPI","accountAddress","paymasterAPI","gasless","entryPointView","EntryPoint__factory","isPhantom","getCode","getInitCode","getAccountInitCode","getVerificationGasLimit","net","hashedUserOp","initCodeHash","callDataHash","verificationGasLimit","preVerificationGas","paymasterAndDataHash","enc","getUserOpHashV06","senderAddress","getCounterFactualAddress","estimateCreationGas","deployerCallData","_parseNumber","a","parseNumber","batchData","prepareExecute","feeData","getDynamicFeeData","_feeData$maxPriorityF","_feeData$maxFeePerGas","Celo","CeloAlfajoresTestnet","CeloBaklavaTestnet","partialOp","paymasterResult","estimates","unwrapBundlerError","paymasterResult2","signUserOpHash","getUserOpReceipt","interval","endtime","Date","now","_error$error","AccountAPI","n","getAccountContract","_this$params$accountI","accountContract","accountInfo","ACCOUNT_CORE_ABI","getFactoryContract","localSigner","createAccount","estimateGasCost","ether","_this$params$factoryI","factoryContract","execute","prepareExecuteBatch","targets","datas","isAcountDeployed","SmartWalletConnector","Connector","_config$deployOnSign","ENTRYPOINT_ADDRESS","personalWallet","providerConfig","defaultFactoryInfo","defaultAccountInfo","accountApi","aaProvider","create4337Provider","connectionArgs","disconnect","switchChain","setupListeners","updateChains","hasPermissionToExecute","_await$accountContrac","restrictions","account","getAllSigners","item","permissions","approvedCallTargets","getTarget","getValue","sendBatch","prepareBatchTx","executeBatch","sendRaw","executeRaw","sendBatchRaw","prepareBatchRaw","executeBatchRaw","estimate","estimateTx","getOverrides","estimateRaw","_tx$data3","estimateBatch","estimateBatchRaw","deployIfNeeded","grantPermissions","revokePermissions","revokeAccess","addAdmin","grantAdminPermissions","removeAdmin","revokeAdminPermissions","getAllActiveSigners","getAllAdminsAndSigners","_this$personalWallet","isAdmin","startDate","expirationDate","nativeTokenLimitPerTransaction","_this$config$accountI","_this$config$factoryI","owner","deployGasLimit","estimateDeploymentGasLimit","getGasPrice","transactionGasLimit","transactionCost","deployCost","totalCost","add","wei","details","initGas","resolvedTxs"],"sourceRoot":""}