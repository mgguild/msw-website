"use strict";(self.webpackChunkMetaSaga_Warriors=self.webpackChunkMetaSaga_Warriors||[]).push([[4470],{85663:(t,a,e)=>{e.d(a,{D:()=>w,F:()=>d,I:()=>c,a:()=>p,b:()=>u,c:()=>h,f:()=>l,g:()=>y,u:()=>f});var r=e(37843),n=e(50489),s=e(23475),o=e(51027),i=e(84787).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),d={name:"Failed to load NFT metadata"};async function l(t,a,e){if(a.startsWith("data:application/json;base64")&&"undefined"!==typeof i){const e=a.split(",")[1],n=JSON.parse(i.from(e,"base64").toString("utf-8"));return r.C.parse({...n,id:s.O$.from(t).toString(),uri:a})}const o=a.replace("{id}",n.hexZeroPad(s.O$.from(t).toHexString(),32).slice(2));let c;try{c=await e.downloadJSON(o)}catch(p){const r=a.replace("{id}",s.O$.from(t).toString());try{c=await e.downloadJSON(r)}catch(l){console.warn("failed to get token metadata: ".concat(JSON.stringify({tokenId:t.toString(),tokenUri:a})," -- falling back to default metadata")),c=d}}return r.C.parse({...c,id:s.O$.from(t).toString(),uri:a})}async function h(t,a,n,i){let h;const u=(await e.e(5025).then(e.t.bind(e,25025,19))).default,f=new o.CH(t,u,a),[y,w]=await Promise.all([f.supportsInterface(c),f.supportsInterface(p)]);if(y){const r=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,s=new o.CH(t,r,a);h=await s.tokenURI(n)}else{if(!w)throw Error("Contract must implement ERC 1155 or ERC 721.");{const r=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,s=new o.CH(t,r,a);h=await s.uri(n)}}return h?l(n,h,i):r.C.parse({...d,id:s.O$.from(n).toString(),uri:""})}async function u(t,a){return"string"===typeof t?t:await a.upload(r.a.parse(t))}async function f(t,a,e,n){if(function(t){return void 0===t.find((t=>"string"!==typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!==typeof t))}(t)){return await a.uploadBatch(t.map((t=>r.a.parse(t))),{rewriteFileNames:{fileStartNumber:e||0},onProgress:null===n||void 0===n?void 0:n.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function y(t){const a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw new Error("Can only create batches with the same base URI for every entry in the batch. Expected '".concat(a,"' but got '").concat(r,"'"))}return a.replace(/\/$/,"")+"/"}const w=100},14470:(t,a,e)=>{e.d(a,{C:()=>m,D:()=>W,a:()=>b,c:()=>I});var r=e(71818),n=e(57470),s=e(64127),o=e(19928),i=e(75867),c=e(24731),p=e(60387),d=e(4004),l=e(50489),h=e(23475),u=e(51027),f=e(37843),y=e(85663),w=e(16482),g=e(37367);class m{constructor(t,a){(0,r.Z)(this,"featureName",o.d1.name),(0,r.Z)(this,"setDefaultRoyaltyInfo",(0,s.d)((async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),r=await this.metadata._parseAndUploadMetadata(e);if((0,n.h)("setContractURI",this.contractWrapper)){const t=new i.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[r])];return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}))),(0,r.Z)(this,"setTokenRoyaltyInfo",(0,s.d)((async(t,a)=>{const e=o.bD.parse(a);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))),this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return o.bD.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return o.bD.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}}class W{constructor(t,a,e,n){(0,r.Z)(this,"createDelayedRevealBatch",(0,s.d)((async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const n=await this.storage.uploadBatch([f.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),o=(0,y.g)(n),i=await this.nextTokenIdToMintFn(),l=await this.storage.uploadBatch(a.map((t=>f.a.parse(t))),{onProgress:null===r||void 0===r?void 0:r.onProgress,rewriteFileNames:{fileStartNumber:i.toNumber()}}),h=(0,y.g)(l),u=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(u,e),g=await this.contractWrapper.read("encryptDecrypt",[c.Y0(h),w]);let m;if(await this.isLegacyContract())m=g;else{const t=await this.contractWrapper.getChainID(),a=p.keccak256(["bytes","bytes","uint256"],[c.Y0(h),w,t]);m=d.$.encode(["bytes","bytes32"],[g,a])}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,o.endsWith("/")?o:"".concat(o,"/"),m],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",null===t||void 0===t?void 0:t.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let s=e;s.lte(r);s=s.add(1))n.push({id:s,receipt:t});return n}})}))),(0,r.Z)(this,"reveal",(0,s.d)((async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw new Error("invalid password")}catch(r){throw new Error("invalid password")}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}))),this.featureName=e,this.nextTokenIdToMintFn=n,this.contractWrapper=t,this.storage=a}async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map((t=>{if((0,n.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,n.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),r=e.slice(0,e.length-1),s=await Promise.all(Array.from([0,...r]).map((t=>this.getNftMetadata(t.toString())))),o=await this.isLegacyContract(),i=(await Promise.all(Array.from([...e]).map((t=>o?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(l.hexDataLength(t)>0){if(o)return t;return d.$.decode(["bytes","bytes32"],t)[0]}return t}));return s.map(((t,a)=>({batchId:h.O$.from(a),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,a)=>l.hexDataLength(i[a])>0))}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return p.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,y.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,n.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const a=(await e.e(8839).then(e.t.bind(e,98839,19))).default,r=new u.CH(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function I(t,a,e,r,n){let s={};const i=r||o.aV,c=(await(0,g.n)(t.getProvider(),a,i)).mul(e);return c.gt(0)&&(i===o.aV?s={value:c}:i!==o.aV&&n&&await(0,w.a)(t,i,c,e,0)),s}class b{constructor(t){(0,r.Z)(this,"featureName",o.d2.name),(0,r.Z)(this,"set",(0,s.d)((async t=>{const a=await(0,o.aL)(t);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})}))),this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}}}}]);
//# sourceMappingURL=4470.b8eb0bc3.chunk.js.map