(self.webpackChunkMetaSaga_Warriors=self.webpackChunkMetaSaga_Warriors||[]).push([[3812],{34240:(e,a,t)=>{"use strict";t.d(a,{SafeConnector:()=>A});var n=t(80584),s=t(70252),r=t(1624),i=t(60852),o=t(38856),c=t(15076),d=t(70036),h=t(11208),f=t(9384),g=t.n(f),p=t(47016);t(83440);const w={1:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",137:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",56:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",42161:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",1313161554:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",43114:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",10:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",84531:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",42220:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",5:"0x58FCe385Ed16beB4BCE49c8DF34c7d6975807520",100:"0x58FCe385Ed16beB4BCE49c8DF34c7d6975807520"},u=[{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"msgHash",type:"bytes32"}],name:"SignMsg",type:"event"},{inputs:[{internalType:"bytes",name:"message",type:"bytes"}],name:"getMessageHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes",name:"_data",type:"bytes"}],name:"signMessage",outputs:[],stateMutability:"nonpayable",type:"function"}];class A extends s.C{constructor(){super(),(0,n._)(this,"supportedChains",A.supportedChains),(0,n._)(this,"id","safe-wallet"),(0,n._)(this,"ready",!0),(0,n._)(this,"name","Safe Wallet"),this.ready=!0}async connect(e){if(!(e.chain.chainId in p.C))throw new Error("Chain not supported by Safe");return this.safeSigner=await this.createSafeSigner(e),await this.getAddress()}async createSafeSigner(e){this.personalWallet=e.personalWallet;const a=await e.personalWallet.getSigner(),t=e.safeAddress,n=e.chain.chainId;if(!a)throw new Error("cannot create Gnosis Safe signer without a personal signer");if(await a.getChainId()!==n)throw new Error("chainId of personal signer has to match safe chainId");if(!t)throw new Error("safeAddress is required");if(!n)throw new Error("safeChainId is required");const s=p.C[n],d=w[n];if(!s||!d)throw new Error("Chain not supported");const A=new f.EthersAdapter({ethers:r,signerOrProvider:a}),y=await g().create({ethAdapter:A,safeAddress:t}),l=new h.SafeService(s),b=new h.SafeEthersSigner(y,l,a.provider);return b.signMessage=async e=>{const t=new i.q(d,u).interface.encodeFunctionData("signMessage",[o.S(e)]),n=d,s=c.e,r=c.e,h=await y.createTransaction({safeTransactionData:{to:n,value:"0",operation:1,data:t,baseGas:5e4,safeTxGas:5e4,gasPrice:0,gasToken:s,refundReceiver:r}}),f=await y.getTransactionHash(h),g=await y.signTransactionHash(f);for(await l.proposeTx(await y.getAddress(),f,h,g);;){try{const e=await l.getSafeTxDetails(f);if(e.transactionHash){var p;await(null===(p=a.provider)||void 0===p?void 0:p.waitForTransaction(e.transactionHash));break}}catch(w){}await new Promise((e=>setTimeout(e,5e3)))}return"0x"},this.previousConnector=e.personalWallet,b}async disconnect(){this.safeSigner=void 0,this.previousConnector=void 0}async getAddress(){const e=await this.getSigner();return await e.getAddress()}async getChainId(){return(await this.getSigner()).getChainId()}async getProvider(){const e=(await this.getSigner()).provider;if(!e)throw new Error("No provider available");return e}async getSigner(){if(!this.safeSigner)throw new Error("not connected - please call connect() first");return this.safeSigner}async isConnected(){try{return!!await this.getAddress()}catch(e){return!1}}onAccountsChanged(e){0===e.length?this.emit("disconnect"):e[0]&&this.emit("change",{account:d.getAddress(e[0])})}onDisconnect(){this.emit("disconnect")}switchChain(){throw new Error("Safe connector does not support switching chains")}updateChains(){}async setupListeners(){}}(0,n._)(A,"supportedChains",(()=>Object.keys(p.C))())},79100:()=>{},93656:()=>{},46056:()=>{}}]);
//# sourceMappingURL=3812.44895bf5.chunk.js.map