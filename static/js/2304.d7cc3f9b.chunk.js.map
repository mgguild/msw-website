{"version":3,"file":"static/js/2304.d7cc3f9b.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-4e44ea9c.browser.esm.js","../node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-0b9abb2d.browser.esm.js","../node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/sdk/dist/signature-ccc18f2f.browser.esm.js"],"sourcesContent":["import { BigNumber } from 'ethers';\nimport { z } from 'zod';\nimport { x as ExtensionNotImplementedError } from './index-b91bd093.browser.esm.js';\n\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace - The namespace to check\n * @param feature - The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\nexport { EndDateSchema as E, RawDateSchema as R, StartDateSchema as S, assertEnabled as a };\n","import { cw as BigNumberTransformSchema, cx as FileOrBufferOrStringSchema, cy as HexColor, cq as ContractWrapper } from './index-b91bd093.browser.esm.js';\nimport { z } from 'zod';\nimport { i as isNativeToken } from './fetchCurrencyValue-e91195b2.browser.esm.js';\n\nconst PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional().nullable())();\n\n/**\n * @internal\n */\nconst BasicNFTInput = /* @__PURE__ */(() => z.object({\n  name: z.union([z.string(), z.number()]).optional().nullable(),\n  description: z.string().nullable().optional().nullable(),\n  image: FileOrBufferOrStringSchema.nullable().optional(),\n  animation_url: FileOrBufferOrStringSchema.optional().nullable()\n}))();\n\n/**\n * @internal\n */\nconst CommonNFTInput = /* @__PURE__ */(() => BasicNFTInput.extend({\n  external_url: FileOrBufferOrStringSchema.nullable().optional(),\n  background_color: HexColor.optional().nullable(),\n  properties: OptionalPropertiesInput,\n  attributes: OptionalPropertiesInput\n}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst NFTInputOrUriSchema = /* @__PURE__ */(() => z.union([CommonNFTInput, z.string()]))();\n\n/**\n * @internal\n */\nconst CommonNFTOutput = /* @__PURE__ */(() => CommonNFTInput.extend({\n  id: z.string(),\n  uri: z.string(),\n  image: z.string().nullable().optional(),\n  external_url: z.string().nullable().optional(),\n  animation_url: z.string().nullable().optional()\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @internal\n */\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\nexport { BasicNFTInput as B, CommonNFTOutput as C, NFTInputOrUriSchema as N, CommonNFTInput as a, setErc20Allowance as s };\n","import { constants, utils, BigNumber } from 'ethers';\nimport { bK as SnapshotInputSchema, bL as SnapshotEntryWithProofSchema, bM as SnapshotSchema, cq as ContractWrapper, b5 as BigNumberSchema, aV as NATIVE_TOKEN_ADDRESS, cv as AmountSchema, cz as QuantitySchema, b6 as BigNumberishSchema, cA as BytesLikeSchema, s as DuplicateLeafsError, b9 as AddressOrEnsSchema, b8 as AddressSchema, cB as BasisPointsSchema } from './index-b91bd093.browser.esm.js';\nimport { f as fetchCurrencyMetadata, i as isNativeToken, a as fetchCurrencyValue } from './fetchCurrencyValue-e91195b2.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-ce7058bf.browser.esm.js';\nimport { MerkleTree } from '@thirdweb-dev/merkletree';\nimport { S as StartDateSchema, E as EndDateSchema } from './assertEnabled-4e44ea9c.browser.esm.js';\nimport { z } from 'zod';\nimport { N as NFTInputOrUriSchema } from './setErc20Allowance-0b9abb2d.browser.esm.js';\nimport { v4 } from 'uuid';\n\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\n\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\n\n/**\n * @internal\n * @param quantity - The quantity to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return constants.MaxUint256;\n  } else {\n    return utils.parseUnits(quantity, tokenDecimals);\n  }\n}\n\nasync function parseSnapshotInputs(inputs) {\n  const chunkSize = 25000;\n  const chunks = Array.from({\n    length: Math.ceil(inputs.length / chunkSize)\n  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));\n  const results = [];\n  const parsedChunks = await Promise.all(chunks.map(chunk => SnapshotInputSchema.parseAsync(chunk)));\n  for (const chunk of parsedChunks) {\n    results.push(...chunk);\n  }\n  return results;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion = /*#__PURE__*/function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n  return SnapshotFormatVersion;\n}({}); // address, maxClaimable, price, currencyAddress\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = await parseSnapshotInputs(snapshotInput);\n\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new MerkleTree(Object.values(roots), utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        const uri = this.baseUri.endsWith(\"/\") ? this.baseUri : `${this.baseUri}/`;\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${uri}${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new MerkleTree(hashedEntries, utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parseAsync({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\n\n/**\n * @internal\n */\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = await SnapshotSchema.parseAsync(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\n\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\n\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\n/**\n * @internal\n */\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns  `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? constants.MaxUint256 : utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = BigNumber.from(pricePerToken).mul(quantity).div(utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * @internal\n */\nconst CurrencySchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  symbol: z.string(),\n  decimals: z.number()\n}))();\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = /* @__PURE__ */(() => CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: z.string()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = /* @__PURE__ */(() => z.object({\n  name: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = /* @__PURE__ */(() => z.object({\n  startTime: StartDateSchema,\n  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: AmountSchema.default(0),\n  maxClaimableSupply: QuantitySchema,\n  maxClaimablePerWallet: QuantitySchema,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([0], 32)),\n  snapshot: z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = /* @__PURE__ */(() => z.array(ClaimConditionInputSchema))();\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.partial())();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.extend({\n  availableSupply: QuantitySchema,\n  currentMintSupply: QuantitySchema,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n}))();\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider - the provider to use\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion - the snapshot format version\n * @returns The generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = await parseSnapshotInputs(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\n\nfunction compare(a, b) {\n  const left = BigNumber.from(a);\n  const right = BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c - The condition input\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot - The merkle root to fetch the snapshot for\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = await SnapshotSchema.parseAsync(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param bn - The big number to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm - The contract model to transform\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n * @param shouldDownloadSnapshot - Whether to download the snapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parseAsync({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param index - The index of the condition to update\n * @param claimConditionInput - The input claim condition to update\n * @param existingConditions - The existing claim conditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\nlet ClaimEligibility = /*#__PURE__*/function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"ClaimPhaseNotStarted\"] = \"Claim phase has not started yet.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"WrongPriceOrCurrency\"] = \"Incorrect price or currency.\";\n  ClaimEligibility[\"OverMaxClaimablePerWallet\"] = \"Cannot claim more than maximum allowed quantity.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n  return ClaimEligibility;\n}({});\n\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    v4({}, buffer);\n    return utils.hexlify(utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = /* @__PURE__ */(() => z.object({\n  to: AddressOrEnsSchema.refine(address => address.toLowerCase() !== constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: AmountSchema.default(0),\n  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  quantity: AmountSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = /* @__PURE__ */(() => Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  metadata: NFTInputOrUriSchema,\n  royaltyRecipient: z.string().default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0)\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  uri: z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = /* @__PURE__ */(() => Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\nexport { SnapshotFormatVersion as A, BaseSignaturePayloadInput as B, ClaimEligibility as C, processClaimConditionInputs as D, abstractContractModelToLegacy as E, abstractContractModelToNew as F, GenericRequest as G, updateExistingClaimConditions as H, resolveOrGenerateId as I, MintRequest20 as M, PartialClaimConditionInputSchema as P, Signature20PayloadInput as S, approveErc20Allowance as a, createSnapshot as b, convertToReadableQuantity as c, ClaimConditionMetadataSchema as d, ClaimConditionInputSchema as e, fetchSnapshotEntryForAddress as f, ClaimConditionInputArray as g, ClaimConditionOutputSchema as h, CurrencySchema as i, CurrencyValueSchema as j, Signature20PayloadOutput as k, Signature721PayloadInput as l, Signature721PayloadOutput as m, Signature1155PayloadInput as n, Signature1155PayloadInputWithTokenId as o, Signature1155PayloadOutput as p, Signature721WithQuantityInput as q, Signature721WithQuantityOutput as r, MintRequest721 as s, MintRequest1155 as t, MintRequest721withQuantity as u, transformResultToClaimCondition as v, legacyContractModelToAbstract as w, newContractModelToAbstract as x, convertQuantityToBigNumber as y, prepareClaim as z };\n"],"names":["RawDateSchema","z","union","date","transform","i","BigNumber","from","Math","floor","getTime","number","StartDateSchema","default","Date","EndDateSchema","now","assertEnabled","namespace","feature","ExtensionNotImplementedError","PropertiesInput","object","catchall","BigNumberTransformSchema","unknown","OptionalPropertiesInput","array","optional","nullable","BasicNFTInput","name","string","description","image","FileOrBufferOrStringSchema","animation_url","CommonNFTInput","extend","external_url","background_color","HexColor","properties","attributes","NFTInputOrUriSchema","CommonNFTOutput","id","uri","async","setErc20Allowance","contractToApprove","value","currencyAddress","overrides","isNativeToken","ERC20Abi","signer","getSigner","provider","getProvider","erc20","ContractWrapper","options","storage","owner","getSignerAddress","spender","address","read","lt","sendTransaction","abstractContractModelToLegacy","model","startTimestamp","maxClaimableSupply","supplyClaimed","merkleRoot","pricePerToken","currency","quantityLimitPerTransaction","maxClaimablePerWallet","waitTimeInSecondsBetweenClaims","abstractContractModelToNew","quantityLimitPerWallet","metadata","convertQuantityToBigNumber","quantity","tokenDecimals","constants","utils","parseSnapshotInputs","inputs","chunkSize","chunks","Array","length","ceil","_","slice","results","parsedChunks","Promise","all","map","chunk","SnapshotInputSchema","parseAsync","push","SnapshotFormatVersion","ShardedMerkleTree","constructor","baseUri","originalEntriesUri","shardNybbles","this","shards","trees","fromUri","shardedMerkleTreeInfo","downloadJSON","isShardedMerkleTree","fromShardedMerkleTreeInfo","e","info","hashEntry","entry","currencyDecimals","snapshotFormatVersion","V1","maxClaimable","V2","price","fetchAndCacheDecimals","cache","undefined","fetchCurrencyMetadata","decimals","buildAndUpload","snapshotInput","arguments","snapshotEntry","shard","toLowerCase","currencyDecimalMap","subTrees","Object","entries","_ref","MerkleTree","sort","getHexRoot","roots","fromEntries","tree","values","shardsToUpload","shardId","data","proofs","getProof","toString","JSON","stringify","concat","uris","uploadBatch","lastIndexOf","upload","shardedMerkleInfo","endsWith","hashedEntries","find","leaf","proof","SnapshotEntryWithProofSchema","getAllEntries","console","warn","fetchSnapshotEntryForAddress","merkleMetadata","snapshotUri","raw","merkleTree","snapshotData","SnapshotSchema","claims","c","legacyContractModelToAbstract","newContractModelToAbstract","approveErc20Allowance","allowance","totalPrice","mul","div","add","prepareClaim","addressToClaim","activeClaimCondition","merkleMetadataFetcher","contractWrapper","checkERC20Allowance","priceInProof","currencyAddressInProof","merkleRootHash","startsWith","normalizePriceValue","Error","message","getCallOverrides","gt","CurrencySchema","symbol","CurrencyValueSchema","BigNumberSchema","displayValue","ClaimConditionMetadataSchema","ClaimConditionInputSchema","startTime","NATIVE_TOKEN_ADDRESS","AmountSchema","QuantitySchema","waitInSeconds","BigNumberishSchema","BytesLikeSchema","snapshot","ClaimConditionInputArray","ClaimConditionOutputSchema","availableSupply","currentMintSupply","currencyMetadata","n","toNumber","processSnapshotData","claimConditionInputs","snapshotInfos","inputsWithSnapshots","conditionInput","snapshotInfo","input","addresses","Set","size","DuplicateLeafsError","createSnapshot","processClaimConditionInputs","parsedInputs","sortedConditions","metadataOrUri","convertToContractModel","a","b","left","right","eq","compare","fetchSnapshot","smt","claim","convertToReadableQuantity","bn","transformResultToClaimCondition","pm","shouldDownloadSnapshot","_pm$waitTimeInSeconds","cv","fetchCurrencyValue","sub","resolvedMetadata","updateExistingClaimConditions","index","claimConditionInput","existingConditions","priceDecimals","priceInWei","priceInTokens","newConditionParsed","mergedConditionOutput","existingOutput","newConditionAtIndex","formattedPrice","ClaimEligibility","resolveOrGenerateId","requestUId","buffer","Buffer","alloc","v4","BaseSignaturePayloadInput","to","AddressOrEnsSchema","refine","AddressSchema","mintStartTime","mintEndTime","uid","arg","primarySaleRecipient","Signature20PayloadInput","Signature20PayloadOutput","Signature721PayloadInput","royaltyRecipient","royaltyBps","BasisPointsSchema","Signature721PayloadOutput","Signature1155PayloadInput","Signature1155PayloadInputWithTokenId","tokenId","Signature1155PayloadOutput","Signature721WithQuantityInput","Signature721WithQuantityOutput","MintRequest20","type","MintRequest721","MintRequest1155","MintRequest721withQuantity"],"sourceRoot":""}