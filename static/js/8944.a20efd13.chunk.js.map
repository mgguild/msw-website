{"version":3,"file":"static/js/8944.a20efd13.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js","../node_modules/buffer-reverse/index.js","../node_modules/treeify/treeify.js"],"sourcesContent":["import { Buffer } from 'buffer';\nimport reverse from 'buffer-reverse';\nimport { asTree } from 'treeify';\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n  bufferIndexOf(array, element) {\n    let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (isSorted) {\n      return this.binarySearch(array, element, Buffer.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n    return this.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) {\n            continue;\n          }\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  binarySearch(array, element, compareFunction) {\n    return Base.binarySearch(array, element, compareFunction);\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  linearSearch(array, element, eqChecker) {\n    return Base.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n  static bufferify(value) {\n    if (!Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === \"object\" && value.words) {\n        return Buffer.from(value.toString(convertWordsToBuffer), \"hex\");\n      } else if (Base.isHexString(value)) {\n        return Buffer.from(value.replace(/^0x/, \"\"), \"hex\");\n      } else if (typeof value === \"string\") {\n        return Buffer.from(value);\n      } else if (typeof value === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      } else if (value instanceof Uint8Array) {\n        return Buffer.from(value.buffer);\n      } else if (typeof value === \"number\") {\n        let s = value.toString();\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n        return Buffer.from(s, \"hex\");\n      } else if (ArrayBuffer.isView(value)) {\n        return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n    return value;\n  }\n  bigNumberify(value) {\n    return Base.bigNumberify(value);\n  }\n  static bigNumberify(value) {\n    if (typeof value === \"bigint\") {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      if (value.startsWith(\"0x\") && Base.isHexString(value)) {\n        return BigInt(\"0x\" + value.replace(\"0x\", \"\").toString());\n      }\n      return BigInt(value);\n    }\n    if (Buffer.isBuffer(value)) {\n      return BigInt(\"0x\" + value.toString(\"hex\"));\n    }\n    if (value instanceof Uint8Array) {\n      return uint8ArrayToBigInt(value);\n    }\n    if (typeof value === \"number\") {\n      return BigInt(value);\n    }\n    throw new Error(\"cannot bigNumberify\");\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  static isHexString(v) {\n    return typeof v === \"string\" && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n  static print(tree) {\n    console.log(tree.toString());\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? \"0x\" : \"\"}${(value || Buffer.alloc(0)).toString(\"hex\")}`;\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n      if (Buffer.isBuffer(v)) {\n        return v;\n      }\n      if (this.isHexString(v)) {\n        return Buffer.from(v.replace(\"0x\", \"\"), \"hex\");\n      }\n      if (typeof v === \"string\") {\n        return Buffer.from(v);\n      }\n      if (typeof v === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      }\n      if (ArrayBuffer.isView(v)) {\n        return Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      }\n\n      // crypto-js support\n      const arrayBuffer = hexStringToArrayBuffer(value.toString(\"hex\"));\n      // Assuming f now works with ArrayBuffers\n      const processedBuffer = f(arrayBuffer);\n      const hexResult = arrayBufferToHexString(processedBuffer);\n      return Buffer.from(hexResult, \"hex\");\n    };\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  isHexString(value) {\n    return Base.isHexString(value);\n  }\n\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n  log2(n) {\n    return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n  }\n\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n  zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n  static hexZeroPad(hexStr, length) {\n    return \"0x\" + hexStr.replace(\"0x\", \"\").padStart(length, \"0\");\n  }\n}\nvar Base$1 = Base;\n\n// UTILS\n\n// replaces CryptoJS.enc.Hex\nfunction convertWordsToBuffer(value) {\n  const wordArray = value.words;\n  const arrayBuffer = new ArrayBuffer(wordArray.length * 4); // 4 bytes per word\n  const uint8View = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < wordArray.length; i++) {\n    uint8View[i * 4] = wordArray[i] >> 24 & 0xff;\n    uint8View[i * 4 + 1] = wordArray[i] >> 16 & 0xff;\n    uint8View[i * 4 + 2] = wordArray[i] >> 8 & 0xff;\n    uint8View[i * 4 + 3] = wordArray[i] & 0xff;\n  }\n  return arrayBuffer;\n}\nfunction hexStringToArrayBuffer(hexString) {\n  const buffer = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < hexString.length; i += 2) {\n    buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n  return buffer.buffer;\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n  const uint8View = new Uint8Array(arrayBuffer);\n  return Array.from(uint8View).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction uint8ArrayToBigInt(u8a) {\n  const hex = Array.from(u8a).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  return BigInt(`0x${hex}`);\n}\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\n\n// TODO: Clean up and DRY up code\n// Disclaimer: The multiproof code is unaudited and may possibly contain serious issues. It's in a hacky state as is and needs to be rewritten.\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base$1 {\n  duplicateOdd = false;\n  concatenator = Buffer.concat;\n  hashLeaves = false;\n  isBitcoinTree = false;\n  leaves = [];\n  layers = [];\n  sortLeaves = false;\n  sortPairs = false;\n  sort = false;\n  fillDefaultHash = null;\n  complete = false;\n\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves, hashFn) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (options.complete) {\n      if (options.isBitcoinTree) {\n        throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n      }\n      if (options.duplicateOdd) {\n        throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n      }\n    }\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.complete = !!options.complete;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === \"function\") {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === \"string\") {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    this.sort = !!options.sort;\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n    this.duplicateOdd = !!options.duplicateOdd;\n    if (options.concatenator) {\n      this.concatenator = options.concatenator;\n    }\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    return {\n      complete: this.complete,\n      isBitcoinTree: this.isBitcoinTree,\n      hashLeaves: this.hashLeaves,\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs,\n      sort: this.sort,\n      fillDefaultHash: this.fillDefaultHash?.toString() ?? null,\n      duplicateOdd: this.duplicateOdd\n    };\n  }\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.leaves = leaves.map(this.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Buffer.compare);\n    }\n    if (this.fillDefaultHash) {\n      for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n      }\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            const data = nodes[nodes.length - 1];\n            let hash = data;\n\n            // is bitcoin tree\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              hash = this.hashFn(this.concatenator([reverse(data), reverse(data)]));\n              hash = reverse(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) ; else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let combined = null;\n        if (this.isBitcoinTree) {\n          combined = [reverse(left), reverse(right)];\n        } else {\n          combined = [left, right];\n        }\n        if (this.sortPairs) {\n          combined.sort(Buffer.compare);\n        }\n        let hash = this.hashFn(this.concatenator(combined));\n\n        // double hash if bitcoin tree\n        if (this.isBitcoinTree) {\n          hash = reverse(this.hashFn(hash));\n        }\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n        if (this.sortLeaves) {\n          values = values.sort(Buffer.compare);\n        }\n      }\n      return this.leaves.filter(\n      // @ts-expect-error - issue from original code\n      leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n    }\n    return this.leaves;\n  }\n\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return Buffer.from([]);\n    }\n    return this.leaves[index];\n  }\n\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n  getLeafCount() {\n    return this.leaves.length;\n  }\n\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n    if (typeof jsonStr === \"string\") {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error(\"Expected type of string or object\");\n    }\n    if (!parsed) {\n      return [];\n    }\n    if (!Array.isArray(parsed)) {\n      throw new Error(\"Expected JSON string to be array\");\n    }\n    return parsed.map(MerkleTree.bufferify);\n  }\n\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[][]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n  getLayers() {\n    return this.layers;\n  }\n\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[][]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n  }\n\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n      return acc;\n    }, []);\n    layers.unshift(Buffer.from([0]));\n    return layers;\n  }\n\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n  getRoot() {\n    if (this.layers.length === 0) {\n      return Buffer.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n  }\n\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n  getProof(leaf, index) {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    leaf = this.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ?\n      // @ts-expect-error - issue from original code\n      index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ?\n      // Proof Generation for Bitcoin Trees\n      index :\n      // Proof Generation for Non-Bitcoin Trees\n      // @ts-expect-error - issue from original code\n      index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex]\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = index / 2 | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getProofs\n   * @desc Returns the proofs for all leaves.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n   * @example\n   * ```js\n   *const proofs = tree.getProofs()\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proofs = tree.getProofs()\n   *```\n   */\n  getProofs() {\n    // @ts-expect-error - issue from original code\n    const proof = [];\n    // @ts-expect-error - issue from original code\n    const proofs = [];\n\n    // @ts-expect-error - issue from original code\n    this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n\n    // @ts-expect-error - issue from original code\n    return proofs;\n  }\n\n  /**\n   * getProofsDFS\n   * @desc Get all proofs through single traverse\n   * @param {Number} currentLayer - Current layer index in traverse.\n   * @param {Number} index - Current tarvese node index in traverse.\n   * @param {Object[]} proof - Proof chain for single leaf.\n   * @param {Object[]} proofs - Proofs for all leaves\n   * @example\n   * ```js\n   *const layers = tree.getLayers()\n   *const index = 0;\n   *let proof = [];\n   *let proofs = [];\n   *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n   *```\n   */\n  // @ts-expect-error - issue from original code\n  getProofsDFS(currentLayer, index, proof, proofs) {\n    const isRightNode = index % 2;\n    if (currentLayer === -1) {\n      if (!isRightNode) {\n        proofs.push([...proof].reverse());\n      }\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    if (index >= this.layers[currentLayer].length) {\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    const layer = this.layers[currentLayer];\n    const pairIndex = isRightNode ? index - 1 : index + 1;\n    let pushed = false;\n    if (pairIndex < layer.length) {\n      pushed = true;\n      proof.push({\n        position: isRightNode ? \"left\" : \"right\",\n        data: layer[pairIndex]\n      });\n    }\n    const leftchildIndex = index * 2;\n    const rightchildIndex = index * 2 + 1;\n    this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n    this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n    if (pushed) {\n      proof.splice(proof.length - 1, 1);\n    }\n  }\n\n  /**\n   * getHexProofs\n   * @desc Returns the proofs for all leaves as hex strings.\n   * @return {String[]} - Proofs array as hex strings.\n   * @example\n   * ```js\n   *const proofs = tree.getHexProofs()\n   *```\n   */\n  getHexProofs() {\n    return this.getProofs().map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getPositionalHexProof\n   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n   * @example\n   * ```js\n   *const proof = tree.getPositionalHexProof(leaves[2])\n   *```\n   */\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === \"left\" ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n  getProofIndices(treeIndices, depth) {\n    const leafCount = 2 ** depth;\n    let maximalIndices = new Set();\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((x, y) => x - y).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) {\n            break;\n          }\n          index = index / 2 | 0;\n        }\n      }\n    }\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n    }\n    return proofIndices;\n  }\n\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n  getMultiProof(tree, indices) {\n    if (!this.complete) {\n      console.warn(\"Warning: For correct multiProofs it's strongly recommended to set complete: true\");\n    }\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // @ts-expect-error - issue from original code\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n    // @ts-expect-error - issue from original code\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n      if (this.sortPairs) {\n        // @ts-expect-error - issue from original code\n        els = els.sort(Buffer.compare);\n      }\n\n      // @ts-expect-error - issue from original code\n      let ids = els.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error(\"Element does not exist in Merkle tree\");\n      }\n\n      // @ts-expect-error - issue from original code\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n          const pairElement = this.getPairNode(layer, idx);\n          hashes.push(layer[idx]);\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n          nextIds.push(idx / 2 | 0);\n        }\n        ids = nextIds.filter((value, j, self) => self.indexOf(value) === j);\n        nextIds = [];\n      }\n\n      // @ts-expect-error - issue from original code\n      return proof.filter(value => !hashes.includes(value));\n    }\n\n    // @ts-expect-error - issue from original code\n    return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(\n    // @ts-expect-error - issue from original code\n    index => tree[index]);\n  }\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n    let proofHashes = [];\n    // @ts-expect-error - issue from original code\n    let currentLayerIndices = indices;\n    // @ts-expect-error - issue from original code\n    for (const treeLayer of tree) {\n      const siblings = [];\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n        const idx = index - 1;\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n        uniqueIndices.add((index - 1) / 2);\n      }\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n    return proofHashes;\n  }\n\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error(\"Invalid Inputs!\");\n    }\n    let ids;\n    if (leaves.every(Number.isInteger)) {\n      ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error(\"Element does not exist in Merkle tree\");\n    }\n    const _proofs = proofs.map(item => this.bufferify(item));\n\n    // @ts-expect-error - issue from original code\n    const tested = [];\n    // @ts-expect-error - issue from original code\n    const flags = [];\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids_, idx) => {\n        // @ts-expect-error - issue from original code\n        const skipped = tested.includes(layer[idx]);\n        if (!skipped) {\n          const pairElement = this.getPairNode(layer, idx);\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n          // eslint-disable-next-line no-unused-expressions\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n        // @ts-expect-error - issue from original code\n        ids_.push(idx / 2 | 0);\n        return ids_;\n      }, []);\n    }\n\n    // @ts-expect-error - issue from original code\n    return flags;\n  }\n\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null;\n\n      // case for when proof is hex values only\n      if (typeof node === \"string\") {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === \"left\";\n      } else {\n        throw new Error(\"Expected node to be of type string or object\");\n      }\n      const buffers = [];\n      if (this.isBitcoinTree) {\n        buffers.push(reverse(hash));\n        buffers[isLeftNode ? \"unshift\" : \"push\"](reverse(data));\n        hash = this.hashFn(this.concatenator(buffers));\n        hash = reverse(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(this.concatenator(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(this.concatenator(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? \"unshift\" : \"push\"](data);\n          hash = this.hashFn(this.concatenator(buffers));\n        }\n      }\n    }\n    return Buffer.compare(hash, root) === 0;\n  }\n\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n    for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n      // @ts-expect-error - issue from original code\n      tree[2 ** depth + index] = leaf;\n    }\n    for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n      // @ts-expect-error - issue from original code\n      tree[index] = proofitem;\n    }\n    let indexqueue = Object.keys(tree).map(value => Number(value)).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        // @ts-expect-error - issue from original code\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n        if (this.sortPairs) {\n          pair = pair.sort(Buffer.compare);\n        }\n        const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n        // @ts-expect-error - issue from original code\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n      i += 1;\n    }\n    return !proofIndices.length ||\n    // @ts-expect-error - issue from original code\n    {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(Buffer.compare);\n      hashes[i] = this.hashFn(this.concatenator(buffers));\n    }\n    return Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n        if (objs.length) {\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          // @ts-expect-error - issue from original code\n          const akey = Object.keys(a)[0];\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]][akey] = a[akey];\n          if (objs.length) {\n            const b = objs.shift();\n            // @ts-expect-error - issue from original code\n            const bkey = Object.keys(b)[0];\n            // @ts-expect-error - issue from original code\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n        arr.push(obj);\n      }\n      objs.push(...arr);\n    }\n    return objs[0];\n  }\n\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n  getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      // @ts-expect-error - issue from original code\n      return null;\n    }\n  }\n\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n  toTreeString() {\n    const obj = this.getLayersAsObject();\n    return asTree(obj, true, false);\n  }\n\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n  toString() {\n    return this.toTreeString();\n  }\n  isUnevenTree(treeLayers) {\n    const depth = treeLayers?.length || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n    const tree = [leafTuples];\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex])\n      // @ts-expect-error - issue from original code\n      .sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      })\n      // @ts-expect-error - issue from original code\n      .map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex_] = _ref8;\n        return layerIndex_;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n      tree.push(parentLayer);\n    }\n    return tree[tree.length - 1][0][1];\n  }\n}\n\nexport { MerkleTree };\n","module.exports = function reverse (src) {\n  var buffer = new Buffer(src.length)\n\n  for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n","//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '' : '');\n    if (key) {\n      str += ' ';\n    } else {\n      str += '';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"],"names":["Base","print","this","bufferIndexOf","array","element","arguments","length","undefined","binarySearch","Buffer","compare","linearSearch","eqChecker","buffer1","buffer2","equals","compareFunction","start","end","mid","Math","floor","ordering","i","bufferify","value","isBuffer","words","from","toString","convertWordsToBuffer","isHexString","replace","Uint8Array","buffer","s","concat","ArrayBuffer","isView","byteOffset","byteLength","bigNumberify","startsWith","BigInt","u8a","hex","Array","map","byte","padStart","join","uint8ArrayToBigInt","Error","v","test","tree","console","log","bufferToHex","withPrefix","alloc","bufferifyFn","f","arrayBuffer","hexString","parseInt","substring","hexStringToArrayBuffer","hexResult","uint8View","arrayBufferToHexString","log2","n","zip","a","b","e","hexZeroPad","hexStr","Base$1","wordArray","MerkleTree","constructor","leaves","hashFn","options","super","_defineProperty","complete","isBitcoinTree","duplicateOdd","hashLeaves","sortLeaves","sortPairs","fillDefaultHash","idx","sort","concatenator","processLeaves","getOptions","_this$fillDefaultHash","_this$fillDefaultHash2","pow","ceil","push","createHashes","nodes","layers","layerIndex","layerLimit","Number","isInteger","slice","data","hash","reverse","left","right","combined","addLeaf","leaf","addLeaves","getLeaves","values","isArray","filter","getLeaf","index","getLeafIndex","target","getLeafCount","getHexLeaves","marshalLeaves","JSON","stringify","unmarshalLeaves","jsonStr","parsed","parse","Object","getLayers","getHexLayers","reduce","acc","item","layer","getLayersFlat","unshift","getHexLayersFlat","getLayerCount","getRoot","getHexRoot","getProof","proof","isRightNode","pairIndex","position","getHexProof","getProofs","proofs","getProofsDFS","currentLayer","pushed","leftchildIndex","rightchildIndex","splice","getHexProofs","getPositionalHexProof","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","x","add","y","redundantIndices","has","includes","getProofIndicesForUnevenTree","sortedLeafIndices","leavesCount","unevenLayers","proofIndices","layerNodes","proofNodeIndices","unevenLayer","find","_ref","getMultiProof","indices","warn","isUnevenTree","every","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","j","pairElement","getPairNode","self","indexOf","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getHexMultiProof","getProofFlags","_proofs","tested","flags","ids_","proofUsed","verify","targetNode","root","node","isLeftNode","buffers","verifyMultiProof","proofLeaves","verifyMultiProofForUnevenTree","proofitem","indexqueue","keys","hasOwnProperty","call","pair","verifyMultiProofWithFlags","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","computedRoot","calculateRootForUnevenTree","getDepth","getLayersAsObject","objs","arr","obj","shift","akey","bkey","resetTree","pairIdx","toTreeString","asTree","treeLayers","isPowOf2","leafIndices","leafHashes","totalLeavesCount","leafTuples","_ref2","_ref3","indexA","indexB","leafTupleIndices","_ref4","nextSliceStart","proofTuplesByLayers","sliceStart","_ref5","_ref6","_ref7","_ref8","layerIndex_","parentIndices","parentLayer","parentNodeTreeIndex","bufA","bufB","module","exports","src","makePrefix","key","last","str","filterKeys","hideFunctions","branch","growBranch","lastStates","showValues","callback","lastKey","circular","line","lastStatesCopy","forEach","lastState","Date","Treeify","lineCallback","factory"],"sourceRoot":""}