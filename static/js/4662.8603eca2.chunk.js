"use strict";(self.webpackChunkMetaSaga_Warriors=self.webpackChunkMetaSaga_Warriors||[]).push([[4662],{55176:(t,e,a)=>{a.d(e,{a:()=>u,b:()=>l,c:()=>p,d:()=>y,g:()=>h});var r=a(21204),i=a(1824),n=a(53796),s=a(60852),o=a(3628),c=a(86412);function d(t){return"("+t.map((t=>"tuple"===t.type?d(t.components):"tuple[]"===t.type?d(t.components)+"[]":t.type)).join(",")+")"}function l(t){const e=new i.k$(t),a=[];for(const r of Object.values(e.functions)){const t=e.getFunction(e.getSighash(r));t.name.startsWith("_")||a.push({functionSelector:e.getSighash(t),functionSignature:t.name+d(t.inputs)})}return a}async function h(t,e,a,n,s,o){r.dy.deploymentPresets={};const[h,{compilerMetadata:p,extendedMetadata:u}]=await Promise.all([n||(0,r.ax)(a),(0,r.aJ)(t,e)]),y={},g=[],m=null===u||void 0===u?void 0:u.defaultExtensions;if("plugin"===(null===u||void 0===u?void 0:u.routerType)&&m){(0,c.c)(s||o,"Require Client Id / Secret Key");const t=await Promise.all(m.map((t=>(0,r.aI)(t.publisherAddress,t.extensionName,t.extensionVersion,e,s,o)))),n=(await Promise.all(t.map((t=>(0,r.aJ)(t.metadataUri,e))))).map((t=>t.compilerMetadata)),l=await Promise.all(n.map((t=>(0,r.aE)("plugin",a,e,h,{metadata:t},s,o)))),p=[];n.forEach(((t,e)=>{const a=function(t,e){const a=new i.k$(e),r=[];for(const i of Object.values(a.functions)){const e=a.getFunction(a.getSighash(i));e.name.includes("_")||r.push({functionSelector:a.getSighash(e),functionSignature:e.name+d(e.inputs),pluginAddress:t})}return r}(l[e].transaction.predictedAddress,t.abi);p.push(...a)}));const u=await(0,r.aE)("plugin",a,e,h,{contractName:"PluginMap",constructorParams:{_pluginsToAdd:{value:p}}},s,o);y._pluginMap={value:u.transaction.predictedAddress},g.push(...l,u)}else if("dynamic"===(null===u||void 0===u?void 0:u.routerType)&&m){(0,c.c)(s||o,"Require Client Id / Secret Key");const t=await Promise.all(m.map((t=>(0,r.aI)(t.publisherAddress,t.extensionName,t.extensionVersion,e,s,o)))),i=(await Promise.all(t.map((async t=>(0,r.aJ)(t.metadataUri,e))))).map((t=>t.compilerMetadata)),n=await Promise.all(i.map((t=>(0,r.aE)("extension",a,e,h,{metadata:t},s,o)))),d=[];i.forEach(((t,e)=>{const a=l(t.abi);d.push({metadata:{name:t.name,metadataURI:"",implementation:n[e].transaction.predictedAddress},functions:a})})),y._extensions={value:d},g.push(...n)}const[w,f]=await Promise.all([(0,r.aE)("implementation",a,e,h,{metadata:p,constructorParams:y},s,o),(0,r.aE)("infra",a,e,h,{contractName:"TWCloneFactory"},s,o)]);return g.push(f),g.push(...Object.values(r.dy.deploymentPresets)),g.push(w),g}function p(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r.as;if(0===(t=t.filter((t=>t.data.length>0))).length)return[];const a=[];let i=0,s=[];return t.forEach((t=>{const r=function(t){let e=n.arrayify(t).map((t=>0===t?4:16)).reduce(((t,e)=>t+e))+200*t.length/2+6*Math.ceil(t.length/64)+32e3+21e3;return e=Math.floor(64*e/63),e}(t.data);i+r>e?0===s.length?a.push([t]):(a.push(s),i=r,s=[t]):(i+=r,s.push(t))})),s.length>0&&a.push(s),a}async function u(t,e,a){var i,n;const o=p(e);if(0===o.length)return;null===a||void 0===a||null===(i=a.notifier)||void 0===i||i.call(a,"deploying","infra");const c=await Promise.all(o.map((e=>new s.uY(r.au,r.at).connect(t).deploy(e))));await Promise.all(c.map((t=>t.deployed()))),null===a||void 0===a||null===(n=a.notifier)||void 0===n||n.call(a,"deployed","infra")}async function y(t,e,a){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:7e6;(0,c.c)(t.provider,"Provider required");if(!await(0,r.av)(e.predictedAddress,t.provider)){var n,s;console.debug("deploying contract via create2 factory at: ".concat(e.predictedAddress));const r={to:e.to,data:e.data};try{await t.estimateGas(r)}catch(d){console.debug("error estimating gas while deploying prebuilt: ",d),r.gasLimit=o.iC.from(i)}null===a||void 0===a||null===(n=a.notifier)||void 0===n||n.call(a,"deploying","preset"),await(await t.sendTransaction(r)).wait(),null===a||void 0===a||null===(s=a.notifier)||void 0===s||s.call(a,"deployed","preset")}}},7032:(t,e,a)=>{a.d(e,{g:()=>n,i:()=>i});var r=a(46948);function i(t){const e=new URL(t).hostname;return e.endsWith(".thirdweb.com")||e.endsWith(".thirdweb-dev.com")||"localhost"===e||"0.0.0.0"===e}function n(t){return(0,r.Pp2)(t).map((t=>{try{const e=new URL(t);return e.hostname.endsWith(".thirdweb.com")&&(e.pathname="",e.search=""),e.toString()}catch(e){return t}}))}},34662:(t,e,a)=>{a.d(e,{SmartWalletConnector:()=>Ot});var r=a(70252),i=a(63604),n=a(53796),s=a(93720),o=a(5148),c=a(3628),d=a(45248),l=a(75672),h=a(96736),p=a(15076),u=a(70036),y=a(9264),g=a(21088),m=a(7032),w=a(12895),f=a(90192),v=a(80584),b=a(15948),A=a(51416),P=a(94572),C=a(21204),T=a(13520),_=a(238),x=a(47644),I=a(86412);class D extends C.cp{constructor(t,e,a){super(t,e),(0,P.c)(this,"updatePublisherProfile",(0,A.d)((async t=>{const e=this.getSigner();(0,I.c)(e,"A signer is required");const a=await e.getAddress(),r=await this.storage.upload(t);return A.T.fromContractWrapper({contractWrapper:this.publisher,method:"setPublisherProfileUri",args:[a,r]})}))),(0,P.c)(this,"publish",(0,A.d)((async(t,e)=>{const a=this.cleanupOldPublishFlowData(e),r=this.getSigner();(0,I.c)(r,"A signer is required");const i=await r.getAddress(),n=await(0,C.a8)(t,this.storage),s=await(0,C.Y)(n.metadataUri,this.storage),o=(0,C.ah)(C.bj.parse(s.abi),"PluginRouter"),c=(0,C.ah)(C.bj.parse(s.abi),"DynamicContract");if(a.routerType=o?"plugin":c?"dynamic":"none",c||o){const t=a.defaultExtensions;if(t&&t.length>0)try{const e=(await Promise.all(t.map((t=>(0,C.aI)(t.publisherAddress,t.extensionName,t.extensionVersion,this.storage,this.options.clientId,this.options.secretKey))))).map((t=>t.metadataUri)),r=(await Promise.all(e.map((async t=>(0,C.aJ)(t,this.storage))))).map((t=>t.compilerMetadata.abi)),i=(0,C.aj)([s.abi,...r]);a.compositeAbi=C.bj.parse(i)}catch{}}const d=await this.getLatest(i,n.name);if(d&&d.metadataUri){const t=(await this.fetchPublishedContractInfo(d)).publishedMetadata.version;if(!(0,C.am)(t,a.version))throw Error("Version ".concat(a.version," is not greater than ").concat(t))}const l=await(await this.storage.download(n.bytecodeUri)).text(),h=l.startsWith("0x")?l:"0x".concat(l),u=x.keccak256(["bytes"],[h]),y=n.name,g=await C.bt.parseAsync({...a,metadataUri:n.metadataUri,bytecodeUri:n.bytecodeUri,name:n.name,analytics:n.analytics,publisher:i}),m=await this.storage.upload(g);return A.T.fromContractWrapper({contractWrapper:this.publisher,method:"publishContract",args:[i,y,m,n.metadataUri,u,p.e],parse:t=>{const e=this.publisher.parseLogs("ContractPublished",t.logs);if(e.length<1)throw new Error("No ContractPublished event found");const a=e[0].args.publishedContract;return{receipt:t,data:async()=>this.toPublishedContract(a)}}})}))),(0,P.c)(this,"unpublish",(0,A.d)((async(t,e)=>{const a=await(0,C.aL)(t);return A.T.fromContractWrapper({contractWrapper:this.publisher,method:"unpublishContract",args:[a,e]})}))),this.storage=a,this.publisher=new C.cq(t,(0,C.aQ)(),_,e,a)}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.publisher.updateSignerOrProvider(t)}async extractConstructorParams(t){return async function(t,e){const a=await(0,C.a9)(t,e);return(0,C.a1)(a.abi)}(t,this.storage)}async extractFunctions(t){return async function(t,e){const a=await(0,C.a9)(t,e);return(0,C.a2)(a.abi,a.metadata)}(t,this.storage)}async fetchCompilerMetadataFromPredeployURI(t){return(0,C.a9)(t,this.storage)}async fetchPrePublishMetadata(t,e){const a=await(0,C.a9)(t,this.storage),r=e?await this.getLatest(e,a.name):void 0;return{preDeployMetadata:a,latestPublishedContractMetadata:r?await this.fetchPublishedContractInfo(r):void 0}}async fetchCompilerMetadataFromAddress(t){const e=await(0,C.aL)(t);return(0,C.K)(e,this.getProvider(),this.storage,this.options)}async fetchPublishedContractInfo(t){return{name:t.id,publishedTimestamp:t.timestamp,publishedMetadata:await this.fetchFullPublishMetadata(t.metadataUri)}}async fetchFullPublishMetadata(t){return(0,C.aa)(t,this.storage)}async resolvePublishMetadataFromCompilerMetadata(t){const e=await this.publisher.read("getPublishedUriFromCompilerUri",[t]);if(0===e.length)throw Error("Could not resolve published metadata URI from ".concat(t));return await Promise.all(e.filter((t=>t.length>0)).map((t=>this.fetchFullPublishMetadata(t))))}async resolveContractUriFromAddress(t){const e=await(0,C.aL)(t),a=await(0,C.a4)(e,this.getProvider());return(0,I.c)(a,"Could not resolve contract URI from address"),a}async fetchContractSourcesFromAddress(t){const e=await(0,C.aL)(t),a=await this.fetchCompilerMetadataFromAddress(e);return await(0,C.ao)(a,this.storage)}async fetchContractAbiFromAddress(t){const e=await(0,C.aL)(t);return(await(0,C.K)(e,this.getProvider(),this.storage)).abi}async getPublisherProfile(t){const e=await(0,C.aL)(t),a=await this.publisher.read("getPublisherProfileUri",[e]);return a&&0!==a.length?C.bw.parse(await this.storage.downloadJSON(a)):{}}async getAll(t){const e=await(0,C.aL)(t),a=(await this.publisher.read("getAllPublishedContracts",[e])).reduce(((t,e)=>(t[e.contractId]=e,t)),{});return Object.entries(a).map((t=>{let[,e]=t;return this.toPublishedContract(e)}))}async getAllVersions(t,e){const a=await(0,C.aL)(t),r=await this.publisher.read("getPublishedContractVersions",[a,e]);if(0===r.length)throw Error("Not found");return r.map((t=>this.toPublishedContract(t)))}async getVersion(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest";const r=await(0,C.aL)(t);if("latest"===a)return this.getLatest(r,e);const i=await this.getAllVersions(r,e),n=(await Promise.all(i.map((t=>this.fetchPublishedContractInfo(t))))).find((t=>t.publishedMetadata.version===a));return(0,I.c)(n,"Contract version not found"),i.find((t=>t.timestamp===n.publishedTimestamp))}async getLatest(t,e){const a=await(0,C.aL)(t),r=await this.publisher.read("getPublishedContract",[a,e]);if(r&&r.publishMetadataUri)return this.toPublishedContract(r)}toPublishedContract(t){return C.bx.parse({id:t.contractId,timestamp:t.publishTimestamp,metadataUri:t.publishMetadataUri})}cleanupOldPublishFlowData(t){return t.compositeAbi&&delete t.compositeAbi,{...t,isDeployableViaFactory:!1,isDeployableViaProxy:!1,factoryDeploymentData:{...t.factoryDeploymentData,implementationAddresses:{},factoryAddresses:{}}}}}var F=a(71588),E=a(11248),S=a(1824),B=a(60852),O=a(38856),L=a(59500),k=a(99532),U=a(563),N=a(16056),G=a(55516),M=a(89032),R=a(83440),W=a(81639),V=a(46948),K=a(16175),H=a(55176),q=a(57048);let j=!1;async function J(t,e,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0;const s=(0,C.a_)(e,{clientId:i,secretKey:n}),o=await async function(t,e,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0;const s=(0,C.a_)(e,{clientId:i,secretKey:n}),o=(await(0,C.aI)(C.aH,t,r,a,i,n)).metadataUri,c=await(0,C.ax)(s);(0,I.c)(c,"Thirdweb stack not found");const{extendedMetadata:d}=await(0,C.aJ)(o,a);if("plugin"===(null===d||void 0===d?void 0:d.routerType)||"dynamic"===(null===d||void 0===d?void 0:d.routerType)){var l;const t=null===(l=(await(0,H.g)(o,a,s,c,i,n)).find((t=>"implementation"===t.type)))||void 0===l?void 0:l.transaction.predictedAddress;return(0,I.c)(t,"Error computing address for plugin router"),t}return(await(0,C.aE)("implementation",s,a,c,{contractName:t},i,n)).transaction.predictedAddress}(t,e,a,r,i,n),c=await(0,C.av)(o,s);return(0,I.c)(c,"Contract not deployed yet"),o}const z="Pending in queue",Y={OK:"1",NOTOK:"0"};async function Z(t,e,a,r,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"latest",s=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,c=arguments.length>8?arguments[8]:void 0;const d=await J(t,e,i,n,s,o),l=await async function(t,e,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0;const o=(0,C.a_)(e,{clientId:i,secretKey:n}),c=(await(0,C.aI)(C.aH,t,r,a,i,n)).metadataUri,d=await(0,C.aJ)(c,a),l=await(0,C.ax)(o);(0,I.c)(l,"Thirdweb stack not found");const{extendedMetadata:h}=await(0,C.aJ)(c,a);let p;var u;p="plugin"===(null===h||void 0===h?void 0:h.routerType)||"dynamic"===(null===h||void 0===h?void 0:h.routerType)?null===(u=(await(0,H.g)(c,a,o,l,i,n)).find((t=>"implementation"===t.type)))||void 0===u?void 0:u.encodedArgs:await(0,C.aF)(d.compilerMetadata,o,a,l,s,i,n);return p}(t,e,i,n,s,o,c);console.info("Verifying ".concat(t," at address ").concat(d));return await $(d,e,a,r,i,null===l||void 0===l?void 0:l.toString().replace("0x",""))}async function $(t,e,r,i,n,s){try{const c=(0,C.a_)(e,{});t=(await(0,C.a6)(t,c)).address;const d=await(0,C.K)(t,c,n),l=d.metadata.compiler.version,h=await(0,C.ao)(d,n),p=d.metadata.sources,u={};for(const t of Object.keys(p)){const e=h.find((e=>t===e.filename));if(!e)throw new Error("Could not find source file for ".concat(t));u[t]={content:e.source}}const y={language:"Solidity",sources:u,settings:{optimizer:d.metadata.settings.optimizer,evmVersion:d.metadata.settings.evmVersion,remappings:d.metadata.settings.remappings,outputSelection:{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"],"":["ast"]}}}},g=d.metadata.settings.compilationTarget,m=Object.keys(g)[0],w=s||await async function(t,e,r,i,n,s){const c=(0,C.a1)(i);if(0===c.length)return"";const d=await fetch("".concat(t,"?module=contract&action=getcontractcreation&contractaddresses=").concat(r,"&apikey=").concat(e)),l=await d.json();if(l&&l.status===Y.OK&&void 0!==l.result[0]){const t=new S.k$(i),e=l.result[0].txHash;let d="";if(0===t.deploy.inputs.length)return"";const u=await n.getTransaction(e),y=u.data;try{const t=await async function(t,e,r){const i=await(0,C.a4)(t,e);if(i){const t=(await Promise.resolve().then(a.t.bind(a,238,19))).default,e=new B.wn((0,C.aQ)(),t,(0,C.a_)("polygon",{})),n=await e.getPublishedUriFromCompilerUri(i);if(0===n.length)throw Error("Could not resolve published metadata URI from ".concat(i));const s=await Promise.all(n.filter((t=>t.length>0)).map((t=>(0,C.aa)(t,r))));return s.length>0?await(await r.download(s[0].bytecodeUri)).text():void 0}return}(r,n,s);if(t){const e=t.startsWith("0x")?t:"0x".concat(t);let a;try{a=await(0,C.ax)(n)}catch(h){}const r=u.to===a?64:0;d=y.substring(e.length+r)}}catch(p){}if(!d){const t=[...y.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];t.length>0&&(d=t[0][2])}if(!d){const t=64*c.length;d=y.substring(y.length-t)}try{o.s.decode(t.deploy.inputs,"0x".concat(d))}catch(p){throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.")}return d}return""}(r,i,t,d.abi,c,n),f={apikey:i,module:"contract",action:"verifysourcecode",contractaddress:t,sourceCode:JSON.stringify(y),codeformat:"solidity-standard-json-input",contractname:"".concat(m,":").concat(d.name),compilerversion:"v".concat(l),constructorArguements:w},v=new URLSearchParams({...f}),b=await fetch(r,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:v.toString()}),A=await b.json();if(A.status===Y.OK)return A.result;throw new Error("".concat(A.result))}catch(c){throw new Error(c.toString())}}async function Q(t,e,a){const r="".concat(t,"?module=contract&action=checkverifystatus&guid=").concat(a,"&apikey=").concat(e,'"');return new Promise(((t,e)=>{const a=setInterval((async()=>{try{const e=await fetch(r,{method:"GET"}),i=await e.json();(null===i||void 0===i?void 0:i.result)!==z&&(clearInterval(a),t(i))}catch(i){clearInterval(a),e(i)}}),3e3)}))}class X extends C.cp{constructor(t,e,a){super(t,e),this.storage=a}updateSignerOrProvider(t){super.updateSignerOrProvider(t)}async verifyThirdwebContract(t,e,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0;const n=(await this.getProvider().getNetwork()).chainId,s=await Z(t,n,e,a,this.storage,r,this.options.clientId,this.options.secretKey,i);console.info("Checking verification status...");const o=await Q(e,a,s);console.info(o)}async verifyContract(t,e,a,r){const i=(await this.getProvider().getNetwork()).chainId;let n;if(r){const t=Object.values(r).map((t=>((0,I.c)(t.type,"Param type is required"),t.type))),e=Object.values(r).map((t=>t.value));n=o.s.encode(t,e)}const s=await $(t,i,e,a,this.storage,n);console.info("Checking verification status...");const c=await Q(e,a,s);console.info(c)}}const tt="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";class et{constructor(t,e,a){(0,P.c)(this,"events",new R.c),this.connection=new C.cp(t,e),this.options=e,this.events=new R.c,this.storage=a}connect(t){this.connection.updateSignerOrProvider(t),this.events.emit("signerChanged",this.connection.getSigner())}async transfer(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:C.aV;const[i,n,s]=await Promise.all([(0,C.aL)(t),(0,C.aL)(r),(0,W.n)(this.connection.getProvider(),e,r)]),o=this.requireWallet();if((0,M.i)(n)){const t=await o.getAddress(),e=(0,T.uH)()?{}:await(0,A.g)(this.connection.getProvider()),a=await o.sendTransaction({from:t,to:i,value:s,...e});return{receipt:await a.wait()}}{const t=(await Promise.resolve().then(a.t.bind(a,2056,19))).default;return{receipt:await this.createErc20(n,t).sendTransaction("transfer",[i,s])}}}async balance(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:C.aV;this.requireWallet();const e=await(0,C.aL)(t),r=this.connection.getProvider();let i;if((0,M.i)(e))i=await r.getBalance(await this.getAddress());else{const t=(await Promise.resolve().then(a.t.bind(a,2056,19))).default;i=await this.createErc20(e,t).read("balanceOf",[await this.getAddress()])}return await(0,M.a)(r,e,i)}async getAddress(){return await this.requireWallet().getAddress()}async getChainId(){return await this.requireWallet().getChainId()}async getNonce(t){return await this.connection.getProvider().getTransactionCount(await this.getAddress(),t)}isConnected(){try{return this.requireWallet(),!0}catch(t){return!1}}async sign(t){const e=this.requireWallet();return await e.signMessage(t)}async signTypedData(t,e,a){return await(0,C.aM)(this.requireWallet(),t,e,a)}recoverAddress(t,e){const a=O.S(t),r=n.arrayify(a);return L.recoverAddress(r,e)}async sendRawTransaction(t){const e=this.requireWallet();return t={...(0,T.uH)()?{}:await(0,A.g)(this.connection.getProvider()),...t},e.sendTransaction(t)}async executeRawTransaction(t){const e=await this.sendRawTransaction(t);return{receipt:await e.wait()}}async requestFunds(t){const e=await this.getChainId();if(e===C.aS.Localhost||e===C.aS.Hardhat){return new et(new k.Wallet(tt,(0,C.a_)(e,this.options)),this.options,this.storage).transfer(await this.getAddress(),t)}throw new Error("Requesting funds is not supported on chain: '".concat(e,"'."))}requireWallet(){const t=this.connection.getSigner();return(0,I.c)(t,"This action requires a connected wallet. Please pass a valid signer to the SDK."),t}createErc20(t,e){return new C.cq(this.connection.getSignerOrProvider(),t,e,this.options,this.storage)}}function at(t){return function(t){const e=[];return(0,C.cr)((0,C.ab)(t),e),e.map((t=>t.name))}(t)}class rt{constructor(t,e){(0,P.c)(this,"addContract",(0,A.d)((async t=>{const e=await this.registryRouter.getSignerAddress();return A.T.fromContractWrapper({contractWrapper:this.registryLogic,method:"add",args:[e,t.address,t.chainId,t.metadataURI||""]})}))),(0,P.c)(this,"addContracts",(0,A.d)((async t=>{const e=await this.registryRouter.getSignerAddress(),a=[],r=new M.C(this.registryLogic);return t.forEach((t=>{a.push(r.encode("add",[e,t.address,t.chainId,t.metadataURI||""]))})),A.T.fromContractWrapper({contractWrapper:this.registryRouter,method:"multicall",args:[a]})}))),(0,P.c)(this,"removeContract",(0,A.d)((async t=>{const e=await this.registryRouter.getSignerAddress();return A.T.fromContractWrapper({contractWrapper:this.registryLogic,method:"remove",args:[e,await(0,C.aL)(t.address),t.chainId]})}))),(0,P.c)(this,"removeContracts",(0,A.d)((async t=>{const e=await this.registryRouter.getSignerAddress(),a=new M.C(this.registryLogic),r=await Promise.all(t.map((async t=>a.encode("remove",[e,await(0,C.aL)(t.address),t.chainId]))));return A.T.fromContractWrapper({contractWrapper:this.registryRouter,method:"multicall",args:[r]})})));let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.storage=e,this.registryLogic=new C.cq(t,(0,C.aR)(),F,a,e),this.registryRouter=new C.cq(t,(0,C.aR)(),E,a,e)}async updateSigner(t){this.registryLogic.updateSignerOrProvider(t),this.registryRouter.updateSignerOrProvider(t)}async getContractMetadataURI(t,e){return await this.registryLogic.read("getMetadataUri",[t,await(0,C.aL)(e)])}async getContractMetadata(t,e){const a=await this.getContractMetadataURI(t,e);if(!a)throw new Error("No metadata URI found for contract ".concat(e," on chain ").concat(t));return await this.storage.downloadJSON(a)}async getContractAddresses(t){return(await this.registryLogic.read("getAll",[await(0,C.aL)(t)])).filter((t=>u.isAddress(t.deploymentAddress)&&t.deploymentAddress.toLowerCase()!==p.e)).map((t=>({address:t.deploymentAddress,chainId:t.chainId.toNumber()})))}}function it(t,e){const a=C.bj.parse(t||[]);for(const r of a)if("function"===r.type&&r.name===e)return r.inputs||[];return[]}function nt(t,e){if(t.length!==e.length)throw Error("Passed the wrong number of constructor arguments: ".concat(e.length,", expected ").concat(t.length));return t.map(((t,a)=>"tuple"===t||t.endsWith("[]")?"string"===typeof e[a]?JSON.parse(e[a]):e[a]:"bytes32"===t?((0,I.c)(n.isHexString(e[a]),'Could not parse bytes32 value. Expected valid hex string but got "'.concat(e[a],'".')),n.hexZeroPad(e[a],32)):t.startsWith("bytes")?((0,I.c)(n.isHexString(e[a]),'Could not parse bytes value. Expected valid hex string but got "'.concat(e[a],'".')),e[a]):t.startsWith("uint")||t.startsWith("int")?c.iC.from(e[a].toString()):e[a]))}async function st(t,e){(0,I.c)(t.provider,"No provider");if(await(0,C.av)(C.ar,t.provider))return C.ar;const a=await(0,C.aw)(t.provider),r=(await t.provider.getNetwork()).chainId,i=a?r:0;console.debug("ChainId ".concat(r," enforces EIP155: ").concat(a));const n=C.cs[r]?(0,C.aG)(i,{gasPrice:C.cs[r].gasPrice,gasLimit:C.cs[r].gasLimit}):(0,C.aG)(i,{});if(!await(0,C.av)(n.deployment,t.provider)){var s,o;const a=null!==(s=C.cs[r])&&void 0!==s&&s.gasPrice?C.cs[r].gasPrice:100*10**9,i=null!==(o=C.cs[r])&&void 0!==o&&o.gasLimit?C.cs[r].gasLimit:1e5;(0,I.c)(i,"gasLimit undefined for create2 factory deploy"),(0,I.c)(a,"gasPrice undefined for create2 factory deploy");const p=c.iC.from(a).mul(i);(await t.provider.getBalance(n.signer)).lt(p)&&await(await t.sendTransaction({to:n.signer,value:p})).wait();try{var d,l;console.debug("deploying CREATE2 factory at: ".concat(n.deployment)),null===e||void 0===e||null===(d=e.notifier)||void 0===d||d.call(e,"deploying","create2Factory"),await(await t.provider.sendTransaction(n.transaction)).wait(),null===e||void 0===e||null===(l=e.notifier)||void 0===l||l.call(e,"deployed","create2Factory")}catch(h){throw new Error("Couldn't deploy CREATE2 factory: ".concat(JSON.stringify(h)))}}return n.deployment}C.aS.Mainnet,C.aS.Goerli,C.aS.Polygon,C.aS.Mumbai,C.aS.Fantom,C.aS.FantomTestnet,C.aS.Avalanche,C.aS.AvalancheFujiTestnet,C.aS.Optimism,C.aS.OptimismGoerli,C.aS.Arbitrum,C.aS.ArbitrumGoerli,C.aS.BinanceSmartChainMainnet,C.aS.BinanceSmartChainTestnet,C.aS.Hardhat,C.aS.Localhost;function ot(t,e){return e===p.e?t:e}async function ct(t,e,a,r,i){const n=await r.getAddress(),s=[];switch(e.trusted_forwarders&&e.trusted_forwarders.length>0&&s.push(...e.trusted_forwarders),t){case C.d.contractType:case C.N.contractType:const t=await C.d.schema.deploy.parseAsync(e);return[n,t.name,t.symbol,a,s,ot(n,t.primary_sale_recipient),t.fee_recipient,t.seller_fee_basis_points,t.platform_fee_basis_points,ot(n,t.platform_fee_recipient)];case C.e.contractType:const r=await C.e.schema.deploy.parseAsync(e);return[n,r.name,r.symbol,a,s,ot(n,r.primary_sale_recipient),r.fee_recipient,r.seller_fee_basis_points,r.platform_fee_basis_points,ot(n,r.platform_fee_recipient)];case C.c.contractType:const i=await C.c.schema.deploy.parseAsync(e);return[n,i.name,i.symbol,a,s,i.fee_recipient,i.seller_fee_basis_points];case C.E.contractType:case C.a.contractType:const o=await C.E.schema.deploy.parseAsync(e);return[n,o.name,o.symbol,a,s,ot(n,o.primary_sale_recipient),o.fee_recipient,o.seller_fee_basis_points,o.platform_fee_basis_points,ot(n,o.platform_fee_recipient)];case C.T.contractType:case C.g.contractType:const d=await C.g.schema.deploy.parseAsync(e);return[n,d.name,d.symbol,a,s,ot(n,d.primary_sale_recipient),ot(n,d.platform_fee_recipient),d.platform_fee_basis_points];case C.V.contractType:const l=await C.V.schema.deploy.parseAsync(e);return[l.name,a,s,l.voting_token_address,l.voting_delay_in_blocks,l.voting_period_in_blocks,c.iC.from(l.proposal_token_threshold),l.voting_quorum_fraction];case C.f.contractType:const h=await C.f.schema.deploy.parseAsync(e);return[n,a,s,h.recipients.map((t=>t.address)),h.recipients.map((t=>c.iC.from(t.sharesBps)))];case C.M.contractType:case C.b.contractType:const p=await C.M.schema.deploy.parseAsync(e);return[n,a,s,ot(n,p.platform_fee_recipient),p.platform_fee_basis_points];case C.P.contractType:const u=await C.P.schema.deploy.parseAsync(e);return[n,u.name,u.symbol,a,s,u.fee_recipient,u.seller_fee_basis_points];default:return[]}}const dt={[C.aS.Mainnet]:{"nft-drop":"0x60fF9952e0084A6DEac44203838cDC91ABeC8736","edition-drop":"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550","token-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728","signature-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"},[C.aS.Polygon]:{"nft-drop":"0xB96508050Ba0925256184103560EBADA912Fcc69","edition-drop":"0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550","token-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf","signature-drop":"0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"},[C.aS.Fantom]:{"nft-drop":"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2","edition-drop":"0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B","token-drop":"0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa","signature-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"},[C.aS.Avalanche]:{"nft-drop":"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6","edition-drop":"0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766","token-drop":"0xca0B071899E575BA86495D46c5066971b6f3A901","signature-drop":"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"},[C.aS.Optimism]:{"nft-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1","edition-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10","token-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","signature-drop":"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"},[C.aS.Arbitrum]:{"nft-drop":"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a","edition-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","token-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9","signature-drop":"0x2dF9851af45dd41C8584ac55D983C604da985Bc7"},[C.aS.BinanceSmartChainMainnet]:{"nft-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","edition-drop":"0x2A396b2D90BAcEF19cDa973586B2633d22710fC2","token-drop":"0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10","signature-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1"},[C.aS.Goerli]:{"nft-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","edition-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf","token-drop":"0x5680933221B752EB443654a014f88B101F868d50","signature-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"},[C.aS.Mumbai]:{"nft-drop":"0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a","edition-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","token-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9","signature-drop":"0x2dF9851af45dd41C8584ac55D983C604da985Bc7"},[C.aS.FantomTestnet]:{"nft-drop":"0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD","edition-drop":"0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE","token-drop":"0xFBd7D24d80ee005671E731a7287DEB6073264dD1","signature-drop":"0x5A8eA4Adad8289746D073947BA06D69A62499aaf"},[C.aS.AvalancheFujiTestnet]:{"nft-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","edition-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728","token-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A","signature-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F"},[C.aS.OptimismGoerli]:{"nft-drop":"0xCcddcec1831646Beff2753249f1B9C580327E89F","edition-drop":"0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A","token-drop":"0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C","signature-drop":"0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"},[C.aS.ArbitrumGoerli]:{"nft-drop":"0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6","edition-drop":"0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6","token-drop":"0x1d47526C3292B0130ef0afD5F02c1DA052A017B3","signature-drop":"0xE1eE43D23f247b6A9aF81fcE2766E76709482728"},[C.aS.BinanceSmartChainTestnet]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""},[C.aS.Hardhat]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""},[C.aS.Localhost]:{"nft-drop":"","edition-drop":"","token-drop":"","signature-drop":""}};class lt extends C.cq{constructor(t,e,a,r){super(e,t,q,r,a),(0,P.c)(this,"DEFAULT_VERSION_MAP",{[C.d.contractType]:3,[C.N.contractType]:1,[C.e.contractType]:4,[C.c.contractType]:1,[C.E.contractType]:2,[C.a.contractType]:1,[C.T.contractType]:2,[C.g.contractType]:1,[C.V.contractType]:1,[C.f.contractType]:1,[C.M.contractType]:2,[C.b.contractType]:3,[C.P.contractType]:2}),(0,P.c)(this,"deploy",(0,A.d)((async(t,e,a,r,i,n)=>{const s=C.h[t],o=await s.schema.deploy.parseAsync(e),c=await this.storage.upload(o),d=await this.getImplementation(s,r)||void 0;if(!d||d===p.e)throw new Error("No implementation found for ".concat(t));const l=await s.getAbi(d,this.getProvider(),this.storage),h=this.getSigner();(0,I.c)(h,"A signer is required to deploy contracts");const u=await ct(t,o,c,h,this.storage),y=B.wn.getInterface(l).encodeFunctionData("initialize",u),g=await this.getProvider().getBlockNumber(),m=null!==i&&void 0!==i&&i.saltForProxyDeploy?U.id(i.saltForProxyDeploy):N.y(g.toString());return A.T.fromContractWrapper({contractWrapper:this,method:"deployProxyByImplementation",args:[d,y,m],parse:t=>{n&&n();const e=this.parseLogs("ProxyDeployed",t.logs);if(e.length<1)throw new Error("No ProxyDeployed event found");const r=e[0].args.proxy;return a.emit("contractDeployed",{status:"completed",contractAddress:r,transactionHash:t.transactionHash}),r}})}))),(0,P.c)(this,"deployProxyByImplementation",(0,A.d)((async(t,e,a,r,i,n,s)=>{const o=B.wn.getInterface(e).encodeFunctionData(a,r),c=await this.getProvider().getBlockNumber(),d=n?U.id(n):N.y(c.toString());return A.T.fromContractWrapper({contractWrapper:this,method:"deployProxyByImplementation",args:[t,o,d],parse:t=>{s&&s();const e=this.parseLogs("ProxyDeployed",t.logs);if(e.length<1)throw new Error("No ProxyDeployed event found");const a=e[0].args.proxy;return i.emit("contractDeployed",{status:"completed",contractAddress:a,transactionHash:t.transactionHash}),a}})}))),this.storage=a}async getDeployArguments(t,e,a){let r=[];e.trusted_forwarders&&e.trusted_forwarders.length>0&&(r=e.trusted_forwarders);const i=await this.getSignerAddress();switch(t){case C.d.contractType:case C.N.contractType:const t=await C.d.schema.deploy.parseAsync(e);return[i,t.name,t.symbol,a,r,ot(i,t.primary_sale_recipient),t.fee_recipient,t.seller_fee_basis_points,t.platform_fee_basis_points,ot(i,t.platform_fee_recipient)];case C.e.contractType:const n=await C.e.schema.deploy.parseAsync(e);return[i,n.name,n.symbol,a,r,ot(i,n.primary_sale_recipient),n.fee_recipient,n.seller_fee_basis_points,n.platform_fee_basis_points,ot(i,n.platform_fee_recipient)];case C.c.contractType:const s=await C.c.schema.deploy.parseAsync(e);return[i,s.name,s.symbol,a,r,s.fee_recipient,s.seller_fee_basis_points];case C.E.contractType:case C.a.contractType:const o=await C.E.schema.deploy.parseAsync(e);return[i,o.name,o.symbol,a,r,ot(i,o.primary_sale_recipient),o.fee_recipient,o.seller_fee_basis_points,o.platform_fee_basis_points,ot(i,o.platform_fee_recipient)];case C.T.contractType:case C.g.contractType:const d=await C.g.schema.deploy.parseAsync(e);return[i,d.name,d.symbol,a,r,ot(i,d.primary_sale_recipient),ot(i,d.platform_fee_recipient),d.platform_fee_basis_points];case C.V.contractType:const l=await C.V.schema.deploy.parseAsync(e);return[l.name,a,r,l.voting_token_address,l.voting_delay_in_blocks,l.voting_period_in_blocks,c.iC.from(l.proposal_token_threshold),l.voting_quorum_fraction];case C.f.contractType:const h=await C.f.schema.deploy.parseAsync(e);return[i,a,r,h.recipients.map((t=>t.address)),h.recipients.map((t=>c.iC.from(t.sharesBps)))];case C.M.contractType:const p=await C.M.schema.deploy.parseAsync(e);return[i,a,r,ot(i,p.platform_fee_recipient),p.platform_fee_basis_points];case C.b.contractType:const u=await C.b.schema.deploy.parseAsync(e);return[i,a,r,ot(i,u.platform_fee_recipient),u.platform_fee_basis_points];case C.P.contractType:const y=await C.P.schema.deploy.parseAsync(e);return[i,y.name,y.symbol,a,r,y.fee_recipient,y.seller_fee_basis_points];default:return[]}}async getImplementation(t,e){const a=N.y(t.name),r=function(t,e){if(t in dt){const a=dt[t];if(e in a)return a[e]}return null}(await this.getChainID(),t.contractType);return r&&r.length>0&&void 0===e?r:this.read("getImplementation",[a,void 0!==e?e:this.DEFAULT_VERSION_MAP[t.contractType]])}async getLatestVersion(t){const e=(0,C.k)(t);if(!e)throw new Error("Invalid contract type ".concat(t));const a=N.y(e);return this.read("currentVersion",[a])}}class ht extends C.cq{constructor(t,e,a,r,i){super(e,t,r,i,a),(0,P.c)(this,"addContract",(0,A.d)((async t=>await this.addContracts.prepare([t])))),(0,P.c)(this,"addContracts",(0,A.d)((async t=>{const e=await this.getSignerAddress(),a=new M.C(this),r=(await Promise.all(t.map((t=>(0,C.aL)(t))))).map((t=>a.encode("add",[e,t])));return A.T.fromContractWrapper({contractWrapper:this,method:"multicall",args:[r]})}))),(0,P.c)(this,"removeContract",(0,A.d)((async t=>await this.removeContracts.prepare([t])))),(0,P.c)(this,"removeContracts",(0,A.d)((async t=>{const e=await this.getSignerAddress(),a=new M.C(this),r=(await Promise.all(t.map((t=>(0,C.aL)(t))))).map((t=>a.encode("remove",[e,t])));return A.T.fromContractWrapper({contractWrapper:this,method:"multicall",args:[r]})})))}async getContractAddresses(t){return(await this.read("getAll",[await(0,C.aL)(t)])).filter((t=>u.isAddress(t)&&t.toLowerCase()!==p.e))}}const pt=(()=>C.bB.merge(C.bD).merge(C.bH))(),ut=(()=>pt.merge(C.bF).merge(C.bE).merge(C.bG))(),yt=(()=>C.bB.merge(C.bH))(),gt=(()=>yt.merge(C.bG))();async function mt(t,e,a,r,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:7e6;(0,I.c)(a.provider,"Provider is required");const s=t.startsWith("0x")?t:"0x".concat(t),d=await st(a),l=(0,C.a1)(e),h=nt(l.map((t=>t.type)),r),p=l.map((t=>"tuple[]"===t.type?G.Sk.from(t):t.type)),u=o.s.encode(p,h),y=(0,C.aA)(s,u,d,i);let g="";if(await(0,C.av)(y,a.provider))throw new Error("Contract already deployed at ".concat(y));{console.debug("deploying contract via create2 factory at: ".concat(y)),g=(0,C.az)(s,u,i);const t={to:d,data:g};try{await a.estimateGas(t)}catch(m){console.debug("error estimating gas while deploying prebuilt: ",m),t.gasLimit=c.iC.from(n)}await(await a.sendTransaction(t)).wait()}return y}async function wt(t,e,a,r,i){const n=t.startsWith("0x")?t:"0x".concat(t),s=await(0,C.ax)(a),c=(0,C.a1)(e),d=nt(c.map((t=>t.type)),r),l=c.map((t=>"tuple[]"===t.type?G.Sk.from(t):t.type)),h=o.s.encode(l,d);return(0,C.aA)(n,h,s,i)}class ft extends C.cp{static async fromWallet(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;const i=await t.getSigner();return ft.fromSigner(i,e,a,r)}static fromSigner(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0,i=t;if(e)try{const r=(0,C.a_)(e,a);i=t.connect(r)}catch{}const n=new ft(e||i,e?vt(e,a):a,r);return n.updateSignerOrProvider(i),n}static fromPrivateKey(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;const i=(0,C.a_)(e,a),n=new k.Wallet(t,i);return new ft(n,vt(e,a),r)}constructor(t){var e;let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;let i="No API key. Please provide a ".concat("clientId",". It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key");var n,s,o;n=i,s=a.clientId,o=a.secretKey,j||(j=!0,s||o||console.warn(n)),a=vt(t,a),super(t,a),(0,P.c)(this,"contractCache",new Map),(0,C.aT)(null===(e=a)||void 0===e?void 0:e.supportedChains);const c=function(t,e){return t||(null!==e&&void 0!==e&&e.gatewayUrls?new T.uO({gatewayUrls:e.gatewayUrls,clientId:e.clientId,secretKey:e.secretKey}):new T.uO({clientId:null===e||void 0===e?void 0:e.clientId,secretKey:null===e||void 0===e?void 0:e.secretKey}))}(r,a);this.storage=c,this.storageHandler=c,this.wallet=new et(t,a,c),this.deployer=new At(t,a,c),this.verifier=new X(t,a,c),this.multiChainRegistry=new rt(t,this.storageHandler,this.options),this._publisher=new D(t,this.options,this.storageHandler)}get auth(){throw new Error("The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.\n      Please visit https://portal.thirdweb.com/wallets/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).\n\n      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.")}async getNFTDrop(t){return await this.getContract(t,"nft-drop")}async getSignatureDrop(t){return await this.getContract(t,"signature-drop")}async getNFTCollection(t){return await this.getContract(t,"nft-collection")}async getEditionDrop(t){return await this.getContract(t,"edition-drop")}async getEdition(t){return await this.getContract(t,"edition")}async getTokenDrop(t){return await this.getContract(t,"token-drop")}async getToken(t){return await this.getContract(t,"token")}async getVote(t){return await this.getContract(t,"vote")}async getSplit(t){return await this.getContract(t,"split")}async getMarketplace(t){return await this.getContract(t,"marketplace")}async getMarketplaceV3(t){return await this.getContract(t,"marketplace-v3")}async getPack(t){return await this.getContract(t,"pack")}async getMultiwrap(t){return await this.getContract(t,"multiwrap")}async getContract(t,e){const a=await(0,C.aL)(t);if(this.contractCache.has(a))return this.contractCache.get(a);if(a in K._)return await this.getContractFromAbi(a,K._[a]);let r;if(e&&"custom"!==e)r="string"===typeof e&&e in C.h?await C.h[e].initialize(this.getSignerOrProvider(),a,this.storage,this.options):await this.getContractFromAbi(a,e);else try{const t=await this.getPublisher().fetchCompilerMetadataFromAddress(a);r=await this.getContractFromAbi(a,t.abi)}catch(i){const t=await this.resolveContractType(a);if(!t||"custom"===t)throw i;{const e=await C.h[t].getAbi(a,this.getProvider(),this.storage);r=await this.getContractFromAbi(a,e)}}return this.contractCache.set(a,r),r}async getBuiltInContract(t,e){return await this.getContract(t,e)}async resolveContractType(t){try{const e=(await a.e(9796).then(a.t.bind(a,29796,19))).default,r=new B.wn(await(0,C.aL)(t),e,this.getProvider()),i=y.Gk(await r.contractType()).replace(/\x00/g,"");return(0,C.j)(i)}catch(e){return"custom"}}async getContractList(t){var e;const a=await(null===(e=await this.deployer.getRegistry())||void 0===e?void 0:e.getContractAddresses(await(0,C.aL)(t)))||[],r=(await this.getProvider().getNetwork()).chainId;return await Promise.all(a.map((async t=>({address:t,chainId:r,contractType:()=>this.resolveContractType(t),metadata:async()=>(await this.getContract(t)).metadata.get(),extensions:async()=>at((await this.getContract(t)).abi)}))))}async getMultichainContractList(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.wFi;const a=await this.multiChainRegistry.getContractAddresses(t),r=e.reduce(((t,e)=>(t[e.chainId]=e,t)),{}),i={};return a.map((t=>{let{address:a,chainId:n}=t;if(!r[n])return{address:a,chainId:n,contractType:async()=>"custom",metadata:async()=>({name:""}),extensions:async()=>[]};try{let t=i[n];return t||(t=new ft(n,{...this.options,readonlySettings:void 0,supportedChains:e},this.storage),i[n]=t),{address:a,chainId:n,contractType:()=>t.resolveContractType(a),metadata:async()=>(await t.getContract(a)).metadata.get(),extensions:async()=>at((await t.getContract(a)).abi)}}catch(s){return{address:a,chainId:n,contractType:async()=>"custom",metadata:async()=>({name:""}),extensions:async()=>[]}}}))}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.updateContractSignerOrProvider()}updateContractSignerOrProvider(){this.wallet.connect(this.getSignerOrProvider()),this.deployer.updateSignerOrProvider(this.getSignerOrProvider()),this._publisher.updateSignerOrProvider(this.getSignerOrProvider()),this.multiChainRegistry.updateSigner(this.getSignerOrProvider()),this.verifier.updateSignerOrProvider(this.getSignerOrProvider());for(const[,t]of this.contractCache)t.onNetworkUpdated(this.getSignerOrProvider())}async getContractFromAbi(t,e){const[r,{SmartContract:i}]=await Promise.all([(0,C.aL)(t),Promise.all([a.e(8944),a.e(9688),a.e(1028),a.e(8736),a.e(6096),a.e(400),a.e(2352),a.e(3284),a.e(1340),a.e(5608)]).then(a.bind(a,45608))]);if(this.contractCache.has(r))return this.contractCache.get(r);const[,n]=(0,C.b3)(this.getSignerOrProvider(),this.options),s="string"===typeof e?JSON.parse(e):e,o=new i(this.getSignerOrProvider(),r,await(0,C.ak)(r,C.bj.parse(s),n,this.options,this.storage),this.storageHandler,this.options,(await n.getNetwork()).chainId);return this.contractCache.set(r,o),o}async getBalance(t){return(0,M.a)(this.getProvider(),C.aV,await this.getProvider().getBalance(await(0,C.aL)(t)))}getPublisher(){return this._publisher}}function vt(t,e){var a;(0,C.b1)(t)&&(e={...e,supportedChains:[t,...(null===(a=e)||void 0===a?void 0:a.supportedChains)||[]]});return e}const bt="0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";class At extends C.cp{constructor(t,e,r){super(t,e),(0,P.c)(this,"transactionListener",(t=>{"submitted"===t.status&&this.events.emit("contractDeployed",{status:"submitted",transactionHash:t.transactionHash})})),(0,P.c)(this,"deployNFTCollection",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.N.contractType,t,"latest",e)))),(0,P.c)(this,"deployNFTDrop",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.d.contractType,t,"latest",e)))),(0,P.c)(this,"deployLoyaltyCard",(0,A.f)((async(t,e)=>{var a;const r=await ut.parseAsync(t),i=await this.storage.upload(r),n=[];t.trusted_forwarders&&t.trusted_forwarders.length>0&&n.push(...t.trusted_forwarders);const s=[await(null===(a=this.getSigner())||void 0===a?void 0:a.getAddress()),r.name,r.symbol,i,n,r.primary_sale_recipient,r.fee_recipient,r.seller_fee_basis_points,r.platform_fee_basis_points,r.platform_fee_recipient];return await this.deployReleasedContract.prepare(bt,"LoyaltyCard",s,"latest",e)}))),(0,P.c)(this,"deployOpenEdition",(0,A.f)((async(t,e)=>{var a;const r=await C.bR.deploy.parseAsync(t),i=await this.storage.upload(r),n=[];t.trusted_forwarders&&t.trusted_forwarders.length>0&&n.push(...t.trusted_forwarders);const s=[await(null===(a=this.getSigner())||void 0===a?void 0:a.getAddress()),r.name,r.symbol,i,n,r.primary_sale_recipient,r.fee_recipient,r.seller_fee_basis_points];return await this.deployPublishedContract.prepare(bt,"OpenEditionERC721",s,"latest",e)}))),(0,P.c)(this,"deploySignatureDrop",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.e.contractType,t,"latest",e)))),(0,P.c)(this,"deployMultiwrap",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.c.contractType,t,"latest",e)))),(0,P.c)(this,"deployEdition",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.a.contractType,t,"latest",e)))),(0,P.c)(this,"deployEditionDrop",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.E.contractType,t,"latest",e)))),(0,P.c)(this,"deployToken",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.g.contractType,t,"latest",e)))),(0,P.c)(this,"deployTokenDrop",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.T.contractType,t,"latest",e)))),(0,P.c)(this,"deployMarketplace",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.M.contractType,t,"latest",e)))),(0,P.c)(this,"deployMarketplaceV3",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.b.contractType,t,"latest",e)))),(0,P.c)(this,"deployPack",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.P.contractType,t,"latest",e)))),(0,P.c)(this,"deploySplit",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.f.contractType,t,"latest",e)))),(0,P.c)(this,"deployVote",(0,A.f)((async(t,e)=>await this.deployBuiltInContract.prepare(C.V.contractType,t,"latest",e)))),(0,P.c)(this,"deployAirdropERC20",(0,A.f)((async(t,e)=>{var a;const r=await gt.parseAsync(t),i=await this.storage.upload(r),n=[];t.trusted_forwarders&&t.trusted_forwarders.length>0&&n.push(...t.trusted_forwarders);const s=[await(null===(a=this.getSigner())||void 0===a?void 0:a.getAddress()),i,n];return await this.deployReleasedContract.prepare(bt,"AirdropERC20",s,"latest",e)}))),(0,P.c)(this,"deployAirdropERC721",(0,A.f)((async(t,e)=>{var a;const r=await gt.parseAsync(t),i=await this.storage.upload(r),n=[];t.trusted_forwarders&&t.trusted_forwarders.length>0&&n.push(...t.trusted_forwarders);const s=[await(null===(a=this.getSigner())||void 0===a?void 0:a.getAddress()),i,n];return await this.deployReleasedContract.prepare(bt,"AirdropERC721",s,"latest",e)}))),(0,P.c)(this,"deployAirdropERC1155",(0,A.f)((async(t,e)=>{var a;const r=await gt.parseAsync(t),i=await this.storage.upload(r),n=[];t.trusted_forwarders&&t.trusted_forwarders.length>0&&n.push(...t.trusted_forwarders);const s=[await(null===(a=this.getSigner())||void 0===a?void 0:a.getAddress()),i,n];return await this.deployReleasedContract.prepare(bt,"AirdropERC1155",s,"latest",e)}))),(0,P.c)(this,"deployBuiltInContract",(0,A.f)((()=>{var t=this;return async function(e,a){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest",i=arguments.length>3?arguments[3]:void 0;const n=t.getSigner();(0,I.c)(n,"A signer is required to deploy contracts");const s={app_uri:C.i[e],...await C.h[e].schema.deploy.parseAsync(a)};if(t.hasLocalFactory()){let a;try{a=parseInt(r),isNaN(a)&&(a=void 0)}catch(h){a=void 0}const n=await t.getFactory();if(!n)throw new Error("Factory not found");return n.on(C.aZ.Transaction,t.transactionListener),n.deploy.prepare(e,s,t.events,a,i,(()=>{n.off(C.aZ.Transaction,t.transactionListener)}))}const o=(0,C.k)(e);(0,I.c)(o,"Contract name not found");const c=await t.storage.upload(s),d=await ct(e,s,c,n,t.storage),l=await t.fetchPublishedContractFromPolygon(bt,o,r);return t.deployContractFromUri.prepare(l.metadataUri,d,i)}})())),(0,P.c)(this,"deployReleasedContract",(0,A.f)((()=>{var t=this;return async function(e,a,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",n=arguments.length>4?arguments[4]:void 0;const s=await t.fetchPublishedContractFromPolygon(e,a,i);return await t.deployContractFromUri.prepare(s.metadataUri,r,n)}})())),(0,P.c)(this,"deployPublishedContract",this.deployReleasedContract),(0,P.c)(this,"deployViaFactory",(0,A.d)((async(t,e,a,r,i,n)=>{const s=await(0,C.aL)(t),o=await(0,C.aL)(e),c=this.getSigner();(0,I.c)(c,"signer is required");const d=new lt(s,this.getSignerOrProvider(),this.storage,this.options);return d.on(C.aZ.Transaction,this.transactionListener),await d.deployProxyByImplementation.prepare(o,a,r,i,this.events,n,(()=>{d.off(C.aZ.Transaction,this.transactionListener)}))}))),(0,P.c)(this,"deployProxy",(0,A.f)((async(t,e,r,i)=>{const n=await(0,C.aL)(t),s=B.wn.getInterface(e).encodeFunctionData(r,i),{TWProxy__factory:o}=await a.e(2216).then(a.bind(a,92216));return this.deployContractWithAbi.prepare(o.abi,o.bytecode,[n,s])}))),(0,P.c)(this,"deployViaAutoFactory",(0,A.f)((async(t,e,a,r,i,n)=>{var s,o,c;const d=await st(a,n),l=await(0,H.g)(t,this.storage,this.getProvider(),d,this.options.clientId,this.options.secretKey),h=null===(s=l.find((t=>"implementation"===t.type)))||void 0===s?void 0:s.transaction.predictedAddress,p=l.filter((t=>t.transaction.data&&t.transaction.data.length>0)),u=p.filter((t=>"infra"!==t.type)).map((t=>t.transaction)),y=p.filter((t=>"infra"===t.type)).map((t=>t.transaction));await(0,H.a)(a,y,n);for(const v of u)try{await(0,H.d)(a,v,n)}catch(f){throw console.debug("Error deploying contract at ".concat(v.predictedAddress),null===f||void 0===f?void 0:f.message),f}const g=await(0,C.aL)(h),m=await async function(t,e,a,r,i){return a||(a=await(0,C.ax)(t)),(await(0,C.aE)("infra",t,e,a,{contractName:"TWCloneFactory"},r,i)).transaction.predictedAddress}(this.getProvider(),this.storage,d,this.options.clientId,this.options.secretKey);null===n||void 0===n||null===(o=n.notifier)||void 0===o||o.call(n,"deploying","proxy");const w=await this.deployViaFactory.prepare(m,g,e.compilerMetadata.abi,r,i,null===n||void 0===n?void 0:n.saltForProxyDeploy);return null===n||void 0===n||null===(c=n.notifier)||void 0===c||c.call(n,"deployed","proxy"),w}))),(0,P.c)(this,"deployViaCustomFactory",(0,A.f)((async(t,e,a,r)=>{var i,n;const s=null===(i=e.extendedMetadata)||void 0===i||null===(i=i.factoryDeploymentData)||void 0===i||null===(i=i.customFactoryInput)||void 0===i?void 0:i.customFactoryAddresses[r],o=await(0,C.aL)(s);(0,I.c)(o,"customFactoryAddress not found for chainId '".concat(r,"'")),(0,I.c)(null===(n=e.extendedMetadata)||void 0===n||null===(n=n.factoryDeploymentData)||void 0===n||null===(n=n.customFactoryInput)||void 0===n?void 0:n.factoryFunction,"customFactoryFunction not set'");const c=await(0,C.K)(o,this.getProvider(),this.storage,this.options),d=nt(it(c.abi,e.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((t=>t.type)),t);let l;const h=await A.T.fromContractInfo({contractAddress:o,contractAbi:c.abi,provider:this.getProvider(),signer:a,method:e.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,args:d,parse:()=>l,storage:this.storage});return l=await h.simulate(),h}))),(0,P.c)(this,"deployContractFromUri",(0,A.f)((async(t,e,a)=>{var r,i;const s=this.getSigner();(0,I.c)(s,"A signer is required");const{compilerMetadata:o,extendedMetadata:c}=await(0,C.aJ)(t,this.storage),d=(null===a||void 0===a?void 0:a.forceDirectDeploy)||!1,l=(await this.getProvider().getNetwork()).chainId,h=(null===c||void 0===c||null===(r=c.networksForDeployment)||void 0===r?void 0:r.networksEnabled.includes(l))||(null===c||void 0===c||null===(i=c.networksForDeployment)||void 0===i?void 0:i.allNetworks);if(null!==c&&void 0!==c&&c.networksForDeployment&&!h&&"AccountFactory"!==o.name)throw new Error("Deployments disabled on this network, with chainId: ".concat(l));if(c&&c.factoryDeploymentData&&(c.isDeployableViaProxy||c.isDeployableViaFactory||c.deployType&&"standard"!==c.deployType)&&!d){if("customFactory"===c.deployType)return await this.deployViaCustomFactory.prepare(e,{compilerMetadata:o,extendedMetadata:c},s,l);{(0,I.c)(c.factoryDeploymentData.implementationInitializerFunction,"implementationInitializerFunction not set'");const r=nt(it(o.abi,c.factoryDeploymentData.implementationInitializerFunction).map((t=>t.type)),e),i=c.factoryDeploymentData.implementationAddresses[l];if(!i||"autoFactory"===c.deployType)return await this.deployViaAutoFactory.prepare(t,{compilerMetadata:o,extendedMetadata:c},s,c.factoryDeploymentData.implementationInitializerFunction,r,a);const n=await(0,C.aL)(i);if((0,I.c)(n,"implementationAddress not found for chainId '".concat(l,"'")),c.isDeployableViaFactory){(0,I.c)(c.factoryDeploymentData.factoryAddresses,"isDeployableViaFactory is true so factoryAddresses is required");const t=c.factoryDeploymentData.factoryAddresses[l];(0,I.c)(t,"isDeployableViaFactory is true and factoryAddress not found for chainId '".concat(l,"'"));const e=await(0,C.aL)(t);return await this.deployViaFactory.prepare(e,n,o.abi,c.factoryDeploymentData.implementationInitializerFunction,r,null===a||void 0===a?void 0:a.saltForProxyDeploy)}if(c.isDeployableViaProxy)return await this.deployProxy.prepare(n,o.abi,c.factoryDeploymentData.implementationInitializerFunction,r)}}const p=o.bytecode.startsWith("0x")?o.bytecode:"0x".concat(o.bytecode);if(!n.isHexString(p))throw new Error("Contract bytecode is invalid.\n\n".concat(p));const u=nt((0,C.a1)(o.abi).map((t=>t.type)),e);return this.deployContractWithAbi.prepare(o.abi,p,u)}))),(0,P.c)(this,"deployContractWithAbi",(0,A.f)((async(t,e,a)=>{const r=this.getSigner(),i=this.getProvider();(0,I.c)(r,"Signer is required to deploy contracts");const n=new B.uY(t,e).connect(r);return new A.D({args:a,provider:i,signer:r,factory:n,storage:this.storage,events:this.events})}))),this.storage=r,this.events=new R.c,this.getFactory(),this.getRegistry()}async getLatestBuiltInContractVersion(t){const e=await this.getFactory();if(!e)throw new Error("Factory not found");return await e.getLatestVersion(t)}async deployPublishedContractDeterministic(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bt,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0;const n=this.getSigner();return(0,I.c)(n,"Signer is required"),async function(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest",r=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,c=arguments.length>8?arguments[8]:void 0,d=arguments.length>9&&void 0!==arguments[9]?arguments[9]:7e6;const l=(await(0,C.aI)(e,t,a,n,s,o)).metadataUri,{compilerMetadata:h,extendedMetadata:p}=await(0,C.aJ)(l,n);return(0,I.c)("standard"===(null===p||void 0===p?void 0:p.deployType),"Must be direct deploy"),await mt(h.bytecode,h.abi,i,r,c,d)}(t,a,r,e,n,this.storage,this.options.clientId,this.options.secretKey,i)}async predictAddressDeterministic(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bt,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"latest",i=arguments.length>4?arguments[4]:void 0;const n=this.getProvider();return(0,I.c)(n,"Provider is required"),async function(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest",r=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,o=arguments.length>7?arguments[7]:void 0,c=arguments.length>8?arguments[8]:void 0;const d=(await(0,C.aI)(e,t,a,n,s,o)).metadataUri,{compilerMetadata:l,extendedMetadata:h}=await(0,C.aJ)(d,n);return(0,I.c)("standard"===(null===h||void 0===h?void 0:h.deployType),"Must be direct deploy"),await wt(l.bytecode,l.abi,i,r,c)}(t,a,r,e,n,this.storage,this.options.clientId,this.options.secretKey,i)}async getRegistry(){return this._registry?this._registry:this._registry=this.getProvider().getNetwork().then((async t=>{let{chainId:e}=t;const r=(0,C.aP)(e,"twRegistry");if(!r)return;const i=(await a.e(3816).then(a.t.bind(a,63816,19))).default;return new ht(r,this.getSignerOrProvider(),this.storage,i,this.options)}))}async getFactory(){return this._factory?this._factory:this._factory=this.getProvider().getNetwork().then((async t=>{let{chainId:e}=t;const a=(0,C.aP)(e,"twFactory");if(!a)return;return new lt(a,this.getSignerOrProvider(),this.storage,this.options)}))}updateSignerOrProvider(t){super.updateSignerOrProvider(t),this.updateContractSignerOrProvider()}updateContractSignerOrProvider(){var t,e;null===(t=this._factory)||void 0===t||t.then((t=>{null===t||void 0===t||t.updateSignerOrProvider(this.getSignerOrProvider())})).catch((()=>{})),null===(e=this._registry)||void 0===e||e.then((t=>{null===t||void 0===t||t.updateSignerOrProvider(this.getSignerOrProvider())})).catch((()=>{}))}async getTransactionsForDeploy(t,e){let a=[];const r=this.getProvider();(0,I.c)(r,"A provider is required");const{extendedMetadata:i}=await(0,C.aJ)(t,this.storage),n=(null===e||void 0===e?void 0:e.forceDirectDeploy)||!1;if(i&&i.factoryDeploymentData&&(i.isDeployableViaProxy||i.isDeployableViaFactory||"autoFactory"===i.deployType)&&!n){const e=(await this.getProvider().getNetwork()).chainId;if(!i.factoryDeploymentData.implementationAddresses[e]||"autoFactory"===i.deployType){const e=await(0,C.ax)(this.getProvider());a.push({contractType:"create2Factory",addresses:[e]});const r=(await(0,H.g)(t,this.storage,this.getProvider(),e,this.options.clientId,this.options.secretKey)).filter((t=>t.transaction.data&&t.transaction.data.length>0));r.filter((t=>"infra"!==t.type)).map((t=>t.transaction)).forEach((t=>{a.push({contractType:"preset",addresses:[t.predictedAddress]})}));const i=r.filter((t=>"infra"===t.type)).map((t=>t.transaction));(0,H.c)(i).forEach((t=>{const e=t.map((t=>t.predictedAddress));a.push({contractType:"infra",addresses:e})}))}a=(await Promise.all(a.map((async t=>(await Promise.all(t.addresses.map((async t=>await(0,C.av)(t,r)?null:t)))).filter(Boolean).length>0?t:null)))).filter(Boolean),a.push({contractType:"proxy",addresses:[]})}else a.push({contractType:"custom",addresses:[]});return a}addDeployListener(t){this.events.on("contractDeployed",t)}removeDeployListener(t){this.events.off("contractDeployed",t)}removeAllDeployListeners(){this.events.removeAllListeners("contractDeployed")}async fetchPublishedContractFromPolygon(t,e,a){const r=await(0,C.aL)(t),i=await new ft("polygon",{clientId:this.options.clientId,secretKey:this.options.secretKey},this.storage).getPublisher().getVersion(r,e,a);if(!i)throw new Error("No published contract found for '".concat(e,"' at version '").concat(a,"' by '").concat(r,"'"));return i}hasLocalFactory(){return!!(0,C.cu)("factoryAddress")}}async function Pt(t){const e=await i.resolveProperties(t);return Object.keys(e).map((t=>{let a=e[t];return"string"===typeof a&&a.startsWith("0x")||(a=n.hexValue(a)),[t,a]})).reduce(((t,e)=>{let[a,r]=e;return{...t,[a]:r}}),{})}const Ct=()=>{let t=(()=>{const t=BigInt(Math.floor(4294967296*Math.random())),e=BigInt(Math.floor(4294967296*Math.random())),a=BigInt(Math.floor(4294967296*Math.random())),r=BigInt(Math.floor(4294967296*Math.random())),i=BigInt(Math.floor(4294967296*Math.random())),n=BigInt(Math.floor(4294967296*Math.random()));return t<<BigInt(160)|e<<BigInt(128)|a<<BigInt(96)|r<<BigInt(64)|i<<BigInt(32)|n})().toString(16);return t.length%2!==0&&(t="0"+t),t="0x"+t,c.iC.from(n.concat([t,"0x0000000000000000"]))};class Tt{}class _t{constructor(t,e,a,r,i){this.bundlerUrl=t,this.entryPointAddress=e,this.chainId=a;const n={};if((0,m.i)(this.bundlerUrl)){const t="undefined"!==typeof globalThis&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;i?n["x-secret-key"]=i:r&&(n["x-client-id"]=r,t&&(n["x-bundle-id"]=t)),"undefined"!==typeof globalThis&&"TW_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_AUTH_TOKEN&&(n.authorization="Bearer ".concat(globalThis.TW_AUTH_TOKEN)),"undefined"!==typeof globalThis&&"TW_CLI_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_CLI_AUTH_TOKEN&&(n.authorization="Bearer ".concat(globalThis.TW_CLI_AUTH_TOKEN),n["x-authorize-wallet"]="true"),(0,w.s)(n)}this.userOpJsonRpcProvider=new d.W({url:this.bundlerUrl,headers:n},{name:"Connected bundler network",chainId:a}),this.initializing=this.validateChainId()}async validateChainId(){const t=await this.userOpJsonRpcProvider.send("eth_chainId",[]),e=parseInt(t);if(e!==this.chainId)throw new Error("bundler ".concat(this.bundlerUrl," is on chainId ").concat(e,", but provider is on chainId ").concat(this.chainId))}async sendUserOpToBundler(t){await this.initializing;const e=await Pt(t),a=[e,this.entryPointAddress];return await this.printUserOperation("eth_sendUserOperation",a),await this.userOpJsonRpcProvider.send("eth_sendUserOperation",[e,this.entryPointAddress])}async estimateUserOpGas(t){await this.initializing;const e=await Pt(t),a=[e,this.entryPointAddress];return await this.printUserOperation("eth_estimateUserOperationGas",a),await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas",[e,this.entryPointAddress])}async printUserOperation(t,e){}}class xt extends Tt{constructor(t,e,a,r){super(),this.paymasterUrl=t,this.entryPoint=e,this.clientId=a,this.secretKey=r}async getPaymasterAndData(t){const e={"Content-Type":"application/json"};if((0,m.i)(this.paymasterUrl)){if(this.secretKey&&this.clientId)throw new Error("Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.");this.secretKey?e["x-secret-key"]=this.secretKey:this.clientId&&(e["x-client-id"]=this.clientId,"undefined"!==typeof globalThis&&"APP_BUNDLE_ID"in globalThis&&(e["x-bundle-id"]=globalThis.APP_BUNDLE_ID)),"undefined"!==typeof globalThis&&"TW_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_AUTH_TOKEN&&(e.authorization="Bearer ".concat(globalThis.TW_AUTH_TOKEN)),"undefined"!==typeof globalThis&&"TW_CLI_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_CLI_AUTH_TOKEN&&(e.authorization="Bearer ".concat(globalThis.TW_CLI_AUTH_TOKEN),e["x-authorize-wallet"]="true"),(0,w.s)(e)}const a=await fetch(this.paymasterUrl,{method:"POST",headers:e,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[await Pt(t),this.entryPoint]})}),r=await a.json();if(!a.ok){const t=r.error||a.statusText,e=r.code||"UNKNOWN";throw new Error("Paymaster error: ".concat(t,"\nStatus: ").concat(a.status,"\nCode: ").concat(e))}if(r.result)return"string"===typeof r.result?{paymasterAndData:r.result}:r.result;{var i;const t=(null===(i=r.error)||void 0===i?void 0:i.message)||r.error||a.statusText||"unknown error";throw new Error("Paymaster error from ".concat(this.paymasterUrl,": ").concat(t))}}}const It=(t,e,a,r)=>new xt(t,e,a,r);class Dt{constructor(t,e,a,r,i,n,s){this.resolve=t,this.reject=e,this.entryPoint=a,this.sender=r,this.userOpHash=i,this.nonce=n,this.timeout=s,(0,v._)(this,"resolved",!1),this.boundLisener=this.listenerCallback.bind(this)}start(){const t=this.entryPoint.filters.UserOperationEvent(this.userOpHash);setTimeout((async()=>{const e=await this.entryPoint.queryFilter(t,-10);e.length>0?this.listenerCallback(e[0]):this.entryPoint.once(t,this.boundLisener)}),100)}stop(){this.entryPoint.off("UserOperationEvent",this.boundLisener)}async listenerCallback(){for(var t=arguments.length,e=new Array(t),a=0;a<t;a++)e[a]=arguments[a];const r=arguments[arguments.length-1];if(!r.args)return void console.error("got event without args",r);var i;if(r.args.userOpHash!==this.userOpHash)return void console.log("== event with wrong userOpHash: sender/nonce: event.".concat(r.args.sender,"@").concat(r.args.nonce.toString(),"!= userOp.").concat(this.sender,"@").concat(parseInt(null===(i=this.nonce)||void 0===i?void 0:i.toString())));const n=await r.getTransactionReceipt();r.args.success||await this.extractFailureReason(n),this.stop(),this.resolve(n),this.resolved=!0}async extractFailureReason(t){t.status=0;const e=await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash,this.sender),t.blockHash);if(e[0]){let t=e[0].args.revertReason;t.startsWith("0x08c379a0")&&(t=o.s.decode(["string"],"0x"+t.substring(10)).toString()),this.reject(new Error("UserOp failed with reason: ".concat(t)))}}}class Ft extends l.Signer{constructor(t,e,a,r,n){super(),i.defineReadOnly(this,"provider",a),this.config=t,this.originalSigner=e,this.erc4337provider=a,this.httpRpcClient=r,this.smartAccountAPI=n}async sendTransaction(t,e){var a;const r=await i.resolveProperties(t);await this.verifyAllNecessaryFields(r);const n=Ct(),s=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:r.to||"",data:(null===(a=r.data)||void 0===a?void 0:a.toString())||"0x",value:r.value,gasLimit:r.gasLimit,nonce:n,maxFeePerGas:r.maxFeePerGas,maxPriorityFeePerGas:r.maxPriorityFeePerGas},e),o=await this.smartAccountAPI.signUserOp(s),c=await this.erc4337provider.constructUserOpTransactionResponse(o);try{await this.httpRpcClient.sendUserOpToBundler(o)}catch(d){throw this.unwrapError(d)}return c}unwrapError(t){try{let i="Unknown Error";if(t.error)i="The bundler has failed to include UserOperation in a batch: ".concat(t.error);else if(t.body&&"string"===typeof t.body){var e,a,r;const n=JSON.parse(t.body),s=t.status||"UNKNOWN",o=(null===n||void 0===n?void 0:n.code)||"UNKNOWN";let c=(null===n||void 0===n||null===(e=n.error)||void 0===e?void 0:e.message)||(null===n||void 0===n||null===(a=n.error)||void 0===a?void 0:a.data)||(null===n||void 0===n?void 0:n.error)||t.reason;if(null!==(r=c)&&void 0!==r&&r.includes("FailedOp")){let t="";const e=c.match(/FailedOp\((.*)\)/);if(e){const a=e[1].split(",");t="(paymaster address: ".concat(a[1],")"),c=a[2]}i="The bundler has failed to include UserOperation in a batch: ".concat(c," ").concat(t)}else i="RPC error: ".concat(c,"\nStatus: ").concat(s,"\nCode: ").concat(o)}const n=new Error(i);return n.stack=t.stack,n}catch(i){}return t}async verifyAllNecessaryFields(t){if(!t.to)throw new Error("Missing call target");if(!t.data&&!t.value)throw new Error("Missing call data or value")}connect(t){throw new Error("changing providers is not supported")}async getAddress(){return this.address||(this.address=await this.erc4337provider.getSenderAccountAddress()),this.address}async signMessage(t){if(await this.smartAccountAPI.checkAccountPhantom()&&this.config.deployOnSign){console.log("Account contract not deployed yet. Deploying account before signing message");const t=await this.sendTransaction({to:await this.getAddress(),data:"0x"});await t.wait()}return await this.originalSigner.signMessage(t)}async signTransaction(t,e){var a;const r=await i.resolveProperties(t);await this.verifyAllNecessaryFields(r);const n=Ct(),s=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:r.to||"",data:(null===(a=r.data)||void 0===a?void 0:a.toString())||"0x",value:r.value,gasLimit:r.gasLimit,nonce:n},e),o=await this.smartAccountAPI.signUserOp(s);return JSON.stringify(await Pt(o))}}class Et extends h.I${constructor(t,e,a,r,i,n,s){super({name:"ERC-4337 Custom Network",chainId:t}),this.chainId=t,this.config=e,this.originalSigner=a,this.originalProvider=r,this.httpRpcClient=i,this.entryPoint=n,this.smartAccountAPI=s,this.signer=new Ft(e,a,this,i,s)}getSigner(){return this.signer}async perform(t,e){if("sendTransaction"===t||"getTransactionReceipt"===t)throw new Error("Should not get here. Investigate.");return"estimateGas"===t?c.iC.from(5e5):await this.originalProvider.perform(t,e)}async getTransaction(t){return await super.getTransaction(t)}async getTransactionReceipt(t){const e=await t,a=await this.getSenderAccountAddress();return await new Promise(((t,r)=>{new Dt(t,r,this.entryPoint,a,e).start()}))}async getSenderAccountAddress(){return await this.smartAccountAPI.getAccountAddress()}async waitForTransaction(t,e,a){const r=await this.getSenderAccountAddress();return await new Promise(((e,i)=>{new Dt(e,i,this.entryPoint,r,t,void 0,a).start()}))}async constructUserOpTransactionResponse(t){const e=await i.resolveProperties(t),a=await this.smartAccountAPI.getUserOpHash(e),r=async()=>await new Promise(((t,r)=>{new Dt(t,r,this.entryPoint,e.sender,a,e.nonce).start()}));return{hash:a,confirmations:0,from:e.sender,nonce:0,gasLimit:c.iC.from(e.callGasLimit),value:c.iC.from(0),data:n.hexValue(e.callData),chainId:this.chainId,wait:async t=>{const a=await r();return 0!==e.initCode.length&&await this.smartAccountAPI.checkAccountPhantom(),a}}}async detectNetwork(){return this.originalProvider.detectNetwork()}}class St{constructor(t){(0,v._)(this,"isPhantom",!0),this.provider=t.provider,this.entryPointAddress=t.entryPointAddress,this.accountAddress=t.accountAddress,this.paymasterAPI=t.paymasterAPI,this.gasless=t.gasless,this.entryPointView=f.EntryPoint__factory.connect(t.entryPointAddress,t.provider).connect(p.e)}async checkAccountPhantom(){if(!this.isPhantom)return this.isPhantom;return(await this.provider.getCode(this.getAccountAddress())).length>2&&(this.isPhantom=!1),this.isPhantom}async getInitCode(){return await this.checkAccountPhantom()?await this.getAccountInitCode():"0x"}async getVerificationGasLimit(){return 1e5}async getUserOpHash(t){const e=await this.provider.getNetwork().then((t=>t.chainId));return async function(t,e,a){const r=await i.resolveProperties(t),n={sender:r.sender,nonce:r.nonce,initCodeHash:s.keccak256(r.initCode),callDataHash:s.keccak256(r.callData),callGasLimit:r.callGasLimit,verificationGasLimit:r.verificationGasLimit,preVerificationGas:r.preVerificationGas,maxFeePerGas:r.maxFeePerGas,maxPriorityFeePerGas:r.maxPriorityFeePerGas,paymasterAndDataHash:s.keccak256(r.paymasterAndData)},c=o.s.encode([{components:[{type:"address",name:"sender"},{type:"uint256",name:"nonce"},{type:"bytes32",name:"initCodeHash"},{type:"bytes32",name:"callDataHash"},{type:"uint256",name:"callGasLimit"},{type:"uint256",name:"verificationGasLimit"},{type:"uint256",name:"preVerificationGas"},{type:"uint256",name:"maxFeePerGas"},{type:"uint256",name:"maxPriorityFeePerGas"},{type:"bytes32",name:"paymasterAndDataHash"}],name:"hashedUserOp",type:"tuple"}],[{...n}]),d=s.keccak256(c),l=o.s.encode(["bytes32","address","uint256"],[d,e,a]);return s.keccak256(l)}(t,this.entryPointAddress,e)}async getAccountAddress(){return this.senderAddress||(this.accountAddress?this.senderAddress=this.accountAddress:this.senderAddress=await this.getCounterFactualAddress()),this.senderAddress}async estimateCreationGas(t){if(!t||"0x"===t)return 0;const e=t.substring(0,42),a="0x"+t.substring(42);return await this.provider.estimateGas({to:e,data:a})}async createUnsignedUserOp(t,e,a){var r;const i=await this.getInitCode(),n=null!==(r=function(t){if(!t||""===t)return null;return c.iC.from(t.toString())}(e.value))&&void 0!==r?r:c.iC.from(0),s=null!==a&&void 0!==a&&a.batchData?e.data:await this.prepareExecute(e.target,n,e.data).then((t=>t.encode()));let{maxFeePerGas:o,maxPriorityFeePerGas:d}=e;if(!o||!d){const t=await(0,A.a)(this.provider);var l;if(!d)d=null!==(l=t.maxPriorityFeePerGas)&&void 0!==l?l:void 0;if(!o){var h;o=null!==(h=t.maxFeePerGas)&&void 0!==h?h:void 0;const e=(await this.provider.getNetwork()).chainId;e!==V.Mp5.chainId&&e!==V.uCI.chainId&&e!==V.gDO.chainId||(d=o)}}if(!o||!d)throw new Error("maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely");const[p,u]=await Promise.all([this.getAccountAddress(),e.nonce?Promise.resolve(e.nonce):this.getNonce()]),y={sender:p,nonce:u,initCode:i,callData:s,maxFeePerGas:o,maxPriorityFeePerGas:d,callGasLimit:c.iC.from(1e6),verificationGasLimit:c.iC.from(1e6),preVerificationGas:c.iC.from(1e6),paymasterAndData:"0x",signature:"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c"};if(void 0!==(null===a||void 0===a?void 0:a.gasless)?a.gasless:this.gasless){const e=await this.paymasterAPI.getPaymasterAndData(y),a=e.paymasterAndData;if(a&&"0x"!==a&&(y.paymasterAndData=a),e.callGasLimit&&e.verificationGasLimit&&e.preVerificationGas)y.callGasLimit=c.iC.from(e.callGasLimit),y.verificationGasLimit=c.iC.from(e.verificationGasLimit),y.preVerificationGas=c.iC.from(e.preVerificationGas);else{let e;try{e=await t.estimateUserOpGas(y)}catch(g){throw this.unwrapBundlerError(g)}if(y.callGasLimit=c.iC.from(e.callGasLimit),y.verificationGasLimit=c.iC.from(e.verificationGasLimit),y.preVerificationGas=c.iC.from(e.preVerificationGas),a&&"0x"!==a){const t=await this.paymasterAPI.getPaymasterAndData(y);t.paymasterAndData&&"0x"!==t.paymasterAndData&&(y.paymasterAndData=t.paymasterAndData)}}}else{let e;try{e=await t.estimateUserOpGas(y)}catch(g){throw this.unwrapBundlerError(g)}y.callGasLimit=c.iC.from(e.callGasLimit),y.verificationGasLimit=c.iC.from(e.verificationGasLimit),y.preVerificationGas=c.iC.from(e.preVerificationGas)}return{...y,signature:""}}async signUserOp(t){const e=await this.getUserOpHash(t),a=await this.signUserOpHash(e);return{...t,signature:a}}async getUserOpReceipt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3e4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2e3;const r=Date.now()+e;for(;Date.now()<r;){const e=await this.entryPointView.queryFilter(this.entryPointView.filters.UserOperationEvent(t));if(e[0])return e[0].transactionHash;await new Promise((t=>setTimeout(t,a)))}return null}unwrapBundlerError(t){var e;const a=(null===t||void 0===t||null===(e=t.error)||void 0===e?void 0:e.message)||t.error||t.message||t;return new Error(a)}}class Bt extends St{constructor(t,e){super({...t,provider:e}),this.params=t,this.sdk=ft.fromPrivateKey(tt,t.chain,{clientId:t.clientId,secretKey:t.secretKey,supportedChains:"object"===typeof t.chain?[t.chain]:void 0})}async getChainId(){return await this.provider.getNetwork().then((t=>t.chainId))}async getAccountContract(){var t;this.accountContract||(null!==(t=this.params.accountInfo)&&void 0!==t&&t.abi?this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),this.params.accountInfo.abi):this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),b.A));return this.accountContract}async getAccountInitCode(){const t=await this.getFactoryContract();console.log("Deploying smart wallet via factory");const e=await this.params.localSigner.getAddress(),a=await this.params.factoryInfo.createAccount(t,e);try{console.log("Cost to deploy smart wallet: ",(await a.estimateGasCost()).ether,"ETH")}catch(r){console.error("Cost to deploy smart wallet: unknown",r)}return n.hexConcat([t.getAddress(),a.encode()])}async getFactoryContract(){var t;return this.factoryContract||(null!==(t=this.params.factoryInfo)&&void 0!==t&&t.abi?this.factoryContract=await this.sdk.getContract(this.params.factoryAddress,this.params.factoryInfo.abi):this.factoryContract=await this.sdk.getContract(this.params.factoryAddress)),this.factoryContract}async getCounterFactualAddress(){if(this.params.accountAddress)return this.params.accountAddress;const t=await this.getFactoryContract(),e=await this.params.localSigner.getAddress();return this.params.factoryInfo.getAccountAddress(t,e)}async getNonce(){if(await this.checkAccountPhantom())return c.iC.from(0);const t=await this.getAccountContract();return this.params.accountInfo.getNonce(t)}async prepareExecute(t,e,a){const r=await this.getAccountContract();return this.params.accountInfo.execute(r,t,e,a)}async prepareExecuteBatch(t,e,a){return(await this.getAccountContract()).prepare("executeBatch",[t,e,a])}async signUserOpHash(t){return await this.params.localSigner.signMessage(n.arrayify(t))}async isAcountDeployed(){return!await this.checkAccountPhantom()}}class Ot extends r.C{constructor(t){super(),this.config=t}async initialize(t){var e;const a=this.config,r=(0,C.a_)(a.chain,{clientId:a.clientId,secretKey:a.secretKey});this.chainId=(await r.getNetwork()).chainId;const i=this.config.bundlerUrl||"https://".concat(this.chainId,".bundler.thirdweb.com"),n=this.config.paymasterUrl||"https://".concat(this.chainId,".bundler.thirdweb.com/v2"),s=a.entryPointAddress||b.E,o=null===(e=a.deployOnSign)||void 0===e||e,c=await t.personalWallet.getSigner(),d={chain:a.chain,localSigner:c,entryPointAddress:s,bundlerUrl:i,paymasterAPI:this.config.paymasterAPI?this.config.paymasterAPI:It(n,s,this.config.clientId,this.config.secretKey),gasless:a.gasless,deployOnSign:o,factoryAddress:a.factoryAddress,accountAddress:t.accountAddress,factoryInfo:a.factoryInfo||this.defaultFactoryInfo(),accountInfo:a.accountInfo||this.defaultAccountInfo(),clientId:a.clientId,secretKey:a.secretKey};this.personalWallet=t.personalWallet;const l=new Bt(d,r);this.aaProvider=function(t,e,a,r){const i=f.EntryPoint__factory.connect(t.entryPointAddress,a),n=new _t(t.bundlerUrl,t.entryPointAddress,r,t.clientId,t.secretKey);return new Et(r,t,t.localSigner,a,n,i,e)}(d,l,r,this.chainId),this.accountApi=l}async connect(t){return await this.initialize(t),await this.getAddress()}getProvider(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider)}async getSigner(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider.getSigner())}async getAddress(){return(await this.getSigner()).getAddress()}async isConnected(){try{return!!await this.getAddress()}catch(t){return!1}}async disconnect(){this.personalWallet=void 0,this.aaProvider=void 0}async switchChain(t){const e=await this.getProvider();if((await e.getNetwork()).chainId!==t)throw new Error("Not supported.")}setupListeners(){return Promise.resolve()}updateChains(t){}async hasPermissionToExecute(t){var e;const a=await this.getAccountContract(),r=await this.getSigner(),i=await r.getAddress(),n=null===(e=(await a.account.getAllSigners()).filter((t=>u.getAddress(t.signer)===u.getAddress(i)))[0])||void 0===e?void 0:e.permissions;return!!n&&n.approvedCallTargets.includes(t.getTarget())}async send(t,e){return(await this.getSigner()).sendTransaction({to:t.getTarget(),data:t.encode(),value:await t.getValue()},e)}async execute(t,e){const a=await this.send(t,e);return{receipt:await a.wait()}}async sendBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),{tx:r,batchData:i}=await this.prepareBatchTx(t);return await a.sendTransaction({to:await a.getAddress(),data:r.encode(),value:0},{...e,batchData:i})}async executeBatch(t,e){const a=await this.sendBatch(t,e);return{receipt:await a.wait()}}async sendRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return(await this.getSigner()).sendTransaction(t,e)}async executeRaw(t,e){const a=await this.sendRaw(t,e);return{receipt:await a.wait()}}async sendBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),r=await this.prepareBatchRaw(t);return a.sendTransaction({to:await a.getAddress(),data:r.tx.encode(),value:0},{...e,batchData:r.batchData})}async executeBatchRaw(t,e){const a=await this.sendBatchRaw(t,e);return{receipt:await a.wait()}}async estimate(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return this.estimateTx({target:t.getTarget(),data:t.encode(),value:await t.getValue(),gasLimit:await t.getOverrides().gasLimit,maxFeePerGas:await t.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await t.getOverrides().maxPriorityFeePerGas,nonce:await t.getOverrides().nonce},e)}async estimateRaw(t,e){var a;if(!this.accountApi)throw new Error("Personal wallet not connected");const r=await i.resolveProperties(t);return this.estimateTx({target:r.to||p.e,data:(null===(a=r.data)||void 0===a?void 0:a.toString())||"",value:r.value||c.iC.from(0),gasLimit:r.gasLimit,maxFeePerGas:r.maxFeePerGas,maxPriorityFeePerGas:r.maxPriorityFeePerGas,nonce:r.nonce},e)}async estimateBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:r}=await this.prepareBatchTx(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:r})}async estimateBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:r}=await this.prepareBatchRaw(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:r})}async deploy(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await this.getSigner(),a=await e.sendTransaction({to:await e.getAddress(),data:"0x"},{...t,batchData:{targets:[],data:[],values:[]}});return{receipt:await a.wait()}}async isDeployed(){if(!this.accountApi)throw new Error("Personal wallet not connected");return await this.accountApi.isAcountDeployed()}async deployIfNeeded(t){await this.isDeployed()||await this.deploy(t)}async grantPermissions(t,e){await this.deployIfNeeded();return(await this.getAccountContract()).account.grantPermissions(t,e)}async revokePermissions(t){await this.deployIfNeeded();return(await this.getAccountContract()).account.revokeAccess(t)}async addAdmin(t){await this.deployIfNeeded();return(await this.getAccountContract()).account.grantAdminPermissions(t)}async removeAdmin(t){await this.deployIfNeeded();return(await this.getAccountContract()).account.revokeAdminPermissions(t)}async getAllActiveSigners(){if(await this.isDeployed()){return(await this.getAccountContract()).account.getAllAdminsAndSigners()}{var t;const e=await(null===(t=this.personalWallet)||void 0===t?void 0:t.getSigner());if(!e)throw new Error("Personal wallet not connected");return[{isAdmin:!0,signer:await e.getAddress(),permissions:{startDate:new Date(0),expirationDate:new Date(0),nativeTokenLimitPerTransaction:c.iC.from(0),approvedCallTargets:[]}}]}}async getAccountContract(){var t;if(!await this.isDeployed())throw new Error("Account contract is not deployed yet. You can deploy it manually using SmartWallet.deploy(), or by executing a transaction from this wallet.");const e=ft.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return null!==(t=this.config.accountInfo)&&void 0!==t&&t.abi?e.getContract(await this.getAddress(),this.config.accountInfo.abi):e.getContract(await this.getAddress())}async getFactoryContract(){var t;const e=ft.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return null!==(t=this.config.factoryInfo)&&void 0!==t&&t.abi?e.getContract(this.config.factoryAddress,this.config.factoryInfo.abi):e.getContract(this.config.factoryAddress)}defaultFactoryInfo(){return{createAccount:async(t,e)=>t.prepare("createAccount",[e,y.kT("")]),getAccountAddress:async(t,e)=>await t.call("getAddress",[e,y.kT("")])}}defaultAccountInfo(){return{execute:async(t,e,a,r)=>t.prepare("execute",[e,a,r]),getNonce:async t=>t.call("getNonce",[])}}async estimateTx(t,e){if(!this.accountApi||!this.aaProvider)throw new Error("Personal wallet not connected");let a=c.iC.from(0);const[r,n]=await Promise.all([this.getProvider(),this.isDeployed()]);n||(a=await this.estimateDeploymentGasLimit());const[s,o]=await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient,t,e),(0,A.b)(r)]),d=await i.resolveProperties(s),l=c.iC.from(d.callGasLimit),h=l.mul(o),p=a.mul(o),u=p.add(h);return{ether:g.formatEther(u),wei:u,details:{deployGasLimit:a,transactionGasLimit:l,gasPrice:o,transactionCost:h,deployCost:p,totalCost:u}}}async estimateDeploymentGasLimit(){if(!this.accountApi)throw new Error("Personal wallet not connected");const t=await this.accountApi.getInitCode(),[e,a]=await Promise.all([this.accountApi.estimateCreationGas(t),this.accountApi.getVerificationGasLimit()]);return c.iC.from(a).add(e)}async prepareBatchRaw(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await Promise.all(t.map((t=>i.resolveProperties(t)))),a=e.map((t=>t.to||p.e)),r=e.map((t=>t.data||"0x")),n=e.map((t=>t.value||c.iC.from(0)));return{tx:await this.accountApi.prepareExecuteBatch(a,n,r),batchData:{targets:a,data:r,values:n}}}async prepareBatchTx(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=t.map((t=>t.getTarget())),a=t.map((t=>t.encode())),r=await Promise.all(t.map((t=>t.getValue())));return{tx:await this.accountApi.prepareExecuteBatch(e,r,a),batchData:{targets:e,data:a,values:r}}}}}}]);
//# sourceMappingURL=4662.8603eca2.chunk.js.map